<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++ 内存四区 理解总结 | 时光如水の总是无言</title><meta name="description" content="内存模型图（4G） 整体简单说明32位CPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中 0~3G是用户空间，3~4G是内核空间即3G用户空间和1G内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。 各段详细说明静态区域： text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。 data segment(数据段)"><meta name="keywords" content="内存四区"><meta name="author" content="时光如水の总是无言"><meta name="copyright" content="时光如水の总是无言"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wuhongbin.github.io/2020/04/01/C++%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="C++ 内存四区 理解总结"><meta property="og:url" content="https://wuhongbin.github.io/2020/04/01/C++%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="时光如水の总是无言"><meta property="og:description" content="内存模型图（4G） 整体简单说明32位CPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中 0~3G是用户空间，3~4G是内核空间即3G用户空间和1G内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。 各段详细说明静态区域： text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。 data segment(数据段)"><meta property="og:image" content="https://s1.ax1x.com/2020/06/28/NgTarT.jpg"><meta property="article:published_time" content="2020-03-31T19:10:43.000Z"><meta property="article:modified_time" content="2020-06-28T08:26:05.695Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="C++ 函数模板和函数重载同时出现如何调用" href="https://wuhongbin.github.io/2020/04/03/C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8/"><link rel="next" title="C++ 重载、重写、重定义的区别" href="https://wuhongbin.github.io/2020/03/21/C++%20%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%87%8D%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="时光如水の总是无言" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">73</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">50</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book-open"></i><span> 书籍</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-smile-wink"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw far fa-comment-dots"></i><span> 留言</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存模型图（4G）"><span class="toc-number">1.</span> <span class="toc-text">内存模型图（4G）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#整体简单说明"><span class="toc-number">1.1.</span> <span class="toc-text">整体简单说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#各段详细说明"><span class="toc-number">1.2.</span> <span class="toc-text">各段详细说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存四区"><span class="toc-number">2.</span> <span class="toc-text">内存四区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#明确区分堆与栈"><span class="toc-number">3.</span> <span class="toc-text">明确区分堆与栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆和栈的区别"><span class="toc-number">4.</span> <span class="toc-text">堆和栈的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-用来控制变量的存储方式和可见性"><span class="toc-number">5.</span> <span class="toc-text">static 用来控制变量的存储方式和可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数调用模型"><span class="toc-number">6.</span> <span class="toc-text">函数调用模型</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s1.ax1x.com/2020/06/28/NgTarT.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">时光如水の总是无言</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book-open"></i><span> 书籍</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-smile-wink"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw far fa-comment-dots"></i><span> 留言</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">C++ 内存四区 理解总结</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date" title="发表于 2020-04-01 03:10:43"><i class="fa-fw far fa-calendar-alt"></i> 发表于 2020-04-01</time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/C-C/">C / C + +</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">4.6k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 14 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="内存模型图（4G）"><a href="#内存模型图（4G）" class="headerlink" title="内存模型图（4G）"></a>内存模型图（4G）</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/04/17/JZrp0U.png" alt="img"></p>
<h3 id="整体简单说明"><a href="#整体简单说明" class="headerlink" title="整体简单说明"></a>整体简单说明</h3><p>32位CPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中 <strong>0~3G是用户空间</strong>，<strong>3~4G是内核空间</strong>即<strong>3G用户空间和1G内核空间</strong>，不同进程相同的逻辑地址会映射到不同的物理地址中。</p>
<h3 id="各段详细说明"><a href="#各段详细说明" class="headerlink" title="各段详细说明"></a>各段详细说明</h3><p><strong>静态区域：</strong></p>
<p>text segment(<strong>代码段</strong>):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
<p>data segment(<strong>数据段</strong>)：存储程序中已初始化的全局变量和静态变量</p>
<p>bss segment(<strong>BSS段</strong>)：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0</p>
<p><strong>动态区域：</strong></p>
<p>heap（<strong>堆区</strong>）：  当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。</p>
<p>memory mapping segment(<strong>映射区</strong>):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）</p>
<p>stack（<strong>栈区</strong>）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。</p>
<h2 id="内存四区"><a href="#内存四区" class="headerlink" title="内存四区"></a>内存四区</h2><p>一个由C/C++编译的程序占用的内存分为以下几个部分：</p>
<ol>
<li><p><strong>栈区(stack)</strong>：就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是函数的返回地址、参数、局部变量、返回值等，从高地址向低地址增长。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。其操作方式类似于数据结构中的栈。</p>
</li>
<li><p><strong>堆区(heap)</strong>： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。</p>
<p>​    <strong>堆</strong>：是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free()可把内存交还。</p>
<p>​    <strong>自由存储区</strong>：自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区和堆区就有区别了。</p>
</li>
<li><p><strong>数据区</strong>：主要包括静态全局区和静态区，如果要站在汇编角度细分的话还可以分为很多小的区。</p>
<p>​    <strong>全局区&amp;静态区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的 C 语言中，全局变量和静态变量又分为</p>
</li>
</ol>
<p>　　　　全局初始化区(<strong>DATA段</strong>) ：存储程序中已初始化的全局变量和静态变量</p>
<p>　　　　未初始化段(<strong>BSS段</strong>) ：存储未初始化的全局变量和静态变量（局部+全局）。BSS段在DATA段的相邻的  另一块区域。BBS段特点：在程序执行前BBS段自动清零，所以未初始化的全局变量和静态变量在程序执行前已经成为0。</p>
<p>　　<font color=red><strong>在 C++ 里面没有这个区分了，它们共同占用同一块内存区。</strong></font></p>
<ol start="4">
<li><strong>代码区</strong>：包括<strong>只读存储区</strong>和<strong>文本区</strong>，其中<strong>只读存储区</strong>存储<strong>字符串常量</strong>，就是常量区，<strong>文本区</strong>存储<strong>程序的机器代码</strong>。</li>
</ol>
<h2 id="明确区分堆与栈"><a href="#明确区分堆与栈" class="headerlink" title="明确区分堆与栈"></a>明确区分堆与栈</h2><p>在 BBS 上，堆与栈的区分问题，似乎是一个永恒的话题，由此可见，初学者对此往往是混淆不清的，所以我决定拿他第一个开刀。</p>
<p>首先，我们举一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; &#125;</span><br></pre></td></tr></table></figure>

<p>这条短短的一句话就包含了堆与栈，看到 new，我们首先就应该想到，我们分配了一块堆内存，那么指针 p  呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针 p。在程序会先确定在堆中分配内存的大小，然后调用  operator new 分配内存，然后返回这块内存的首地址，放入栈中，他在 VC6 下的汇编代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00401028</span>push <span class="number">14</span>h</span><br><span class="line"><span class="number">0040102</span><span class="function">Acall <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="number">00401060</span>)</span></span></span><br><span class="line">0040102Fadd esp,4</span><br><span class="line"><span class="number">00401032</span>mov dword ptr [ebp<span class="number">-8</span>],eax</span><br><span class="line"><span class="number">00401035</span>mov eax,dword ptr [ebp<span class="number">-8</span>]</span><br><span class="line"><span class="number">00401038</span>mov dword ptr [ebp<span class="number">-4</span>],eax</span><br></pre></td></tr></table></figure>

<p>这里，我们为了简单并没有释放内存，那么该怎么去释放呢？</p>
<p>是 delete p 么？噢，错了，应该是 delete []p，这是为了告诉编译器：我删除的是一个数组，VC6 就会根据相应的 Cookie 信息去进行释放内存的工作。</p>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>好了，我们回到我们的主题：堆和栈究竟有什么区别？主要的区别由以下几点：</p>
<ol>
<li>管理方式不同；</li>
<li>空间大小不同；</li>
<li>能否产生碎片不同；</li>
<li>生长方向不同；</li>
<li>分配方式不同；</li>
<li>分配效率不同；</li>
</ol>
<p><strong><font color=red>管理方式：</font></strong>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p>
<p><strong><font color=red>空间大小：</font></strong>一般来讲在 32  位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：打开工程，依次操作菜单如下：Project-&gt;Setting-&gt;Link，在 Category 中选中 Output，然后在 Reserve 中设定堆栈的最大值和 commit。注意：reserve 最小值为  4Byte；commit 是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。</p>
<p><strong><font color=red>碎片问题：</font></strong>对于堆来讲，频繁的  new/delete  势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。</p>
<p><strong><font color=red>生长方向：</font></strong>对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</p>
<p><strong><font color=red>分配方式：</font></strong>堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>
<p><strong><font color=red>分配效率：</font></strong>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是 C/C++  函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p>
<p>​        从这里我们可以看到，堆和栈相比，由于大量 new/delete  的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP 和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。</p>
<p>　　虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。</p>
<p>　　无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候 debug 可是相当困难的）</p>
<p>　　对了，还有一件事，如果有人把堆栈合起来说，那它的意思是栈，可不是堆，呵呵，清楚了？</p>
<h2 id="static-用来控制变量的存储方式和可见性"><a href="#static-用来控制变量的存储方式和可见性" class="headerlink" title="static 用来控制变量的存储方式和可见性"></a>static 用来控制变量的存储方式和可见性</h2><p>函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？  最容易想到的方法是定义一个全局的变量，但定义为一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅受此函数控制）。需要一个数据对象为整个类而非某个对象服务，同时又力求不破坏类的封装性，即要求此成员隐藏在类的内部，对外不可见。</p>
<p><strong>static 的内部机制：</strong></p>
<p>　　静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；三是应用程序的 main(）函数前的全局数据声明和定义处。</p>
<p>　　静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的“尺寸和规格”，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。</p>
<p>　　static 被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。</p>
<p><strong>static 的优势：</strong></p>
<p>　　可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。引用静态数据成员时，采用如下格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;静态成员名&gt;</span><br></pre></td></tr></table></figure>

<p>　　如果静态数据成员的访问权限允许的话(即 public 的成员)，可在程序中，按上述格式来引用静态数据成员。</p>
<p>Ps：</p>
<p>　　(1) 类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。</p>
<p>　　(2) 不能将静态成员函数定义为虚函数。</p>
<p>　　(3) 由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针，函数地址类型是一个“nonmember 函数指针”。</p>
<p>　　(4) 由于静态成员函数没有 this 指针，所以就差不多等同于 nonmember 函数，结果就产生了一个意想不到的好处：成为一个  callback 函数，使得我们得以将 c++ 和 c-based x window 系统结合，同时也成功的应用于线程函数身上。</p>
<p>　　(5) static 并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。</p>
<p>　　(6) 静态数据成员在&lt;定义或说明&gt;时前面加关键字 static。</p>
<p>　　(7) 静态数据成员是静态存储的，所以必须对它进行初始化。</p>
<p>　　(8) 静态成员初始化与一般数据成员初始化不同：</p>
<p>　　初始化在类体外进行，而前面不加 static，以免与一般静态变量或对象相混淆；</p>
<p>　　初始化时不加该成员的访问权限控制符 private、public；</p>
<p>　　初始化时使用作用域运算符来标明它所属类；</p>
<p>　　所以我们得出静态数据成员初始化的格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</span><br></pre></td></tr></table></figure>

<p>　　(9)  为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。</p>
<p>​        <strong>注意：</strong>我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</p>
<h2 id="函数调用模型"><a href="#函数调用模型" class="headerlink" title="函数调用模型"></a>函数调用模型</h2><p>变量三要素是：名称、大小、作用域。那么变量的生命周期是多长呢？</p>
<p>编译器是如何管理每个函数间变量的生命周期呢？</p>
<p>要研究变量的生命周期，而变量一般又是在函数中定义分配空间的。</p>
<p>因此下面研究一下变量作为函数参数和返回值传递分析,下面我们具体总结一下，各个函数的变量的生命周期</p>
<p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190809175733510-648621844.png" alt=""></p>
<p>main里面的变量分配内存，函数fa(),函数fb()中的变量分配的内存空间它们的生命周期都是多长呢？</p>
<p>开始已经说明了内存主要分为四区，因此每个函数中变量在堆栈的生命周期是不同的，同时在函数调用的时候，先执行的函数最后才执行完毕</p>
<p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190809175748821-260989720.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">fa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span>*pa = <span class="string">"123456"</span>;<span class="comment">//pa指针在栈区，“123456”在常量区，该函数调用完后指针变量pa就被释放了</span></span><br><span class="line">     <span class="keyword">char</span>*p = <span class="literal">NULL</span>;     <span class="comment">//指针变量p在栈中分配4字节</span></span><br><span class="line">     p=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);<span class="comment">//本函数在这里开辟了一块堆区的内存空间，并把地址赋值给p</span></span><br><span class="line">     <span class="built_in">strcpy</span>(p, <span class="string">"wudunxiong 1234566"</span>);<span class="comment">//把常量区的字符串拷贝到堆区</span></span><br><span class="line">     <span class="keyword">return</span> p;<span class="comment">//返回给主调函数fb()，相对fa来说fb是主调函数，相对main来说，fa(),fb()都是被调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">fb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span>*pstr = <span class="literal">NULL</span>;</span><br><span class="line">     pstr = fa();</span><br><span class="line">     <span class="keyword">return</span> pstr;<span class="comment">//指针变量pstr在这就结束</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     <span class="keyword">char</span>*str = <span class="literal">NULL</span>;</span><br><span class="line">     str = fb();</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"str = %s\n"</span>,str);</span><br><span class="line">     <span class="built_in">free</span>(str);    <span class="comment">//防止内存泄露，被调函数fa()分配的内存存的值通过返回值传给主调函数，然后主调函数释放内存</span></span><br><span class="line">     str = <span class="literal">NULL</span>;<span class="comment">//防止产生野指针</span></span><br><span class="line">     system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数调用总结：</p>
<ol>
<li><p>主调函数分配的内存空间（堆，栈，全局区）可以在被调用函数中使用，可以以指针作函数参数的形式来使用</p>
</li>
<li><p>被调用函数分配的内存空间只有堆区和全局区可以在主调函数中使用（返回值和函数参数），而栈区却不行，因为栈区函数体运行完之后这个函数占用的内存编译器自动帮你释放了。</p>
</li>
<li><p>一定要明白函数的主被调关系以及主被调函数内存分配回收，也就是后面接下几篇总结的函数的输入输出内存模型</p>
</li>
</ol>
<p>[参考: <a href="https://www.cnblogs.com/WindSun/p/11328820.html]" target="_blank" rel="noopener">https://www.cnblogs.com/WindSun/p/11328820.html]</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">时光如水の总是无言</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wuhongbin.github.io/2020/04/01/C++%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93/">https://wuhongbin.github.io/2020/04/01/C++%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wuhongbin.github.io" target="_blank">时光如水の总是无言</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA/">内存四区</a></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2020/07/30/aK1iZD.jpg" data-sites="wechat,weibo,qq,qzone,douban,google,facebook,twitter,linkedin"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信" onclick="window.open('/img/wechat.jpg')"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付宝" onclick="window.open('/img/alipay.jpg')"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/04/03/C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8/"><img class="prev-cover" data-src="https://s1.ax1x.com/2020/06/28/NgTarT.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++ 函数模板和函数重载同时出现如何调用</div></div></a></div><div class="next-post pull-right"><a href="/2020/03/21/C++%20%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%87%8D%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/"><img class="next-cover" data-src="https://s1.ax1x.com/2020/06/28/NgTarT.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++ 重载、重写、重定义的区别</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')
let friends = '5c2105bbfe6rfc02a6f6ae26dad3819c,a0adabb31677df92a2405fb18a02ee4d'.split(',')
let master = 'f8c7c3961aea2c203160e90cd3b3a26a'.split(',')
let tagMeta = '博主,小伙伴,访客'.split(',')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'VCilC4G13xxkwKr2R13ozU6f-gzGzoHsz',
  appKey: 'SUpuL0qdmqksfPHQfRsBOSJn',
  notify: false,
  verify: false,
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: 'false',
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields,
  master: master,
  friends: friends,
  tagMeta: tagMeta,
  metaPlaceholder: {"nick":"昵称/QQ号(必填)","mail":"邮箱(必填)","link":"网址(https://)"}
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 时光如水の总是无言</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">本博客所有内容均收集于互联网或自己创作,方便与网友学习交流，如有侵权，请留言，立即处理!!</div><div class="icp"><a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>© 晋ICP备案87650516号-8</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">简</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/third-party/click_heart.js"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>