<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>时光如水の总是无言</title>
  
  <subtitle>wuhongbin&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuhongbin.github.io/"/>
  <updated>2020-07-31T04:59:51.211Z</updated>
  <id>https://wuhongbin.github.io/</id>
  
  <author>
    <name>时光如水の总是无言</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>查找之折半(二分)查找 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/11/%E6%9F%A5%E6%89%BE%E4%B9%8B%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/11/%E6%9F%A5%E6%89%BE%E4%B9%8B%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-11T11:15:50.000Z</published>
    <updated>2020-07-31T04:59:51.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>折半查找：</strong>又称二分查找，仅适用于 <strong>有序的顺序表</strong></p><h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><ol><li><p>首先将给定值key与表中中间位置元素的关键字比较,  </p></li><li><p>若相等,则返回该元素的位置;  </p></li><li><p>若不等,则在前半部分或者是后半部分进行查找。 </p></li></ol><blockquote><p>查找序列升序时,  </p><p>若key小于中间元素,则查找前半部分  </p><p>若key大于中间元素,则查找后半部分。  </p></blockquote><ol start="4"><li>重复该过程,直到找到查找的元素为止;或查找失败。</li></ol><h1 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(SeqList L, ElemType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> low=<span class="number">0</span>, high=L.TableLen<span class="number">-1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">    mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.elem[mid] == key)  </span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid] &gt; key)</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">            Low = mid + <span class="number">1</span>;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>折半查找的时间复杂度为 O(log2n)</strong></p></blockquote><h1 id="判定树"><a href="#判定树" class="headerlink" title="判定树"></a>判定树</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQ0Hc8.png" alt=""></p><blockquote><p>若该判定树是 <strong>满二叉树</strong> 时，</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQ0xNn.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQBkB4.png" alt=""></p></blockquote><blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQB3HH.png" alt=""></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;折半查找：&lt;/strong&gt;又称二分查找，仅适用于 &lt;strong&gt;有序的顺序表&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="查找" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9F%A5%E6%89%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>查找之顺序(线性)查找 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/11/%E6%9F%A5%E6%89%BE%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/11/%E6%9F%A5%E6%89%BE%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-11T10:15:50.000Z</published>
    <updated>2020-07-31T04:34:12.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>顺序查找：</strong>又称线性查找，主要用于在<strong>线性表</strong>中进行查找。</p><h1 id="无序线性表的顺序查找"><a href="#无序线性表的顺序查找" class="headerlink" title="无序线性表的顺序查找"></a>无序线性表的顺序查找</h1><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQMvkQ.png" alt=""></p><blockquote><p>对无序线性表进行顺序查找，查找失败时要 <strong>遍历整个线性表</strong></p></blockquote><h2 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        ElemType *elem;</span><br><span class="line">        <span class="keyword">int</span> TableLen;</span><br><span class="line">&#125;SSTable;<span class="comment">//查找表</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_Seg</span><span class="params">(SStable ST,ElemType key)</span></span>&#123;</span><br><span class="line">        ST.elem[<span class="number">0</span>] = key; <span class="comment">//哨兵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ST.Tablelen; ST.elem[i] != key; i--);</span><br><span class="line">        <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>哨兵作用：</strong> 查找失败返回哨兵下标即0，查找成功返回查找到的元素下标。如果没有哨兵，则需要加一个if判断，是否查找到指定元素。<strong>使用哨兵可以精简代码量。</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQ1msx.png" alt=""></p><h1 id="有序线性表的顺序查找"><a href="#有序线性表的顺序查找" class="headerlink" title="有序线性表的顺序查找"></a>有序线性表的顺序查找</h1><h2 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQ1aef.png" alt=""></p><blockquote><p>对关键字有序线性表进行顺序查找，查找失败时 <strong>不一定要遍历整个线性表</strong></p></blockquote><h2 id="判定树"><a href="#判定树" class="headerlink" title="判定树"></a>判定树</h2><p><strong>判定树：</strong> 描述查找过程的二叉排序树</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQG5tS.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQGbXn.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;顺序查找：&lt;/strong&gt;又称线性查找，主要用于在&lt;strong&gt;线性表&lt;/strong&gt;中进行查找。&lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="查找" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="顺序查找" scheme="https://wuhongbin.github.io/tags/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>查找的基本概念 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/11/%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/11/%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-11T08:15:43.000Z</published>
    <updated>2020-07-31T04:58:51.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQVP9f.png" alt=""></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><blockquote><p><strong>查找：</strong>在数据集合中寻找满足某种条件的数据元素的过程。 </p><p>查找结果分为 <strong>查找成功</strong> 和 <strong>查找失败</strong>。</p></blockquote><blockquote><p>*<em>查找表:  *</em>用于查找的数据集合, 由同一种数据类型(或记录)的组成, 可以是一个数组或链表等数据类型  </p><p>操作:    </p><ol><li>检索满足条件的某个特定的数据元素的各种属性</li><li>查询某个特定的数据元素是否在查找表中    </li><li>在查找表中插入一个数据元素  </li><li>从查找表中删除一个数据元素</li></ol><p>操作1和2合起来称作 <strong>静态查找表</strong> , 全部操作合起来称作 <strong>动态查找表</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQAdd1.png" alt=""></p><blockquote><p>*<em>关键字:  *</em> 数据元素中唯一标识该元素的某个数据项的值, 使用基于关键字的查找, 查找结果应该是唯一的。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQAwIx.png" alt=""></p><blockquote><p><strong>平均查找长度：</strong>  查找时,关键字比较次数的平均值:</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQkcEq.png" alt=""></p><p>一般用于衡量一个查找算法的<strong>查找效率</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h1&gt;&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-src=&quot;https://s1.ax1x.com/2020/07/31/
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="查找" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9F%A5%E6%89%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>图的应用之关键路径 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/10/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/10/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-10T02:15:43.000Z</published>
    <updated>2020-07-30T10:37:55.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><p><strong>AOE网：</strong>在有向带权图中, 以顶点表示事件, 以有向边表示活动, 以边上权值表示完成该活动的开销(如完成活动所需要的时间), 则称这种有向图为用边 表示活动的网络, 简称 <strong>AOE网</strong> 。</p><p><strong>源点：</strong>没有入边的顶点（有且只有一个）</p><p><strong>汇点：</strong>没有出边的顶点（有且只有一个）</p><p><strong>关键路径：</strong>从原点到汇点最大路径长度的路径称为 <strong>关键路径</strong>, 键路径上的活动为 <strong>关键活动</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/anvC1f.png" alt=""></p><h1 id="基本计算"><a href="#基本计算" class="headerlink" title="基本计算"></a>基本计算</h1><blockquote><p><strong>事件Vk的最早发生时间 Ve(k)</strong></p><p>利用事件的入边，取最大值</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/anxsMT.png" alt=""></p><blockquote><p><strong>事件Vk的最迟发生时间 Vl(k)</strong></p><p>利用事件的出边，取最小值</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/aupgeS.png" alt=""></p><blockquote><p><strong>活动ai的最早开始时间e(i)</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/auEvMd.png" alt=""></p><blockquote><p><strong>活动ai的最迟开始时间l(i)</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/auV3z4.png" alt=""></p><blockquote><p><strong>活动ai的差额d(i) = l(i) - e(i)</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/auVbmn.png" alt=""></p><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/auea8O.png" alt=""></p><blockquote><p>当网中关键路径 <strong>不唯一</strong> 时，只有加快的关键活动或关键活动组合包括在 <strong>所有的关键路径</strong> 上才能缩短工期。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本定义&quot;&gt;&lt;a href=&quot;#基本定义&quot; class=&quot;headerlink&quot; title=&quot;基本定义&quot;&gt;&lt;/a&gt;基本定义&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;AOE网：&lt;/strong&gt;在有向带权图中, 以顶点表示事件, 以有向边表示活动, 以边上权值表示完成该活动
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="关键路径" scheme="https://wuhongbin.github.io/tags/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>图的应用之拓扑排序 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/09/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/09/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-09T06:15:43.000Z</published>
    <updated>2020-07-30T10:38:25.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><blockquote><p><strong>有向无环图：</strong>不存在环的有向图, 简称<strong>DAG图</strong>。    </p><p><strong>AOV网：</strong>若用一个DAG图表示一个工程,其顶点表示活动, 用 有向边&lt;vi, vj&gt;表示活动vi先于活动vj进行的传递关系,则将这种DAG称为<strong>顶点表示活动网络</strong>, 记为<strong>AOV网</strong>。 </p></blockquote><p><strong>拓扑排序：</strong>对DAG所有顶点的一种排序, 使若存在一条从顶点A 到顶点B的路径,在排序中B排在A的后面。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeHxTf.png" alt=""></p><h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><ol><li>从DAG图中选择一个没有前驱的顶点并输出</li><li>从图中删除该顶点和所有以它为起点的有向边</li><li>重复1、2 ，直到当前的DAG图为空或当前图中不存在无前驱的顶点为止。后一种情况说明图中 <strong>有环</strong>。</li></ol><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><h2 id="例1-（无环）"><a href="#例1-（无环）" class="headerlink" title="例1 （无环）"></a>例1 （无环）</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeL9Mj.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeLSzQ.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeLCss.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeqzRg.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeLPLn.png" alt=""></p><h2 id="例2（有环）"><a href="#例2（有环）" class="headerlink" title="例2（有环）"></a>例2（有环）</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeOptK.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeO9fO.png" alt=""></p><blockquote><p><strong>算法结束时没有访问所有顶点,则存在以剩下顶点组成的环。</strong></p></blockquote><h2 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeXi5V.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeXPU0.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeXkCT.png" alt=""></p><blockquote><p><strong>拓扑排序的结果不一定唯一。</strong></p></blockquote><h1 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//温馨提示：以下代码只看思路，不必深究细节</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TopologicalSort</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Initstack(S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) <span class="comment">//入度为0</span></span><br><span class="line">            Push(S,i);<span class="comment">//入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录统计输出顶点的个数</span></span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(S))<span class="comment">//空：图中不存在入度为0的节点   非空：进入循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pop(S, i); <span class="comment">//弹出栈顶元素，弹出一入度为0的顶点</span></span><br><span class="line">        <span class="built_in">print</span>[count++] = i;<span class="comment">//保存当前出栈的入度为0的节点下标  </span></span><br><span class="line">        <span class="keyword">for</span>(p=G.Vertices[i].firstarc; p; p=p-&gt;nextarc)<span class="comment">//遍历边表</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[v]))<span class="comment">//若-1后，入度为0，则入栈</span></span><br><span class="line">                Push(S, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; G.vexnum) <span class="comment">//为真说明图中有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//排序失败</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//排序成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度为 <strong>O（|V| + |E|）</strong></p></blockquote><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><blockquote><p>若邻接矩阵为三角矩阵，则存在拓扑排序；反之不一定成立。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/am9Yf1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;有向无环图：&lt;/strong&gt;不存在环的有向图, 简称&lt;strong&gt;DAG图&lt;/
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="拓扑排序" scheme="https://wuhongbin.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>图的应用之最短路径 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/08/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/08/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-08T08:15:43.000Z</published>
    <updated>2020-07-30T10:39:30.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>在网图和非网图中,最短路径的含义是不同的。          ·</p><p><strong>非网图：</strong> 两个顶点之间经过的边数最少的路径为 <strong>最短路径</strong>。</p><p>​    <strong>网图：</strong> 两个顶点之间带权路径长度最短的路径为 <strong>最短路径</strong>。   </p><p>在带权图当中,把从一个顶点v到另个顶点u所经历的边的权值之和称为,路径的 <strong>带权路径长度</strong>。</p><p>我们把路径起始的第一个顶点称为源点, 最后一个顶点称为终点。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aZDH9e.png" alt=""></p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="迪杰斯特拉（Dijkatra）算法"><a href="#迪杰斯特拉（Dijkatra）算法" class="headerlink" title="迪杰斯特拉（Dijkatra）算法"></a>迪杰斯特拉（Dijkatra）算法</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><blockquote><p>Dijkstra <strong>带权图单源最短路径</strong></p></blockquote><h4 id="辅助数组"><a href="#辅助数组" class="headerlink" title="辅助数组"></a>辅助数组</h4><blockquote><p> <strong>s[]:</strong> 标记已经计算完成的顶点。          </p><p>数组中的值全部初始化为0。源点下标的值初始化为1。</p></blockquote><blockquote><p><strong>dist[]:</strong> 记录从源点vo到其他各顶点当前的最短路径长度。</p><p>数组中的值初始化为源点到格个顶点边的权值，即 dist [i] = arcs [0] [i]</p></blockquote><blockquote><p> <strong>path[]:</strong> 记录从最短路径中顶点的前驱顶点,即path[i] 为v到vi最短路径上ⅵ 的前驱顶点。</p><p>数组中的值初始化：</p><p>若源点v0到该顶点vi有一条有向边(无向边), 则令path[i] = 0  否则 path [i] = -1;</p></blockquote><h4 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h4><ol><li>初始化数组，并集合S初始为 {0}；</li><li>从顶点集合V-S中选出Vj，满足dist[j] = Min(dist [i] l Vi ∈ V-S}，Vj就是当前求得的最短路径的终点，并另S U { j }；</li><li>修改此时从V0出发到集合V-S上任一顶点Vk最短路径的长度：若dist[j]+arcs [j] [k] 则令 dist[k]=dist [j] + arcs [j] [k] ;  path[k]=j;</li><li>重复2、3步，操作n-1次，直到S中包含全部顶点；</li></ol><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aZ2sbj.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aZ2rrQ.png" alt=""></p><h3 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化部分</span></span><br><span class="line">    <span class="keyword">int</span> s[G. vexnum];</span><br><span class="line">    <span class="keyword">int</span> path[G.vexnum];</span><br><span class="line">    <span class="keyword">int</span> dist[G.vexnum];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dist[i] = G.edge[v][i];<span class="comment">//将dist[]数组初始化为源点到格个顶点边的权值</span></span><br><span class="line">        s[i] = <span class="number">0</span>;<span class="comment">//将s[]数组全部初始化为0</span></span><br><span class="line">        <span class="keyword">if</span>(G.edge[v][i] &lt; MAX)<span class="comment">//MAX表示∞，如果权值是∞说明不存在边，无前驱节点记为-1 </span></span><br><span class="line">            path[i] = v;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            path[i]=<span class="number">-1</span>;                         </span><br><span class="line">    &#125;</span><br><span class="line">    s[v] = <span class="number">0</span>;    <span class="comment">//顶点v没有记录过, 赋值为0。 例如: s[u] = 1, 表示顶点u已经记录过</span></span><br><span class="line">    path[v] = <span class="number">-1</span>;  <span class="comment">//v是源点，无前驱节点，记作-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//真正实现部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = MAX;<span class="comment">//临时变脸，记录最小权值  </span></span><br><span class="line">        <span class="keyword">int</span> u;<span class="comment">//临时变脸，记录最小权值边另一头的顶点下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; <span class="built_in">min</span>)<span class="comment">//没被记录过过 &amp;&amp; 权值小</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">min</span> = dist[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        s[u] = <span class="number">1</span>;<span class="comment">//表示顶点u已经记录过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//没被记录过过 &amp;&amp; (v-&gt;u + u-&gt;j) &lt; u-&gt;j</span></span><br><span class="line">            <span class="keyword">if</span>(s[j] == <span class="number">0</span> &amp;&amp; dist[u] + G.Edge[u][j]] &lt; dist[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[u] + G.Edge[u][j]];</span><br><span class="line">                path[j] = u;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度为 O(|V2|)</p></blockquote><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><blockquote><p><strong>不适用于含有负权边的图</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aZzkHs.png" alt=""></p><h2 id="弗洛伊德（Floyd）算法"><a href="#弗洛伊德（Floyd）算法" class="headerlink" title="弗洛伊德（Floyd）算法"></a>弗洛伊德（Floyd）算法</h2><h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><blockquote><p>Floyd <strong>各顶点之间的最短路径</strong></p></blockquote><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p>递推产生一个n阶方阵序列A(-1), A(0, A(k, .…, A(n-1)<br>A(k) [i] [j] 顶点vi到Vj的最短路径长度，且该路径经过的顶点编号不大于k</p><h4 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h4><p>初始化：A(-1) [i] [j] = arcs [i] [j]</p><p>地推方法：A(k) [i] [j] = MIn{A(k-1) [i] [j], A(k-1) [i] [k] + A(k-1) [k] [j]}, k = 0, 1, … , n-1</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeuH0I.png" alt=""></p><h3 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeu7nA.png" alt=""></p><h3 id="参考代码实现-1"><a href="#参考代码实现-1" class="headerlink" title="参考代码实现"></a>参考代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span> <span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化部分</span></span><br><span class="line">    <span class="keyword">int</span> A[G.vexnum][G.vexnum];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)    </span><br><span class="line">            A[i][j] = G.Edge[i][j];  </span><br><span class="line">    <span class="comment">//真正实现部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; j &lt; G.vexnum; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum: j++)</span><br><span class="line"><span class="keyword">if</span>(a[i][j] &gt; a[i][k] + A[k][j])</span><br><span class="line">                   a[i][j] = a[i][k] + A[k][j];            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路径&quot;&gt;&lt;a href=&quot;#最短路径&quot; class=&quot;headerlink&quot; title=&quot;最短路径&quot;&gt;&lt;/a&gt;最短路径&lt;/h1&gt;&lt;p&gt;在网图和非网图中,最短路径的含义是不同的。          ·&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非网图：&lt;/strong&gt; 
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="最短路径" scheme="https://wuhongbin.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
      <category term="迪杰斯特拉(Dijkatra)算法" scheme="https://wuhongbin.github.io/tags/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89-Dijkatra-%E7%AE%97%E6%B3%95/"/>
    
      <category term="弗洛伊德(Floyd)算法" scheme="https://wuhongbin.github.io/tags/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7-Floyd-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>图的应用之最小生成树 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/07/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/07/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-07T08:15:43.000Z</published>
    <updated>2020-07-30T10:34:14.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h1><p><strong>定义：</strong> 连通图包含全部顶点的一个极小连通子图</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/apOGU1.png" alt=""></p><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p><strong>定义：</strong> 对于 <strong>带权无向连通图</strong> G = ( V, E ), G的所有生成树当中边的 <strong>权值之和最小</strong> 的生成树为G的 <strong>最小生成树(MST)</strong> 。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/apXPG6.png" alt=""></p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ol><li><p>最小生成树不一定唯一,即最小生成树的树形不一定唯一。当带权无向连通图G的各边权值不等时或G只有结点数减1条边时,MST唯一    </p></li><li><p>最小生成树的权值是唯一的, 且是最小    </p></li><li><p>最小生成树的边数为顶点数减1</p></li></ol><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="Prim-（普里姆）算法"><a href="#Prim-（普里姆）算法" class="headerlink" title="Prim （普里姆）算法"></a>Prim （普里姆）算法</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li><strong>初始化：</strong>向空的结果树 T =（Vt，Et) 中添加图 G =（V, E) 的任一顶点u0，使 Vt = {u0}，Et为空集；</li><li><strong>循环（直到Vt = V)：</strong>从图G中选择满足 { (u, v) | u∈Vt ，v∈ V-Vt }且具有最小权值的边（u，v），并置Vt = Vt U {v} , Et =Et U (u, v) }。</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9ClrV.png" alt=""></p><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9AdH0.png" alt=""></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote><p><strong>辅助数组理解：</strong></p><p>min_weight [n] ：存放相关顶点间边的权值 </p><p><strong>表示最小生成树中已存放的顶点到未存放顶点的最小权值</strong></p><p>例：假设有 v0，v1，v2，v3，v4 这5个顶点</p><p>min_weight [5] = {0, 2, 0, 0, 0} <strong>表示最小生成树中已存放的顶点到顶点v1的最小权值是2</strong></p><p>adjvex [n] ：存放相关顶点的下标    </p><p>例：假设有 v0，v1，v2，v3，v4 这5个顶点</p><p>adjvex [5] = {0, 0, 1, 0, 1} <strong>表示顶点v2和顶点v4 这两个点和顶点v1间都有边</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MST_Prim</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> min_weight[G.vexnum];<span class="comment">//存放相关顶点间边的权值</span></span><br><span class="line">    <span class="keyword">int</span> adjvex[G.vexnum];<span class="comment">//存放相关顶点的下标 </span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//初始化操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min_weight[i] = G.Edge[<span class="number">0</span>][i];<span class="comment">//将邻接矩阵第0行所有权值加入数组</span></span><br><span class="line">        adjvex[i] = <span class="number">0</span>;<span class="comment">//全部初始化为v0下标</span></span><br><span class="line">    &#125;</span><br><span class="line">                   </span><br><span class="line">    <span class="comment">//正式构造最小生成树的过程               </span></span><br><span class="line">    <span class="keyword">int</span> min_arc;<span class="comment">//临时变量，表示当前最小权值</span></span><br><span class="line">    <span class="keyword">int</span> min_vex;<span class="comment">//临时变量，表示当前最小权值边的顶点数组下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; G.vexnum; i++)   <span class="comment">//由于有一个顶点已在最小生成树中，所以只遍历n-1次</span></span><br><span class="line">    &#123;</span><br><span class="line">        min_arc = INT_MAX;<span class="comment">//初始化最小权值为65535等不可能数值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找出min_weight[]数组中已存的最小权值</span></span><br><span class="line">             <span class="keyword">if</span>(min_weight[j] != <span class="number">0</span> &amp;&amp; min_weight[j] &lt; min_arc)</span><br><span class="line">             &#123;</span><br><span class="line">                 min_arc = min_weight[j];</span><br><span class="line">                 min_vex = j;<span class="comment">//将发现最小权值的下标存入min_vex, 待使用</span></span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        min_weight[min_vex] = <span class="number">0</span>;<span class="comment">//将当前顶点的权值设为0，表示此顶点已完成任务</span></span><br><span class="line">        <span class="comment">//遍历全部顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123; </span><br><span class="line">             <span class="keyword">if</span>(min_weight[j] != <span class="number">0</span> &amp;&amp; G.Edge[min_vex][j] &lt; min_weight[j])</span><br><span class="line">             &#123;</span><br><span class="line">                 min_weight[j] = G.Edge[min_vex][j];</span><br><span class="line">                 adjvex[j] = min_arc;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>结论：</strong></p><p>此算法时间复杂度为 O(V2)，适用于<strong>稠密图</strong></p></blockquote><h2 id="Kruskal（克鲁斯卡尔）算法"><a href="#Kruskal（克鲁斯卡尔）算法" class="headerlink" title="Kruskal（克鲁斯卡尔）算法"></a>Kruskal（克鲁斯卡尔）算法</h2><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li><strong>初始化：</strong>Vt = V，Et = 空集。即是每个顶点构成一棵独立的树，T是一个仅含V个顶点的森林；</li><li><strong>循环（直到T为树）：</strong>按图G的边的权值递增的顺序依次从 E-Et 中选择一条边，若这条边加入后不构成回路，则将其加入E，否则舍弃。</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9WD8s.png" alt=""></p><h3 id="并查集（必看）"><a href="#并查集（必看）" class="headerlink" title="并查集（必看）"></a>并查集（必看）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9jQIA.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9jMad.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9j1PI.png" alt=""></p><h3 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9OeW6.png" alt=""></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;<span class="comment">//两个端点下标</span></span><br><span class="line">    <span class="keyword">int</span> weight;     <span class="comment">//权值</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MST_Kruskal</span><span class="params">(Graph G, Edge* edges, <span class="keyword">int</span>* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heap_sort(edges);<span class="comment">//堆排序</span></span><br><span class="line">    Initial(parent);<span class="comment">//全部初始化为 -1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.arcnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a_root = Find(parent, edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b_root = Find(parent, edges[il.b);</span><br><span class="line">        <span class="keyword">if</span>(a_root != b_root)</span><br><span class="line">        Union(parent, a_root, b_root);<span class="comment">//合并</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>结论：</strong></p><p>此算法时间复杂度为 O(|E|log|E|)，适用于<strong>稀疏图</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;生成树&quot;&gt;&lt;a href=&quot;#生成树&quot; class=&quot;headerlink&quot; title=&quot;生成树&quot;&gt;&lt;/a&gt;生成树&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; 连通图包含全部顶点的一个极小连通子图&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;/img/loa
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="最小生成树" scheme="https://wuhongbin.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="并查集" scheme="https://wuhongbin.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="Prim(普里姆)算法" scheme="https://wuhongbin.github.io/tags/Prim-%E6%99%AE%E9%87%8C%E5%A7%86-%E7%AE%97%E6%B3%95/"/>
    
      <category term="Kruskal(克鲁斯卡尔)算法" scheme="https://wuhongbin.github.io/tags/Kruskal-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>图的遍历之深度优先搜索(DFS) 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/06/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/06/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-06T08:15:43.000Z</published>
    <updated>2020-07-30T05:47:09.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深度度优先搜索"><a href="#深度度优先搜索" class="headerlink" title="深度度优先搜索"></a>深度度优先搜索</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>深度优先搜索(DepthFirstSearch)</strong>,也有称为深度优先遍历,简称为 <strong>DFS</strong>。  </p><blockquote><p>​        还是拿找钥匙例子来说,  无论从哪一间房间开始都可以,将间内的墙角  、床头柜、床上、床下、衣柜、电视柜等挨个寻  找,做到不放过任何一个死角,当所有的抽屉、  储藏柜中全部都找遍,接着再寻找下一个房间。</p></blockquote><h3 id="具体实现思路"><a href="#具体实现思路" class="headerlink" title="具体实现思路"></a>具体实现思路</h3><ol><li><p>首先访问起始顶点v;  </p></li><li><p>接着由v出发访问v的任意一个 <strong>邻接且未被访问</strong> 的邻接顶点Wi  </p></li><li><p>然后再访问与Wi <strong>邻接且未被访问</strong> 的任意顶点 yi;  </p></li><li><p>若w没有邻接且未被访问的顶点时, 退回到它的上一层顶点v;  </p></li><li><p>重复上述过程,直到所有顶点被访问为止。</p></li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/Uz7eqP.png" alt=""></p><blockquote><p><strong>由此看出，深度优先搜索与树的先序遍历类似</strong></p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/Uz7sMR.png" alt=""></p><blockquote><p>小提示：遵循右手原则遍历，蓝色线为走的线</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/Uz7ys1.png" alt=""></p><h3 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/UzbBuR.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_TREE_SIZE]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        visited[i] = FALSE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            DFS(G, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(Graph G, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    <span class="keyword">for</span>(w = FirstNeighbor(G, v); w &gt;= <span class="number">0</span>; w = NextNeighbor(G, v, w))</span><br><span class="line">    <span class="keyword">if</span>(!visited[i])        i</span><br><span class="line">            DFS(G, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>此篇博客仅为本人根据个人理解复习总结所写，如有错误之处，请在下方评论或者联系我，我会第一时间改正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深度度优先搜索&quot;&gt;&lt;a href=&quot;#深度度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;深度度优先搜索&quot;&gt;&lt;/a&gt;深度度优先搜索&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="深度度优先搜索" scheme="https://wuhongbin.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>图的遍历之广度优先搜索(BFS) 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/05/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/05/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-05T06:15:43.000Z</published>
    <updated>2020-07-30T10:32:48.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>从图中某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。</p><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>广度优先搜索（BreadthFirstSearch)</strong>，又称为广度优先遍历，简称 <strong>BFS</strong>。</p><blockquote><p>​        如果以之前我们找钥匙的例子来讲，运用深度优先遍历意味着要先彻底查找完一个房间再开始另一个房间但我们知道，钥匙放在沙发地下等特角奇兄的可能性极低，因此我们运用新的方亲：先看看钥匙是否放在各个房间的显服位置，如果没有，再看看各个房间的抽屉有没有。这样逐步扩大查找的范围的方式我们称为 <strong>广度优先搜索</strong> 。</p></blockquote><h3 id="具体实现思路"><a href="#具体实现思路" class="headerlink" title="具体实现思路"></a>具体实现思路</h3><ol><li>首先访问起始顶点v；</li><li>接着由出发依次访问v的各个 <strong>未被访问过</strong> 的邻接顶点W1, W2….Wi；</li><li>然后依次访问W1, W2…,Wi 的所有 <strong>未被访问过</strong> 的邻接顶点；</li><li>在从这些访问过的顶点出发，访问它们所有 <strong>未被访问过的</strong> 邻接顶点.</li><li>….以此类推；</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvUKr8.png" alt=""></p><blockquote><p><strong>由此看出，广度优先搜索与树的层次遍历类似</strong></p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/UzeahF.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/UzeUtU.png" alt=""></p><h3 id="参考代码实现-邻接矩阵"><a href="#参考代码实现-邻接矩阵" class="headerlink" title="参考代码实现 (邻接矩阵)"></a>参考代码实现 (邻接矩阵)</h3><blockquote><p><strong>温馨提示：请结合本博客另一博文《图的存储结构之邻接矩阵 详细总结》参考学习</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵的广度优先搜索</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_TRUE_SIZE];<span class="comment">//辅助标记数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Mgraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; G.vexnum; i++)<span class="comment">//将辅助标记数组全部初始化为FALSE, G.vexnum表示顶点数</span></span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    initQueue( &amp;Q);<span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c  "</span>, G.vex[i]);<span class="comment">//访问顶点</span></span><br><span class="line">            visited[i] = TRUE;</span><br><span class="line">            EnQueue(&amp;Q, i);</span><br><span class="line">            <span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                DeQueue(&amp;Q, i);</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(G.art[i][j]) == <span class="number">1</span> &amp;&amp; !visited[j])<span class="comment">//等于1 且 未被访问</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%c  "</span>, G.vex[i]);<span class="comment">//访问顶点</span></span><br><span class="line">                        visited[j] = TRUE;</span><br><span class="line">            EnQueue(&amp;Q, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考代码实现-邻接表"><a href="#参考代码实现-邻接表" class="headerlink" title="参考代码实现 (邻接表)"></a>参考代码实现 (邻接表)</h3><blockquote><p><strong>温馨提示：请结合本博客另一博文《图的存储结构之邻接表 详细总结》参考学习</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表的广度优先搜索</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_TRUE_SIZE];<span class="comment">//辅助标记数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Mgraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; G.vexnum; i++)<span class="comment">//将辅助标记数组全部初始化为FALSE, G.vexnum表示顶点数</span></span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    initQueue( &amp;Q);<span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c  "</span>, G.vetices[i].data);<span class="comment">//访问顶点</span></span><br><span class="line">            visited[i] = TRUE;</span><br><span class="line">            EnQueue(&amp;Q, i);</span><br><span class="line">            <span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                DeQueue(&amp;Q, i);</span><br><span class="line">                ArcNode P = G.AdjList[i].first;</span><br><span class="line">                <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; !visited[i])<span class="comment">// 单链表指针为非NULL 且 未被访问</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c  "</span>, G.vetices[p.adjvex].data);<span class="comment">//访问顶点</span></span><br><span class="line">                    visited[j] = TRUE;</span><br><span class="line">                    EnQueue(&amp;Q, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>此篇博客仅为本人根据个人理解复习总结所写，如有错误之处，请在下方评论或者联系我，我会第一时间改正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图的遍历&quot;&gt;&lt;a href=&quot;#图的遍历&quot; class=&quot;headerlink&quot; title=&quot;图的遍历&quot;&gt;&lt;/a&gt;图的遍历&lt;/h2&gt;&lt;p&gt;从图中某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。&lt;/p&gt;
&lt;h2 id=&quot;广度优先搜索
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="广度优先搜索" scheme="https://wuhongbin.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>图的基本操作 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/04/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/04/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-04T03:15:43.000Z</published>
    <updated>2020-07-30T10:30:29.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作一-判断边存在"><a href="#操作一-判断边存在" class="headerlink" title="操作一 判断边存在"></a>操作一 判断边存在</h2><blockquote><p><strong>Adjacent(G, x, y) 判断图G是否存在边 &lt;x, y&gt; 或 (x, y)</strong></p></blockquote><h3 id="实例（无向图）"><a href="#实例（无向图）" class="headerlink" title="实例（无向图）"></a>实例（无向图）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UveNTO.png" alt=""></p><h3 id="实例（有向图）"><a href="#实例（有向图）" class="headerlink" title="实例（有向图）"></a>实例（有向图）</h3><p><strong><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvmT8H.png" alt=""></strong></p><h2 id="操作二-找邻边"><a href="#操作二-找邻边" class="headerlink" title="操作二 找邻边"></a>操作二 找邻边</h2><blockquote><p><strong>Neighbors(G, x) 列出图G中与结点x邻接的边</strong></p></blockquote><h3 id="实例（无向图）-1"><a href="#实例（无向图）-1" class="headerlink" title="实例（无向图）"></a>实例（无向图）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uvnhyn.png" alt=""></p><h3 id="实例（有向图）-1"><a href="#实例（有向图）-1" class="headerlink" title="实例（有向图）"></a>实例（有向图）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uvn4Lq.png" alt=""></p><h2 id="操作三-插入顶点"><a href="#操作三-插入顶点" class="headerlink" title="操作三 插入顶点"></a>操作三 插入顶点</h2><blockquote><p><strong>InsertVertex(G,x) 在图G中插入顶点x</strong></p></blockquote><h3 id="插入顶点F前"><a href="#插入顶点F前" class="headerlink" title="插入顶点F前"></a>插入顶点F前</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvKlE6.png" alt=""></p><h3 id="插入顶点F后"><a href="#插入顶点F后" class="headerlink" title="插入顶点F后"></a>插入顶点F后</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvK1UK.png" alt=""></p><h2 id="操作四-删除顶点"><a href="#操作四-删除顶点" class="headerlink" title="操作四 删除顶点"></a>操作四 删除顶点</h2><blockquote><p><strong>DeleteVertex(G, x) 从图G中删除顶点x</strong></p></blockquote><h3 id="删除顶点A前"><a href="#删除顶点A前" class="headerlink" title="删除顶点A前"></a>删除顶点A前</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvQE6J.png" alt=""></p><h3 id="删除顶点A后"><a href="#删除顶点A后" class="headerlink" title="删除顶点A后"></a>删除顶点A后</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvQAl4.png" alt=""></p><h2 id="操作五-添加边"><a href="#操作五-添加边" class="headerlink" title="操作五 添加边"></a>操作五 添加边</h2><blockquote><p><strong>AddEdge(G, x, y) 若无向边(x,y) 或者 有向边&lt;x, y&gt;不存在,则向图中添加该边</strong></p></blockquote><h3 id="添加边AD前"><a href="#添加边AD前" class="headerlink" title="添加边AD前"></a>添加边AD前</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvlGCT.png" alt=""></p><h3 id="添加边AD后"><a href="#添加边AD后" class="headerlink" title="添加边AD后"></a>添加边AD后</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uvl35V.png" alt=""></p><h2 id="操作六-删除边"><a href="#操作六-删除边" class="headerlink" title="操作六 删除边"></a>操作六 删除边</h2><blockquote><p><strong>RemoveEdge(G, x, y)若 无向边(x, y) 或者 有向边&lt;x, y&gt;存在,则在图G中删除该边</strong></p></blockquote><h3 id="删除边BC前"><a href="#删除边BC前" class="headerlink" title="删除边BC前"></a>删除边BC前</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uv3gHA.png" alt=""></p><h3 id="删除边BC后"><a href="#删除边BC后" class="headerlink" title="删除边BC后"></a>删除边BC后</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uv3cBd.png" alt=""></p><h2 id="操作七-找顶点的邻接点"><a href="#操作七-找顶点的邻接点" class="headerlink" title="操作七 找顶点的邻接点"></a>操作七 找顶点的邻接点</h2><blockquote><p><strong>FirstNeighbor(G, x) 求图G中顶点X的第一个邻接点，若有则返回顶点号。若没有邻接点或图不存在x，则返回 -1。<br>NextNeighbor(G, x) 假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是的最后一个邻接点，则返回 -1。</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uv862T.png" alt=""></p><h2 id="操作八-网获取或设置权值"><a href="#操作八-网获取或设置权值" class="headerlink" title="操作八 网获取或设置权值"></a>操作八 网获取或设置权值</h2><blockquote><p><strong>Get edge value(G, x, y) 获取图G中边(x, y) 或 &lt;x, y&gt; 对应的权值v。</strong>  </p><p><strong>Set edge value(G, x, y) 设置图G中边(x, y) 或 &lt;x, y&gt; 对应的权值为v。</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvG1L4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;操作一-判断边存在&quot;&gt;&lt;a href=&quot;#操作一-判断边存在&quot; class=&quot;headerlink&quot; title=&quot;操作一 判断边存在&quot;&gt;&lt;/a&gt;操作一 判断边存在&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Adjacent(G, x, y) 判断图
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>图的存储结构之邻接多重表 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/03/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/03/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-03T09:15:50.000Z</published>
    <updated>2020-07-30T10:31:56.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        如果我们在无向图的应用中,关注的重点是顶点的话,那么邻接表是不错的选择,但如果我们更关注的是边的操作,比如对已经访问过的边做标记, 或者删除某一条边等操作,邻接表就显得不那么方便了。</p><h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><p><strong>邻接多重表：</strong> 无向图的一种存储结构</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/UOkyiq.png" alt=""></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/UOk6J0.png" alt=""></p><h2 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边表结点</span></span><br><span class="line">    <span class="keyword">int</span> ivex,jvex; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">ilink</span>, *<span class="title">jlink</span>;</span></span><br><span class="line">    <span class="comment">//Inforype info;</span></span><br><span class="line">    <span class="comment">//bool mark;</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span><span class="comment">//顶点结点</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode *firstedge;</span><br><span class="line">&#125;VNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//邻接多重表</span></span><br><span class="line">    VNode adjmulist[MaxVertexNum];</span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;AMLGraph；</span><br></pre></td></tr></table></figure><h2 id="十字链表-VS-邻接多重表"><a href="#十字链表-VS-邻接多重表" class="headerlink" title="十字链表 VS 邻接多重表"></a>十字链表 VS 邻接多重表</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/UOVeGq.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​        如果我们在无向图的应用中,关注的重点是顶点的话,那么邻接表是不错的选择,但如果我们更关注的是边的操作,比如对已经访问过的边
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="图" scheme="https://wuhongbin.github.io/tags/%E5%9B%BE/"/>
    
      <category term="邻接多重表" scheme="https://wuhongbin.github.io/tags/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>图的存储结构之十字链表 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/03/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/03/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-03T01:15:50.000Z</published>
    <updated>2020-07-30T10:32:20.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​       邻接表 固然优秀，但也有不足。例如，对有向图的处理上，有时候需要再建立一个逆邻接表，这就不是很方便了。那我们思考了：有没有可能把邻接表和逆邻接表 结合起呢？答亲是肯定的，这就是我们现在要谈的十字链表 (Orthogonal List)。</p><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p><strong>十字链表</strong> 是有向图的一种链式存储结构</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/ULznFU.png" alt=""></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/UO99JO.png" alt=""></p><h2 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边表结点</span></span><br><span class="line">    <span class="keyword">int</span> tailvex,headvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">hlink</span>, <span class="title">tlink</span>;</span></span><br><span class="line">    <span class="comment">//Inforype info;</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vNodet</span>&#123;</span><span class="comment">//顶点表结点</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode *firstin, *firstout;</span><br><span class="line">]VNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//十字链表</span></span><br><span class="line">    VNode xlist[MaxVertexNum];</span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;GLGraph;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        十字链表的好处就是因为 <strong>把邻接表和逆邻接表整合在了一起</strong> , 这样既容易找到以Vi为尾的弧,也  容易找到以Vj为头的弧,因而容易求得顶点的出度和入度。</p><p>​        十字链表除了结构复杂一点外,其实创建图算法的肘间复杂度是和邻接表相同的,因此,在有向图的应用中,十字链表也是非常好的数据结构模型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​       邻接表 固然优秀，但也有不足。例如，对有向图的处理上，有时候需要再建立一个逆邻接表，这就不是很方便了。那我们思考了：有没有可
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="图" scheme="https://wuhongbin.github.io/tags/%E5%9B%BE/"/>
    
      <category term="十字链表" scheme="https://wuhongbin.github.io/tags/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>图的存储结构之邻接表 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%82%BB%E6%8E%A5%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%82%BB%E6%8E%A5%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-02T03:15:43.000Z</published>
    <updated>2020-07-30T10:31:32.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    由于邻接矩阵适用于存储稠密图，如果用邻接矩阵存储 <strong>稀疏图</strong> 会造成极大的 <strong>空间浪费</strong> ，因此我们来学习 <strong>邻接表</strong> 来存储稀疏图。</p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p><strong>总体思路：</strong>为每个顶点建立一个单链表存放与它相邻的边</p><table><thead><tr><th>顶点表</th><th>采用顺序存储,每个数组元素存放顶点的数据和边表的头指针</th></tr></thead><tbody><tr><td><strong>边表(出边表)</strong></td><td><strong>采用链式存储,单链表中存放与一个顶点相邻的所有边,一个链表结点表示一条从该顶点到链表结点顶点的边</strong></td></tr></tbody></table><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/ULM2oF.png" alt=""></p><h2 id="实例（无向图）"><a href="#实例（无向图）" class="headerlink" title="实例（无向图）"></a>实例（无向图）</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/ULQOBV.png" alt=""></p><h2 id="实例（有向图）"><a href="#实例（有向图）" class="headerlink" title="实例（有向图）"></a>实例（有向图）</h2><blockquote><p><strong>提示：</strong> 下图把顶点当作弧尾建立的 <strong>邻接表</strong> ，如果把顶点当作弧头建立，则称为 <strong>逆邻接表</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/ULQLn0.png" alt=""></p><h2 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边表结点</span></span><br><span class="line">        <span class="keyword">int</span> adjvex;<span class="comment">//顶点下标</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>；  //指向下一个边表结点的指针</span></span><br><span class="line"><span class="class">        //<span class="title">Inforype</span> <span class="title">info</span>;</span><span class="comment">//权值</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span><span class="comment">//顶点表结点</span></span><br><span class="line">        VertexType data;<span class="comment">//顶点数据</span></span><br><span class="line">        ArcNode *first;<span class="comment">//指向它的单链表的头指针</span></span><br><span class="line">&#125;VNode, AdjList[MaxVertexNum];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        AdjList vetices;<span class="comment">//定义邻接表</span></span><br><span class="line">        <span class="keyword">int</span> vexnum,arcnum;<span class="comment">//顶点数，边数</span></span><br><span class="line">&#125;ALGraph</span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/ULJ5NV.png" alt=""></p><h2 id="邻接矩阵-VS-邻接表"><a href="#邻接矩阵-VS-邻接表" class="headerlink" title="邻接矩阵 VS 邻接表"></a>邻接矩阵 VS 邻接表</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/ULYKgg.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    由于邻接矩阵适用于存储稠密图，如果用邻接矩阵存储 &lt;strong&gt;稀疏图&lt;/strong&gt; 会造成极大的 &lt;strong&gt;空间浪费
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="图" scheme="https://wuhongbin.github.io/tags/%E5%9B%BE/"/>
    
      <category term="邻接表" scheme="https://wuhongbin.github.io/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>图的存储结构之邻接矩阵 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-02T02:15:43.000Z</published>
    <updated>2020-07-30T10:31:03.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="邻接矩阵的定义"><a href="#邻接矩阵的定义" class="headerlink" title="邻接矩阵的定义"></a>邻接矩阵的定义</h2><p><strong>图的邻接矩阵（Adjacency Matrix）</strong>存储方式是用两个数组来表示图。一个 <strong>一维数组 *<em>存储图中顶点信息，一个 *</em>二维数组</strong>(称为邻接矩阵) 存储图中的边或弧的信息。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/Ub3rkD.png" alt=""></p><h2 id="图的领接矩阵实现思路"><a href="#图的领接矩阵实现思路" class="headerlink" title="图的领接矩阵实现思路"></a>图的领接矩阵实现思路</h2><p>结点数为n的图G=(V)的邻接矩阵A是nxn的。 </p><p>将G的顶点编号为V1,V2…Vn(数组下标) </p><p>若&lt;Vi,Vj&gt; ∈E，则 A [i] [j] = 1，否则 A [i] [j] = 0</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/Ub8n4e.png" alt=""></p><h3 id="实例（有向图）"><a href="#实例（有向图）" class="headerlink" title="实例（有向图）"></a>实例（有向图）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UbNmpF.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UbNnl4.png" alt=""></p><h3 id="实例（无向图）"><a href="#实例（无向图）" class="headerlink" title="实例（无向图）"></a>实例（无向图）</h3><p><strong><font color=red>注意：</font></strong> 下图中修改部分的值均为 <strong>1</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UbdSSO.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UbdplD.png" alt=""></p><h2 id="网的邻接矩阵实现思路"><a href="#网的邻接矩阵实现思路" class="headerlink" title="网的邻接矩阵实现思路"></a>网的邻接矩阵实现思路</h2><blockquote><p><strong>小提示：</strong>网也就是带权值的图</p></blockquote><p>结点数为n的图G=(V)的邻接矩阵A是nxn的。 </p><p>将G的顶点编号为V1,V2…Vn(数组下标) </p><p>若&lt;Vi,Vj&gt; ∈E，则 A [i] [j] = Wi,j，否则 A [i] [j] = ∞</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/Ub5cXd.png" alt=""></p><h3 id="实例（无向图）-1"><a href="#实例（无向图）-1" class="headerlink" title="实例（无向图）"></a>实例（无向图）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/Uqy1XV.png" alt=""></p><h3 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType Vex[MaxVertexNum];<span class="comment">//点集</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];<span class="comment">//边集</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;<span class="comment">//结点数量，边的数量</span></span><br><span class="line">&#125;MGraph</span><br></pre></td></tr></table></figure><h2 id="邻接矩阵的性质"><a href="#邻接矩阵的性质" class="headerlink" title="邻接矩阵的性质"></a>邻接矩阵的性质</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/Uqy1XV.png" alt=""></p><ol><li><p>邻接矩阵法的空间复杂为O(n2), 适用于 <strong>稠密图</strong></p></li><li><p>无向图的邻接矩阵为 <strong>对称矩阵</strong> </p></li><li><p>无向图中第 i 行 (第 i 列) 非0元素 (非正无穷) 的个数为第 i 个顶点的度 </p></li><li><p>有向图中第 i 行 (第 i 列) 非0元素 (非正无穷) 的个数为第 i 个顶点的出度(入度）</p></li></ol><h2 id="问题探索"><a href="#问题探索" class="headerlink" title="问题探索"></a>问题探索</h2><blockquote><p><strong>问题：</strong>设图G的邻接矩阵为A,矩阵运算 <strong>A的n次</strong> 的含义？？？</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/Uq5RZn.png" alt=""></p><p><strong><font color=red>小提示：</font></strong> 以下 An 代表 A的n次，例如 A2 代表 A的2次</p><p><strong><font color=red>分析：</font></strong></p><p>A2 [2] [5]=1 * 1 + 0 * 0 + 1 * 1 + 0 * 0 + 0 * 0 = 2 </p><p>A2 [2] [5] = 2 表示从顶点v2到顶点v5长度为2的路径有 2 条</p><p>A3 [2] [5] = 0 * 1 + 0 * 0 + 1 * 1 + 1 * 0 + 2 * 0 = 1 </p><p>A2 [2] [3] = 1 表示从顶点v2到顶点v3长度为2的路径有 1 条 </p><p>A3 [2] [5] = 1 表示从顶点v2到顶点v5长度为3的路径有 1 条 </p><p><strong><font color=red>结论：</font></strong></p><p>An [i] [j] = x 表示从顶点Vi到顶点Vj长度为n的路径有 x 条</p><p>即：An [i] [j] 表示从顶点Vi到顶点Vj长度为n的路径条数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;邻接矩阵的定义&quot;&gt;&lt;a href=&quot;#邻接矩阵的定义&quot; class=&quot;headerlink&quot; title=&quot;邻接矩阵的定义&quot;&gt;&lt;/a&gt;邻接矩阵的定义&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;图的邻接矩阵（Adjacency Matrix）&lt;/strong&gt;存储方式是用两个数
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="图" scheme="https://wuhongbin.github.io/tags/%E5%9B%BE/"/>
    
      <category term="邻接矩阵" scheme="https://wuhongbin.github.io/tags/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>图的基本概念 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/01/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/01/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-01T02:10:43.000Z</published>
    <updated>2020-07-30T10:30:01.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h1><p>图（Graph）是由顶点 (Vertex) 的 <strong>有穷非空</strong> 集合 和 顶点之间 <strong>边</strong> 的集合组成，通常表示为：G(V, E)  , 其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p><p>|V|表示图G中顶点的个数，也称为图G的阶；|E| 表示图G中边的条数</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/U7UjGF.png" alt=""></p><blockquote><p>V = {A，B，C，D，E}         |V| = 5</p><p>E = {(A, B), (A, C), (A, E), (B, C), (C, D), (C, E)}      |E| = 6</p></blockquote><p><strong><font color=red>注意：</font></strong>线性表，树都可以为空，但图 <strong>不能为空</strong> (顶点集合V要有穷非空，边集可以是空的)</p><h1 id="图的其它基本概念"><a href="#图的其它基本概念" class="headerlink" title="图的其它基本概念"></a>图的其它基本概念</h1><h2 id="无向图-amp-有向图"><a href="#无向图-amp-有向图" class="headerlink" title="无向图 &amp; 有向图"></a>无向图 &amp; 有向图</h2><p><strong>无向边：</strong>若顶点Vi到Vj之间的边没有方向，则称 这条边为<strong>无向边(Edge)</strong>，用无序偶(Vi，Vj）来表 示。</p><p><strong>有向边：</strong>若从顶点Vi到Vj的边有方向，则称这条边为 <strong>有向边</strong>，也称为 <strong>弧（Arc）</strong>，用有序偶&lt;Vi，Vj&gt;来表示 ，Vi称为<strong>弧尾</strong>，Vj称为<strong>弧头</strong>。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/U7s4uF.png" alt=""></p><h2 id="简单图-amp-多重图"><a href="#简单图-amp-多重图" class="headerlink" title="简单图 &amp; 多重图"></a>简单图 &amp; 多重图</h2><p><strong>简单图：</strong>在图结构中，若不存在顶点到其自身的 边，且同一条边不重复出现，则称这样的图为简单图。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/U7sfjU.png" alt=""></p><h2 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h2><p><strong>无向完全图：</strong>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶 点的无向完全图有n*(n-1)/2条边。</p><p><strong>有向完全图：</strong>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n*(n-1) 条边。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/U7R4u6.png" alt=""></p><h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h2><p>设有两个图G =（V，E) 和 G’ =（V’，E‘），若V’是V的子集，且E‘是E的子集， 则称G’为G的 <strong>子图</strong>，且若V（G）= V（G’）则称 G’ 为 G的 <strong>生成子图</strong></p><blockquote><p><strong>子图</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UH99dU.png" alt=""></p><blockquote><p><strong>生成子图</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UH9CoF.png" alt=""></p><blockquote><p><strong>子图</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UH9ii4.png" alt=""></p><blockquote><p><strong>子图</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHpzLV.png" alt=""></p><blockquote><p><strong>不是子图</strong>，因为它就不是图</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UH9pZT.png" alt=""></p><h2 id="连通图-amp-强连通图"><a href="#连通图-amp-强连通图" class="headerlink" title="连通图 &amp; 强连通图"></a>连通图 &amp; 强连通图</h2><p><strong>连通图：</strong>在无向图G中，如果从顶点V1到顶点V2有路径， 则称V1和V2是连通的，如果对于图中任意两个顶 点Vi和Vj都是连通的，则称G是连通图 (ConnectedGraph)</p><p><strong>连通分量：</strong>无向图中的极大连通子图称为连通分量。 </p><blockquote><p><strong>注意以下概念：</strong> </p><p>首先要是子图，并且子图是要连通的； </p><p>连通子图含有极大顶点数； </p><p>是有极大顶点数的速通子图包含依附于这些顶点的所 有边。</p></blockquote><p><strong>强连通图：</strong>在有向图G中,如果对于每一对Vi到Vj都存在路径,则 称G是强连通图。 </p><p><strong>强连通分量：</strong>有向图中的极大强连通子图称为有向图的强连通分量。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHElH1.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHE3Ax.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHVTeA.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHeENt.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHeV4P.png" alt=""></p><blockquote><p><strong><font color=red>结论：</font></strong></p><p>如果原图是一个连通图 (强连通图)，那么它的连通分量 (强连通分量) 与 原图  <strong>一模一样</strong></p><p>如果原图不是一个连通图 (强连通图)，那么它的连通分量 (强连通分量) 会有 <strong>许多个</strong></p></blockquote><h2 id="生成树-amp-生成森林"><a href="#生成树-amp-生成森林" class="headerlink" title="生成树 &amp; 生成森林"></a>生成树 &amp; 生成森林</h2><p><strong>生成树：</strong>连通图包含全部顶点的一个极小连通子图</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHK1MT.png" alt=""></p><p><strong>生成森林：</strong>非连通图所有连通分量的生成树组成森林</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHKqFs.png" alt=""></p><h2 id="稀疏图-amp-稠密图"><a href="#稀疏图-amp-稠密图" class="headerlink" title="稀疏图 &amp; 稠密图"></a>稀疏图 &amp; 稠密图</h2><p><strong>稀疏图和稠密图：</strong>这里的稀疏和稠密是模糊的概念，都 是相对而言的，通常认为边或弧数小于n*logn(n是顶 点的个数）的图称为稀疏图，反之称为稠密图。 </p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHQXrT.png" alt=""></p><h2 id="顶点的度"><a href="#顶点的度" class="headerlink" title="顶点的度"></a>顶点的度</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHM6XT.png" alt=""><br><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHMgnU.png" alt=""></p><h2 id="权-amp-网"><a href="#权-amp-网" class="headerlink" title="权 &amp; 网"></a>权 &amp; 网</h2><p><strong>权和网：</strong>有些图的边或弧带有与宅相关的数字，这种与图的边或 弧相关的数叫做权(Weight)，带权的图通常称为网 (Network)。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHQeCn.png" alt=""></p><h2 id="有向树"><a href="#有向树" class="headerlink" title="有向树"></a>有向树</h2><p><strong>有向树：</strong> 一个顶点的入度为0，其余顶点的入度均为1的有向图</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHlRY9.png" alt=""></p><h2 id="路径-amp-路径长度-amp-回路"><a href="#路径-amp-路径长度-amp-回路" class="headerlink" title="路径 &amp; 路径长度 &amp; 回路"></a>路径 &amp; 路径长度 &amp; 回路</h2><p><strong>路径：</strong>图中顶点v到顶点w的顶点序列，序列中顶点不重复的路径称为简单路径。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UH1Tcq.png" alt=""></p><p><strong>路径长度：</strong>路径上边的数目，若该路径最短则称其为距离。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UH3N2n.png" alt=""></p><p><strong>回路：</strong>第一个顶点和最后一个顶点相同的路径</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UH3jqf.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图的定义&quot;&gt;&lt;a href=&quot;#图的定义&quot; class=&quot;headerlink&quot; title=&quot;图的定义&quot;&gt;&lt;/a&gt;图的定义&lt;/h1&gt;&lt;p&gt;图（Graph）是由顶点 (Vertex) 的 &lt;strong&gt;有穷非空&lt;/strong&gt; 集合 和 顶点之间 &lt;stron
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="图" scheme="https://wuhongbin.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/31/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/31/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-31T09:46:43.000Z</published>
    <updated>2020-07-30T10:57:26.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h2><p>设二叉树具有n个带权值的叶节点，那么从根节点到各个叶节点的路径长度与相应节点权值的乘积的和，叫做二叉树的 <strong><font color=red>带权路径长度</font></strong>。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHXvHe.png" alt=""></p><p> <strong><font color=red>权：</font></strong> 权代表的是叶子结点的数据信息,是具体的值。也就是结点所储存的值</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHjYE4.png" alt=""></p><p>具有最小带权路径长度的二叉树称为 <strong><font color=red>哈夫曼树 (也称最优数)</font></strong> 。</p><p>相同的叶节点构造出不同的二叉树</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHjX2q.md.png" alt=""></p><h2 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h2><p>构造哈夫曼树的 <strong><font color=red>原则：</font></strong></p><p>① 权值越大的叶节点越靠近根节点</p><p>② 权值越小的叶节点越远离根节点</p><p>构造哈夫曼树的 <strong><font color=red>过程：</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHvMIH.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHxoNQ.md.png" alt=""></p><p><strong><font color=red>哈夫曼树的特点：</font></strong> <strong>n1 = 0</strong></p><p><strong>n = n0 + n1 + n2  =  n0 + n2  =  2n0 - 1</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YttzLR.md.png" alt=""></p><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>规定哈夫曼树中的 <strong><font color=red>左分支为0，右分支为1</font></strong> ，则从根节点到每个节点所经过的分支对应的0和1组成的序列便为该节点对应字符的编码。这样的编码称为 <strong><font color=red>哈夫曼编码</font></strong>。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/Ybp961.md.png" alt=""></p><p>在一组字符的哈夫曼编码中，不可能出现一个字符的哈夫曼编码是另一个字符哈夫曼编码的 <strong><font color=red>前缀</font></strong>。</p><p>例如，有4个字符的编码如下：100,  001,  0，1</p><p>这是哈夫曼编码吗？显然是错误的，因为0是001的前缀，不可能。</p><p>所以哈夫曼编码也称为 <strong><font color=red>前缀编码</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/Ybpc9J.md.png" alt=""></p><p>分析：选 <strong>D</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/Ybpb3d.md.png" alt=""></p><p>分析：选 <strong>A</strong>。哈夫曼树一定是二叉树，但不一定是完全二叉树。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;哈夫曼树的定义&quot;&gt;&lt;a href=&quot;#哈夫曼树的定义&quot; class=&quot;headerlink&quot; title=&quot;哈夫曼树的定义&quot;&gt;&lt;/a&gt;哈夫曼树的定义&lt;/h2&gt;&lt;p&gt;设二叉树具有n个带权值的叶节点，那么从根节点到各个叶节点的路径长度与相应节点权值的乘积的和，叫做二叉
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="哈夫曼树" scheme="https://wuhongbin.github.io/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>线索二叉树 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/30/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/30/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-30T02:46:43.000Z</published>
    <updated>2020-07-30T10:57:55.807Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下 线索二叉树知识点…</p><a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>对于具有n个节点的二叉树，采用二叉链存储时，每个节点有两个指针域，总共有 <strong>2n</strong> 个指针域。</p><p>其中只有 n-1 个节点被有效指针指向，即有 <strong>n-1</strong> 个非空指针域。</p><p>所以共有 2n - (n-1) = <strong>n+1</strong> 个空链域。</p><p><strong><font color=green>解释：</font></strong> <strong>除根节点</strong> （根节点没有指针指向）外，每个节点都有且仅有一个指向自己的指针，所以N个节点的二叉树，需要N-1个指针域，则空指针域有N+1个。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>① 采用某种方法遍历二叉树的结果是一个节点的 <strong><font color=red>线性序列</font></strong> 。</p><p>② <strong><font color=red>修改空链域</font></strong> 改为存放指向节点的前趋和后继节点的地址。</p><p>③ 这样的指向该线性序列中的 “ 前趋 ” 和 “ 后继 ” 的指针，称作 <strong><font color=red>线索 (thread)</font></strong> 。</p><p>④ 创建线索的过程称为 <strong><font color=red>线索化</font></strong> 。</p><p>⑤ <strong><font color=red>线索化的</font></strong> 二叉树称为 线索二叉树。</p><p>⑥ 显然线索二叉树与采用的遍历方法相关，有 <strong><font color=red>先序线索二叉树、中序线索二叉树和后序线索二叉树</font></strong>。</p><p>⑦ 线索二叉树的目的是提高 <strong><font color=red>该遍历过程</font></strong> 的效率。</p><h2 id="设计线索二叉树"><a href="#设计线索二叉树" class="headerlink" title="设计线索二叉树"></a>设计线索二叉树</h2><p>在节点的存储结构上增加 <strong><font color=red>两个标志位</font></strong> 来区分这两种情况：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHB8it.png" alt=""></p><p>这样，每个节点的存储结构如下：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHBYz8.png" alt=""></p><p>为了方便算法设计，在线索二叉树中再增加 <strong><font color=red>一个头节点</font></strong> 。</p><p>线索化二叉树中节点的类型定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;           <span class="comment">//节点数据域</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;          <span class="comment">//增加的线索标记</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">lchild</span>;</span>    <span class="comment">//左孩子或者线索指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">rchild</span>;</span>    <span class="comment">//右孩子或者线索指针    </span></span><br><span class="line">&#125;TBTNode;      <span class="comment">//线索树节点类型定义</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHrD2V.md.png" alt=""></p><h2 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h2><p>建立某种次序的线索化二叉树过程：</p><p>(1) 以该遍历方法遍历一棵二叉树。</p><p>(2) 在遍历的过程中，检查当前访问节点的左、右指针域是否为空：</p><p>​        ① 如果左指针域为空，将它改为指向前趋节点的线索；</p><p>​        ② 如果右指针域为空，将它改为指向后继节点的线索。</p><p>下面以 <strong><font color=red>中序线索二叉树</font></strong> 为例，设计建立线索二叉树的算法。</p><h3 id="建立中序线索二叉树的算法"><a href="#建立中序线索二叉树的算法" class="headerlink" title="建立中序线索二叉树的算法"></a>建立中序线索二叉树的算法</h3><p> ① <strong><font color=red>CreaThread(b)算法：</font></strong> 对以二叉链存储的二叉树b进行中序线索化，并返回线索化后头节点的指针root。</p><p>② <strong><font color=red>Thread(p)算法：</font></strong> 对以 *p 为根节点的二叉树子树的中序线索化。</p><p>在中序遍历中：</p><p>① p总是指向当前线索化的节点。</p><p>② pre 作为全局变量，指向刚刚访问过的节点。</p><p>③  ＊pre  是 ＊p 的中序前趋节点， ＊ p 是 ＊pre  的中序后继节点。</p><p>  <img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHcweU.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHgAmT.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">TBTNode * pre;      <span class="comment">//全局变量</span></span><br><span class="line"><span class="function">TBTNode * <span class="title">CreatThread</span><span class="params">(TBTNode * b)</span>      <span class="comment">//中序线索化二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TBTNode * root;</span><br><span class="line">    root = (TBTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TBTNode));  <span class="comment">//创建头节点</span></span><br><span class="line">    root-&gt;ltag = <span class="number">0</span>; </span><br><span class="line">    root-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    root-&gt;rchild = b;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        root-&gt;lchild = root;<span class="comment">//空二叉树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;lchild = b; </span><br><span class="line">        pre = root;<span class="comment">//pre是*p的前趋节点，供加加线索用</span></span><br><span class="line">        Thread(b);<span class="comment">//中序遍历线索化二叉树</span></span><br><span class="line">        pre-&gt;rchild = root;<span class="comment">//最后处理，加入指向头节点的线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        root-&gt;rchild = pre;<span class="comment">//头节点线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread</span><span class="params">(TBTNode *&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//中序遍历递归算法</span></span><br><span class="line">        Thread(p-&gt;lchild);<span class="comment">//左子树线索化</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)<span class="comment">//前趋线索化</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;lchild = pre;<span class="comment">//建立当前节点的前趋线索</span></span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;ltag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)<span class="comment">//后继线索化</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;rchild = p;<span class="comment">//建立前趋节点的前趋线索</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;rtag = <span class="number">0</span>;</span><br><span class="line">        pre = p; </span><br><span class="line">        Thread(p-&gt;rchild);<span class="comment">//递归调用右子树线索化 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历线索化二叉树"><a href="#遍历线索化二叉树" class="headerlink" title="遍历线索化二叉树"></a>遍历线索化二叉树</h2><p>遍历某种次序的线索二叉树，就是从该次序下的 <strong><font color=red>开始节点</font></strong> 出发，反复找到该节点在该次序下的后继节点，直到头节点。</p><p>以中序线索二叉树为例，开始节点时根节点的最左下节点。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YH78Fx.md.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在中序线索二叉树中中序遍历的过程:</span><br><span class="line">p指向根节点;</span><br><span class="line">while p ≠ root 时循环</span><br><span class="line">&#123;</span><br><span class="line">找开始节点 *p;</span><br><span class="line">访问 *p 节点;</span><br><span class="line">while(*p 节点有右线索)</span><br><span class="line">一直访问下去;</span><br><span class="line">    p 转向右孩子节点;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHHN40.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThInOrder</span><span class="params">(TBTNode * tb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TBTNode * p = tb-&gt;lchild;<span class="comment">//p指向根节点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=tb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">            p = p-&gt;lchild;<span class="comment">//找开始节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);<span class="comment">//访问开始节点</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rtag == <span class="number">1</span> &amp;&amp; p-&gt;rchild != tb)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>优点：</font></strong> 中序遍历算法既没有递归也没有用栈，空间效率得到提高。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下 线索二叉树知识点…&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="线索二叉树" scheme="https://wuhongbin.github.io/tags/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的构造 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-29T02:46:43.000Z</published>
    <updated>2020-07-30T10:58:27.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>同一棵而二叉树（假设每个节点值唯一）具有  <strong><font color=blue>唯一</font></strong>的先序序列、中序序列、后序序列。</p><p>但 <strong><font color=blue>不同的二叉树</font></strong> 可能具有相同的先序序列，中序序列或后序序列。</p><p><strong>例如：</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4TXsP.md.png" alt=""></p><blockquote><p><strong><font color=blue>结论：</font></strong></p><p>① 给定一棵二叉树（假设每个节点值唯一）的先序、中序和后序序列可以唯一构造（确定）出该二叉树。</p><p>② 仅由先序、中序或后序序列中的 <strong>一种</strong>，无法唯一构造出该二叉树。</p></blockquote><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p><strong>那么问题来了？如果给定先序、中序和后序序列中任意两个，是否可以唯一构造出该二叉树呢？</strong></p><blockquote><p><strong><font color=blue>答案：</font></strong></p><p>① 同时给定一棵二叉树的 <strong><font color=green>先序序列和中序序列 </font></strong> 就能唯一确定这棵二叉树</p><p>② 同时给定一棵二叉树的 <strong><font color=green>中序序列和后序序列 </font></strong> 就能唯一确定这棵二叉树</p></blockquote><h3 id="定理1："><a href="#定理1：" class="headerlink" title="定理1："></a><strong><font color=red>定理1：</font></strong></h3><p>任何n（N&gt;0）个不同节点的二叉树，都可以由它的<strong>中序序列和先序序列</strong>唯一确定。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4HUBV.md.png" alt=""></p><p><strong>例如：</strong> 已知先序序列为 ABDGCEF ，中序序列为 DGBAECF，则构造二叉树的过程如下所示。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4bra8.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YIG9mD.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由上述定理得到以下算法</span></span><br><span class="line"><span class="function">BTNOde * <span class="title">CreateBT1</span><span class="params">(<span class="keyword">char</span> * pre, <span class="keyword">char</span> * in, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * s; <span class="keyword">char</span> * p; <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    s = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));  <span class="comment">//创建根节点</span></span><br><span class="line">    s-&gt;data = *pre;</span><br><span class="line">    <span class="keyword">for</span>(p = in;p &lt; in+n;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*p == *pre)<span class="comment">//在in中找为*pre的位置k</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = p-in;</span><br><span class="line">s-&gt;lchild = CreateBT1(pre+<span class="number">1</span>, in, k);<span class="comment">//构造左子树</span></span><br><span class="line">    s-&gt;rchild = CreateBT1(pre+k+<span class="number">1</span>, p+<span class="number">1</span>, n-k<span class="number">-1</span>);<span class="comment">//构造右子树</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定理2："><a href="#定理2：" class="headerlink" title="定理2："></a><strong><font color=red>定理2：</font></strong></h3><p>任何n（N&gt;0）个不同节点的二叉树，都可以由它的<strong>中序序列和后序序列</strong>唯一确定。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4qrO1.md.png" alt=""></p><p><strong>例如：</strong> 已知中序序列为 DGBAECF，后序序列 GDBEFCA 则构造二叉树的过程如下所示。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4qqk8.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YI0lAf.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由上述定理得到以下算法</span></span><br><span class="line"><span class="function">BTNOde * <span class="title">CreateBT2</span><span class="params">(<span class="keyword">char</span> * post, <span class="keyword">char</span> * in, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * b; <span class="keyword">char</span> r, * p; <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    r = *(post+n<span class="number">-1</span>);                       <span class="comment">//根节点值</span></span><br><span class="line">    b = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));  <span class="comment">//创建二叉树根节点*b</span></span><br><span class="line">    b-&gt;data = r;</span><br><span class="line">    <span class="keyword">for</span>(p = in;p &lt; in+n;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*p == r)<span class="comment">//在in中找为*pre的位置k</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = p-in;<span class="comment">//k为根节点在in中的下标</span></span><br><span class="line">s-&gt;lchild = CreateBT2(post, in, k);<span class="comment">//构造左子树</span></span><br><span class="line">    s-&gt;rchild = CreateBT2(post + k, p+<span class="number">1</span>, n-k<span class="number">-1</span>);<span class="comment">//构造右子树</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题1："><a href="#例题1：" class="headerlink" title="例题1："></a><strong><font color=red>例题1：</font></strong></h3><p>设计一个算法将二叉树的<strong>顺序存储结构</strong>转化成<strong>二叉链存储结构</strong>。</p><p><strong><font color=green>解：</font></strong>设二叉树的顺序存储结构为a，由f(a,1)返回创建的二叉链存储结构的根节点指针b</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YI50VU.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode * <span class="title">trans1</span><span class="params">(SqBTree a, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * b;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[i] == <span class="string">'#'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//当节点不存在时返回NULL</span></span><br><span class="line">    b = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));   <span class="comment">//创建根节点</span></span><br><span class="line">    b -&gt; data = a[i];</span><br><span class="line">    b -&gt; lchild = trans1(a, <span class="number">2</span>*i);     <span class="comment">//递归创建左子树</span></span><br><span class="line">    b -&gt; rchild = trans1(a, <span class="number">2</span>*i+<span class="number">1</span>);     <span class="comment">//递归创建左子树</span></span><br><span class="line">    <span class="keyword">return</span>(b);<span class="comment">//返回根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此算法是先序遍历的思路</span></span><br></pre></td></tr></table></figure><h3 id="例题2："><a href="#例题2：" class="headerlink" title="例题2："></a><strong><font color=red>例题2：</font></strong></h3><p>设计一个算法将二叉树的<strong>二叉链存储结构</strong>转化成<strong>顺序存储结构</strong>。</p><p><strong><font color=green>解：</font></strong>f(b，a，i)：由二叉链b创建a[i]为根节点的顺序存储结构a</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YIoA1A.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">trans2</span><span class="params">(BTNode * b, SqBTree a, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = b -&gt; data;<span class="comment">//创建根节点</span></span><br><span class="line">        trans2(b -&gt; lchild, a, <span class="number">2</span>*i);     <span class="comment">//递归创建左子树</span></span><br><span class="line">        trans2(b -&gt; rchild, a, <span class="number">2</span>*i+<span class="number">1</span>);     <span class="comment">//递归创建左子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此算法是先序遍历的思路</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;p&gt;同一棵而二叉树（假设每个节点值唯一）具有  &lt;strong&gt;&lt;font color=blue&gt;唯一&lt;/font&gt;&lt;/strong&gt;的先序序列
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="构造二叉树" scheme="https://wuhongbin.github.io/tags/%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的基本运算及其实现 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-28T09:46:43.000Z</published>
    <updated>2020-07-30T10:59:08.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的基本运算概述"><a href="#二叉树的基本运算概述" class="headerlink" title="二叉树的基本运算概述"></a>二叉树的基本运算概述</h2><p>①  <strong><font color=red>创建二叉树 CreateBTNode(*b, *str)：</font></strong> 根据根据二叉树括号表示法字符串str生成对应的二叉链存储结构b</p><p>②  <strong><font color=red>销毁二叉链存储结构 DestoryBT( *b)：</font></strong> 销毁二叉链b并释放空间</p><p>③  <strong><font color=red>查找节点 FindNode(*b, x)：</font></strong> 在二叉树b中寻找data域值为x的节点，并返回指向该节点的指针</p><p>④  <strong><font color=red>找孩子节点 LchildNode(p) 和 RchildNode(p)：</font></strong>分别求二叉树中节点*p的左孩子节点和右孩子节点</p><p>⑤  <strong><font color=red>求高度 BTNodeDepth(*b)：</font></strong>求二叉树b的高度。若二叉树为空，则其高度为0; 否则，其高度等于左子树和右子树中的最大高度加1</p><p>⑥  <strong><font color=red>输出二叉树 DispBTNode(*b)：</font></strong>以括号表示法输出一棵二叉树</p><h2 id="二叉树的基本运算算法实现"><a href="#二叉树的基本运算算法实现" class="headerlink" title="二叉树的基本运算算法实现"></a>二叉树的基本运算算法实现</h2><h3 id="1-创建二叉树-CreateBTNode-b-str-："><a href="#1-创建二叉树-CreateBTNode-b-str-：" class="headerlink" title="1. 创建二叉树 CreateBTNode(*b, *str)："></a><strong><font color=red>1. 创建二叉树 CreateBTNode(*b, *str)：</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YN4QmR.md.png" alt=""></p><h4 id="算法设计："><a href="#算法设计：" class="headerlink" title=" 算法设计："></a><strong><font color=red> 算法设计：</font></strong></h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YN4KX9.md.png" alt=""></p><h4 id="用ch扫描采用括号表示法表示二叉树的字符串："><a href="#用ch扫描采用括号表示法表示二叉树的字符串：" class="headerlink" title=" 用ch扫描采用括号表示法表示二叉树的字符串："></a><strong><font color=red> 用ch扫描采用括号表示法表示二叉树的字符串：</font></strong></h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YN4zAx.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由str → 二叉链b</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBTNode</span><span class="params">(BTNode *b, <span class="keyword">char</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *St[MaxSize], *p;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>, k, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;                   </span><br><span class="line">    b = <span class="literal">NULL</span>;       <span class="comment">//建立的二叉链初始时为空</span></span><br><span class="line">    ch = str[j];</span><br><span class="line">    <span class="keyword">while</span>(ch != <span class="string">'\0'</span>)  <span class="comment">//str未扫描完时循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span> :top++;St[top] = p; k = <span class="number">1</span>; <span class="keyword">break</span>;  <span class="comment">//可能有左孩子节点，进栈</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span> :top--;<span class="keyword">break</span>;<span class="comment">//退栈</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">','</span> :k = <span class="number">2</span>;<span class="keyword">break</span>;      <span class="comment">//后面为右孩子节点</span></span><br><span class="line">            <span class="keyword">default</span> :<span class="comment">//遇到节点值</span></span><br><span class="line">                p = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>)(BTNode);</span><br><span class="line">                p-&gt;data=ch;</span><br><span class="line">                p-&gt;lchild = p-&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span>(b = <span class="literal">NULL</span>)<span class="comment">//p为二叉树的根节点</span></span><br><span class="line">                    b = p;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//已建立二叉树根节点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">switch</span>(k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>: St[top]-&gt;lchild = p;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>: St[top]-&gt;rchild = p;<span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        j++; ch =str[j];      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-销毁二叉链-DestoryBT-b-："><a href="#2-销毁二叉链-DestoryBT-b-：" class="headerlink" title="2. 销毁二叉链 DestoryBT( *b)："></a><strong><font color=red>2. 销毁二叉链 DestoryBT( *b)：</font></strong></h3><p>设f(b)销毁二叉链b：<strong><font color=red>大问题</font></strong></p><p>则f(b-&gt;lchild)销毁左子树，f(b-&gt;rchild)销毁右子树：<strong><font color=red>两个小问题</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YNzUgA.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryBT</span><span class="params">(BTNOde *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        DestoryBT(b-&gt;lchild);</span><br><span class="line">        DestoryBT(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(b);  <span class="comment">//剩下一个节点*b，直接释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-查找节点-FindNode-b-x"><a href="#3-查找节点-FindNode-b-x" class="headerlink" title="3. 查找节点 FindNode(*b, x)"></a><strong><font color=red>3. 查找节点 FindNode(*b, x)</font></strong></h3><p>设f(b, x)在二叉树b中查找值为x的节点（唯一）。找到后返回其指针，否则返回NULL。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YUF5Qg.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function">BTNode * <span class="title">FindNode</span><span class="params">(BTNode * b, ELemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * p;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;data == x)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = FindNode(b-&gt;lchild, x);</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> FindNode(b-&gt;rchild, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-找孩子节点-LchildNode-p-和-RchildNode-p"><a href="#4-找孩子节点-LchildNode-p-和-RchildNode-p" class="headerlink" title="4. 找孩子节点 LchildNode(p) 和 RchildNode(p)"></a><strong><font color=red>4. 找孩子节点 LchildNode(p) 和 RchildNode(p)</font></strong></h3><p>直接返回 *p 节点的左孩子节点或右孩子节点的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode * <span class="title">LchildNode</span><span class="params">(BTNode * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BTNode * <span class="title">RchildNode</span><span class="params">(BTNode * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-求高度-BTNodeDepth-b"><a href="#5-求高度-BTNodeDepth-b" class="headerlink" title="5. 求高度 BTNodeDepth(*b)"></a><strong><font color=red>5. 求高度 BTNodeDepth(*b)</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YUAzZ9.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BTNodeDepth</span><span class="params">(BTNode * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lchildep,rchilddep;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);    <span class="comment">//空树的高度为0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        lchildep = BTNodeDepth(b-&gt;lchild);   <span class="comment">//求左子树的高度lchildep</span></span><br><span class="line">        rchilddep = BTNodeDepth(b-&gt;rchild);  <span class="comment">//求右子树的高度rchildep</span></span><br><span class="line">        <span class="keyword">return</span> ((lchildep&gt;rchilddep)?(lchildep+<span class="number">1</span>):(rchildep+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-输出二叉树-DispBTNode-b"><a href="#6-输出二叉树-DispBTNode-b" class="headerlink" title="6. 输出二叉树 DispBTNode(*b)"></a><strong><font color=red>6. 输出二叉树 DispBTNode(*b)</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YUVOHJ.md.png" alt=""></p><p>根节点 （ 左子树  ，右子树） ←  括号表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">DispBTNode</span><span class="params">(BTNode * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;lchild != <span class="literal">NULL</span> || b-&gt;rchild != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">            DispBTNode(b-&gt;lchild);  <span class="comment">//递归处理左子树</span></span><br><span class="line">            <span class="keyword">if</span>(b-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">","</span>);</span><br><span class="line">            DispBTNode(b-&gt;rchild);  <span class="comment">//递归处理右子树</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树的基本运算概述&quot;&gt;&lt;a href=&quot;#二叉树的基本运算概述&quot; class=&quot;headerlink&quot; title=&quot;二叉树的基本运算概述&quot;&gt;&lt;/a&gt;二叉树的基本运算概述&lt;/h2&gt;&lt;p&gt;①  &lt;strong&gt;&lt;font color=red&gt;创建二叉树 Creat
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的遍历及其应用 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-27T09:46:43.000Z</published>
    <updated>2020-07-30T10:59:55.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树遍历的概念"><a href="#二叉树遍历的概念" class="headerlink" title="二叉树遍历的概念"></a>二叉树遍历的概念</h2><p><strong><font color=red>二叉树的遍历</font></strong> 是指按照一定次序访问树中所有节点，并且 <strong><font color=red>每个节点仅被访问一次</font></strong> 的过程。</p><p>遍历是二叉树最基本的运算，是二叉树其他运算的基础。</p><p><strong>二叉树的组成：</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/Yd2JFf.png" alt=""></p><h3 id="1-先序遍历过程"><a href="#1-先序遍历过程" class="headerlink" title="1. 先序遍历过程"></a><strong><font color=red>1. 先序遍历过程</font></strong></h3><p>先序遍历NLR二叉树的过程是：</p><p>① 访问根节点;</p><p>② 先序遍历左子树;</p><p>③ 先序遍历右子树。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdR9tf.md.png" alt=""></p><h3 id="2-中序遍历过程"><a href="#2-中序遍历过程" class="headerlink" title="2. 中序遍历过程"></a><strong><font color=red>2. 中序遍历过程</font></strong></h3><p>中序遍历LNR二叉树的过程是：</p><p>① 中序遍历左子树；</p><p>② 访问根节点；</p><p>③ 中序遍历右子树。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdRi9S.md.png" alt=""></p><h3 id="3-后序遍历过程"><a href="#3-后序遍历过程" class="headerlink" title="3. 后序遍历过程"></a><strong><font color=red>3. 后序遍历过程</font></strong></h3><p>中序遍历LNR二叉树的过程是：</p><p>① 后序遍历左子树；</p><p>② 后序遍历右子树；</p><p>③ 访问根节点。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdRCh8.md.png" alt=""></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a><strong><font color=green>例题</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdftfK.md.png" alt=""></p><h2 id="二叉树遍历递归算法"><a href="#二叉树遍历递归算法" class="headerlink" title="二叉树遍历递归算法"></a>二叉树遍历递归算法</h2><p>由二叉树的三种遍历过程直接得到3种递归算法</p><h3 id="先序遍历的递归算法"><a href="#先序遍历的递归算法" class="headerlink" title="先序遍历的递归算法"></a><strong><font color=blue>先序遍历的递归算法</font></strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(b-&gt;lchild);</span><br><span class="line">        PreOrder(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 <strong>访问</strong> 是直接输出节点值。实际上，访问节点可以对该节点进行各种操作，如计数，删除节点等。</p><h3 id="中序遍历的递归算法"><a href="#中序遍历的递归算法" class="headerlink" title="中序遍历的递归算法"></a><strong><font color=blue>中序遍历的递归算法</font></strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrder(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">        InOrder(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历的递归算法"><a href="#后序遍历的递归算法" class="headerlink" title="后序遍历的递归算法"></a><strong><font color=blue>后序遍历的递归算法</font></strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrder(b-&gt;lchild);</span><br><span class="line">        PostOrder(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层次遍历算法"><a href="#层次遍历算法" class="headerlink" title="层次遍历算法"></a>层次遍历算法</h2><p>层次遍历过程：</p><p>对于一棵二叉树，从根节点开始，按从上到下，从左到右的顺序访问每一个节点。</p><p>每个节点仅仅访问一次。</p><h3 id="算法设计思路"><a href="#算法设计思路" class="headerlink" title="算法设计思路"></a>算法设计思路</h3><p>使用一个队列。</p><p>Ⅰ 将根节点进队;</p><p>Ⅱ <strong><font color=blue>队不空时循环</font></strong>：从队列中列出一个节点 *p 访问它；</p><p>​    ① 若它有左孩子节点，将左孩子节点进队；</p><p>​    ② 若它有右孩子节点，将右孩子节点进队。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BTNode * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * p;</span><br><span class="line">    BTNode *qu[MaxSize];  <span class="comment">//定义环形队列，存放节点指针</span></span><br><span class="line">    <span class="keyword">int</span> front,rear;       <span class="comment">//定义对头和队尾指针</span></span><br><span class="line">    front = rear = <span class="number">0</span>;     <span class="comment">//置队列为空队列</span></span><br><span class="line">    rear++;</span><br><span class="line">    qu[rear] = b;         <span class="comment">//根节点指针进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(front != rear)  <span class="comment">//队列不为空循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        front = (front + <span class="number">1</span>)%MaxSize;</span><br><span class="line">        p = qu[front];    <span class="comment">//队头出队列</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);  <span class="comment">//访问节点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)   <span class="comment">//有左孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear = (rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">            qu[rear] = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)   <span class="comment">//有右孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear = (rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">            qu[rear] = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法的时间复杂度为O(n)</strong></p><h2 id="二叉树3种递归遍历算法的应用"><a href="#二叉树3种递归遍历算法的应用" class="headerlink" title="二叉树3种递归遍历算法的应用"></a>二叉树3种递归遍历算法的应用</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><strong><font color=green>基本思路</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/Yw1DA0.md.png" alt=""></p><p><strong><font color=green>例1：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法，计算一棵给定二叉树的所有节点个数</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwGAkq.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Nodes</span><span class="params">(BTNode * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Nodes(b-&gt;lchild)+Nodes(b-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//先左子树，再右子树，最后根节点，是后序遍历的思路</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>提示</font></strong>:<strong>本例算法可以基于任何一种遍历算法</strong></p><p><strong><font color=green>例2：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法，计算一棵给定二叉树的所有叶子节点个数</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwGp6g.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafNodes</span><span class="params">(BTNode * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; b-&gt;rchlid == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        num1 = LeafNodes(b-&gt;lchild);</span><br><span class="line">        num2 = LeafNodes(b-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> (num1+num2);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>提示</font></strong>:<strong>本例算法可以基于任何一种遍历算法</strong></p><p><strong><font color=green>例3：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法把二叉树b复制到二叉树t中</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwJUP0.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(BTNode * b, BTNode * t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">        t-&gt;data = b-&gt;data;<span class="comment">//复制一个根节点*t</span></span><br><span class="line">        Copy(b-&gt;lchild, t-&gt;lchild);    <span class="comment">//递归复制左子树</span></span><br><span class="line">        Copy(b-&gt;rchild, t-&gt;rchild);     <span class="comment">//递归复制右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>先根节点，再左子树，最后右子树，是先序遍历的思路</p><p><strong><font color=green>例4：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法把二叉树b的左、右子树进行交换。要求 <font color=red>不破坏原二叉树</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwYGQO.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(BTNode * b, BTNode * t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">        t-&gt;data = b-&gt;data;<span class="comment">//复制一个根节点*t</span></span><br><span class="line">        Swap(b-&gt;lchild, t-&gt;rchild);    <span class="comment">//递归交换左子树</span></span><br><span class="line">        Swap(b-&gt;rchild, t-&gt;lchild);     <span class="comment">//递归交换右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=green>例5：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法level()求二叉树b中值为x的节点的层次（假设所有节点值唯一）。</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwtDE9.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwtrNR.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/Ywt0HJ.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">(BTNode * b, ElemType x, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空树时返回0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;data == x)<span class="comment">//找到节点时</span></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        l = level(b-&gt;lchild, x, h+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> level(b-&gt;rchild, x, h+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> l;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>注意：</font></strong>基于<strong>先序遍历</strong>算法思想</p><h2 id="层次遍历算法的应用"><a href="#层次遍历算法的应用" class="headerlink" title="层次遍历算法的应用"></a>层次遍历算法的应用</h2><p><strong><font color=green>例1：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法输出从根节点到每个叶子节点的逆路径。</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwNJVH.png" alt=""></p><p><strong>解：</strong> 设计的队列为非环形队列qu，将所有已访问过的节点指针进队，并在队列中保存双亲节点的位置。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwNxsO.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AllPath</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snode</span>;</span></span><br><span class="line">    &#123;</span><br><span class="line">        BTNode * node;     <span class="comment">//存放当前节点指针</span></span><br><span class="line">        <span class="keyword">int</span> parent;   <span class="comment">//存放双亲节点在队列中的位置</span></span><br><span class="line">    &#125;qu[MaxSize];   <span class="comment">//定义非环形队列</span></span><br><span class="line">    BTNode *q;</span><br><span class="line">    <span class="keyword">int</span> front, rear, p;    <span class="comment">//定义队头和队尾指针</span></span><br><span class="line">    front = rear = <span class="number">-1</span>;     <span class="comment">//置队列为空队列</span></span><br><span class="line">    rear++;</span><br><span class="line">    qu[rear].node = b;     <span class="comment">//根节点指针进去队列</span></span><br><span class="line">    qu[rear].parent = <span class="number">-1</span>;  <span class="comment">//根节点没有双亲节点</span></span><br><span class="line">    <span class="keyword">while</span>(front != rear)   <span class="comment">//队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        front++;   <span class="comment">//front是当前节点*q在qu中的位置</span></span><br><span class="line">        q = qu[front].node;  <span class="comment">//队列出队列，该节点指针仍在qu中</span></span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; q-&gt;rchild == <span class="literal">NULL</span>)  <span class="comment">//*q为叶子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = front;     <span class="comment">//输出*q到根节点的逆路径序列</span></span><br><span class="line">            <span class="keyword">while</span>(qu[p].parent != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c-&gt;"</span>, qu[p].node-&gt;data);</span><br><span class="line">                p = qu[p].parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c\m"</span>, qu[p].node-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild != <span class="literal">NULL</span>)   <span class="comment">//*q节点有左孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear++;</span><br><span class="line">            qu[rear].node = q-&gt;lchild;</span><br><span class="line">            qu[rear].parent = front;  <span class="comment">//*q的左孩子的双亲位置为front</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild != <span class="literal">NULL</span>)   <span class="comment">//*q节点有右孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear++;</span><br><span class="line">            qu[rear].node = q-&gt;rchild;</span><br><span class="line">            qu[rear].parent = front;  <span class="comment">//*q的右孩子的双亲位置为front</span></span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树遍历的概念&quot;&gt;&lt;a href=&quot;#二叉树遍历的概念&quot; class=&quot;headerlink&quot; title=&quot;二叉树遍历的概念&quot;&gt;&lt;/a&gt;二叉树遍历的概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;font color=red&gt;二叉树的遍历&lt;/font&gt;&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="遍历二叉树" scheme="https://wuhongbin.github.io/tags/%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
