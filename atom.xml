<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>时光如水の总是无言</title>
  
  <subtitle>wuhongbin&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuhongbin.github.io/"/>
  <updated>2020-07-16T10:43:59.284Z</updated>
  <id>https://wuhongbin.github.io/</id>
  
  <author>
    <name>时光如水の总是无言</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MindMaster(亿图思维导图 ) Pro 破解版</title>
    <link href="https://wuhongbin.github.io/2020/07/07/MindMaster(%E4%BA%BF%E5%9B%BE%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%20)%20Pro%20%E7%A0%B4%E8%A7%A3%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/07/MindMaster(%E4%BA%BF%E5%9B%BE%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%20)%20Pro%20%E7%A0%B4%E8%A7%A3%E7%89%88/</id>
    <published>2020-07-07T02:01:43.000Z</published>
    <updated>2020-07-16T10:43:59.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        MindMaster 自带幻灯片展示功能，不需要借助其他的工具，就可以进行幻灯片展示。同时支持一键将思维导图拆分成多个幻灯片页面，可以在全屏模式下遍历思维导图的主题或者分支，当思维导图内容较多时，也可以很好的将每个细节展示清楚，除此之外，MindMaster 专业版还可以将思维导图幻灯片导出为 PPT 格式，在 Office PowerPoint 中，进行分页展示和打印。</p><p>MindMaster 专业版搭载亿图云服务，提供多人协作办公的功能，团队办公中轻松实现文件共享、编辑，1G 云空间让文件保存和分享更方便自由。通过添加、管理自定义的标签，在进行任务管理的人员分配时，还可以更高效地设置任务信息。MindMaster 专业版还可以从思维导图一键生产甘特图。在思维导图中添加的任务信息会一一对应到甘特图中，思维导图和甘特可以同步编辑、更新。绘制好的甘特图，还可以导出至 PDF 格式，对于进行日程计划、安排、任务管理等，都非常的实用。</p><p>MindMaster 专业版在免费版的基础上，增加了更多主题样式，通过彩虹色、单色、对称色、交替色四种配色，让思维导图色彩更丰富，同时还可以一键切换漂亮的手绘模式的思维导图，除此之外，MindMaster 专业版还提供了丰富的高清且纯矢量剪贴画，适用于商业、教育、人物、自然、科技等各个领域。</p><p>MindMaster 专业版可以将思维导图导出为 Word、PPT、Excel、PDF 等文件格式，无需使用MindMaster 软件就可以进行再次编辑、修改。同时 MindMaster 专业版还支持导出更高 DPI 图片格式，以及 HTML 和 SVG 格式。</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>@果核剥壳 绿色破解制作</p><p>破解后无需屏蔽程序联网</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UDbK6s.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UDbMXn.md.png" alt=""></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://www.lanzous.com/b00zda7wd" target="_blank" rel="noopener">https://www.lanzous.com/b00zda7wd</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        MindMaster 自带幻灯片展示功能，不需要借助其他的工具，就可以进行幻灯片展示。同时支持一键将思维导
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="办公开发" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E5%8A%9E%E5%85%AC%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>GeoGebra(数学软件)v6.0.591.0 多平台版</title>
    <link href="https://wuhongbin.github.io/2020/07/06/GeoGebra(%E6%95%B0%E5%AD%A6%E8%BD%AF%E4%BB%B6)v6.0.591.0%20%E5%A4%9A%E5%B9%B3%E5%8F%B0%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/06/GeoGebra(%E6%95%B0%E5%AD%A6%E8%BD%AF%E4%BB%B6)v6.0.591.0%20%E5%A4%9A%E5%B9%B3%E5%8F%B0%E7%89%88/</id>
    <published>2020-07-06T03:01:43.000Z</published>
    <updated>2020-07-16T10:35:19.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>本软件是一款跨平台的动态数学教学与绘制软件，功能非常强大，并且是免费的，难能可贵！</p><p>GeoGebra 是一个结合「几何」、「代数」与「微积分」的动态数学软件，它是由美国佛罗里达州亚特兰大学的数学教授Markus Hohenwarter所设计的。 一方面来说，GeoGebra 是一个动态的几何软件。您可以在上面画点、向量、线段、直线、多边形、圆锥曲线，甚至是函数，事后你还可以改变它们的属性。<br>另一方面来说，您也可以直接输入方程和点坐标。所以，GeoGebra 也有处理变数的能力（这些变数可以是一个数字、角度、向量或点坐标），它也可以对函数作微分与积分，找出方程的根或计算函数的极大极小值。<br>所以 GeoGebra 同时具有处理代数与几何的功能，因此 GeoGebra 视窗左边有一个「代数区」，右边有一个「几何区」（也称为「绘图区」），就像下图一样。</p><h1 id="软件特色"><a href="#软件特色" class="headerlink" title="软件特色"></a>软件特色</h1><p>* 可免费用于学习、教学和考评。<br>* 功能强大、使用简单、交互性强。<br>* 支持多种语言。<br>* 以趣味的方式真正观察和体验数学和科学。<br>* 可适于各种课程或项目。<br>* 在世界上有数百万人使用。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UD7Q3j.md.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UD7MCQ.md.jpg" alt=""></p><h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><p>制图：考试和非考试相同<br>改进了符号输入框（包括通过输入“错误”语法无法更改矢量和类型）<br>错误修正：ggbApplet.setFixed（）不再触发OnUpdate脚本<br>RandomElement（{1 / 2,1 / 3,1 / 4}）效果更好<br>Android：修复HTC手机上的键盘关闭问题</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://ghboke.ctfile.com/dir/7369060-34163107-384f41/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-34163107-384f41/</a></p><p>链接：<a href="https://pan.baidu.com/s/19ezbfdpyE4O5z9SwqXrRPw" target="_blank" rel="noopener">https://pan.baidu.com/s/19ezbfdpyE4O5z9SwqXrRPw</a>  提取码：unwp</p><p><a href="https://www.lanzous.com/b00z91y6b" target="_blank" rel="noopener">https://www.lanzous.com/b00z91y6b</a></p><p><strong>温馨提示：</strong>任选一链接下载即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;本软件是一款跨平台的动态数学教学与绘制软件，功能非常强大，并且是免费的，难能可贵！&lt;/p&gt;
&lt;p&gt;GeoGebra 是一个结
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="办公开发" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E5%8A%9E%E5%85%AC%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Snipaste(截图&amp;贴图)v2.4 Beta 绿色版</title>
    <link href="https://wuhongbin.github.io/2020/07/05/Snipaste(%E6%88%AA%E5%9B%BE&amp;%E8%B4%B4%E5%9B%BE)v2.4%20Beta%20%E7%BB%BF%E8%89%B2%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/05/Snipaste(%E6%88%AA%E5%9B%BE&amp;%E8%B4%B4%E5%9B%BE)v2.4%20Beta%20%E7%BB%BF%E8%89%B2%E7%89%88/</id>
    <published>2020-07-05T03:01:43.000Z</published>
    <updated>2020-07-16T06:15:03.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Snipaste 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上！下载并打开 Snipaste，按下 <code>F1</code> 来开始截图，再按 <code>F3</code>，截图就在桌面置顶显示了。就这么简单！</p><p>你还可以将剪贴板里的文字或者颜色信息转化为图片窗口，并且将它们进行缩放、旋转、翻转、设为半透明，甚至让鼠标能穿透它们！如果你是程序员、设计师，或者是大部分工作时间都在电脑前，贴图功能将改变你的工作方式、提升工作效率。</p><p>Snipaste 使用很简单，但同时也有一些较高级的用法可以进一步提升你的工作效率。感兴趣的话，请抽空读一读<a href="https://docs.snipaste.com/#/zh-cn/" target="_blank" rel="noopener">用户手册</a>。</p><p>Snipaste 是免费软件，它也很安全，没有广告、不会扫描你的硬盘、更不会上传用户数据，它只做它应该做的事。</p><p><a href="https://img.lguohe.com/uploads/2019/07/N3QEb3VA.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/07/N3QEb3VA.png" alt="img"></a></p><h2 id="软件特色"><a href="#软件特色" class="headerlink" title="软件特色"></a>软件特色</h2><h3 id="强大的截图"><a href="#强大的截图" class="headerlink" title="强大的截图"></a>强大的截图</h3><p><a href="https://img.lguohe.com/uploads/2019/07/N3038l46.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/07/N3038l46.png" alt="img"></a></p><ul><li>自动检测界面元素区域</li><li>像素级的鼠标移动控制、截图范围控制</li><li>取色器 (试试 <code>F1</code>, <code>C</code>, <code>F3</code>)</li><li><strong>历史记录回放</strong> (<code>,</code>/<code>.</code>)</li><li>支持多屏</li><li>支持高分屏</li></ul><h3 id="把图片作为窗口置顶显示"><a href="#把图片作为窗口置顶显示" class="headerlink" title="把图片作为窗口置顶显示"></a>把图片作为窗口置顶显示</h3><p><a href="https://img.lguohe.com/uploads/2019/07/P9A3LpoY.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/07/P9A3LpoY.png" alt="img"></a></p><ul><li>支持将剪贴板中的以下内容转为图片<ul><li>图像</li><li>纯文本</li><li>HTML 文本</li><li>颜色信息</li><li>图像文件：PNG, JPG, BMP, ICO, <strong>GIF</strong> 等</li></ul></li><li>图片窗口支持的操作<ul><li>缩放 (<code>鼠标滚轮</code> 或者 <code>+</code>/<code>-</code>)<br>对于 GIF 图片则是加速/减速</li><li>旋转 (<code>1</code>/<code>2</code>)<br>对于 GIF 图片则是 上一帧/下一帧</li><li>镜像翻转 (<code>3</code>/<code>4</code>)</li><li>设置透明度 (<code>Ctrl</code> + <code>鼠标滚轮</code> 或者 <code>Ctrl</code>+ <code>+</code>/<code>-</code>)</li><li>鼠标穿透 (<code>X</code>, 取消则按 <code>F4</code>)</li><li>缩略图 (<code>Shift</code> + <code>双击</code>)</li><li>图像标注 (<code>空格键</code>)</li><li>隐藏 (<code>左键双击</code>)</li><li>…</li></ul></li><li>取色 (<code>Alt</code>)</li><li>文件拖放</li><li><strong>贴图分组</strong></li><li><strong>自动备份、恢复</strong></li></ul><h3 id="方便地标注图像"><a href="#方便地标注图像" class="headerlink" title="方便地标注图像"></a>方便地标注图像</h3><p><a href="https://img.lguohe.com/uploads/2019/07/vu1nkxdD.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/07/vu1nkxdD.png" alt="img"></a></p><ul><li>丰富的画图工具<ul><li>矩形</li><li>椭圆</li><li>线条</li><li>箭头</li><li>铅笔</li><li>马克笔</li><li>文字</li></ul></li><li>高级标注工具<ul><li>马赛克</li><li>高斯模糊</li><li>橡皮擦</li></ul></li><li>撤销、重做</li></ul><h3 id="自定义设置"><a href="#自定义设置" class="headerlink" title="自定义设置"></a>自定义设置</h3><p><a href="https://img.lguohe.com/uploads/2019/07/TNqoS229.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/07/TNqoS229.png" alt="img"></a></p><p>主题色、界面字体、通知栏图标等<br>快捷键<br>丰富的功能性选项</p><h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><p>修复无法以管理员权限开机启动<br>修复中文字体描边 #1475<br>[Mac] 修复首选项窗口在深色模式下的样式错误<br>[Mac] 修复菜单栏图标的菜单点击无效的问题 #1467</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://ghboke.ctfile.com/dir/7369060-34701258-d02fe8/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-34701258-d02fe8/</a></p><p>链接：<a href="https://pan.baidu.com/s/14EVfjqFNLfF8WJptxcK0Ug" target="_blank" rel="noopener">https://pan.baidu.com/s/14EVfjqFNLfF8WJptxcK0Ug</a>    提取码：4ngr</p><p><a href="https://www.lanzous.com/b00zdqjod" target="_blank" rel="noopener">https://www.lanzous.com/b00zdqjod</a></p><p><strong>温馨提示：</strong> 任选一链接下载即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Snipaste 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上！下载并打开 Snipaste，
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="系统增强" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%BC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Bandicam v4.6.1.1688 便携特别版</title>
    <link href="https://wuhongbin.github.io/2020/07/05/Bandicam%20v4.6.1.1688%20%E4%BE%BF%E6%90%BA%E7%89%B9%E5%88%AB%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/05/Bandicam%20v4.6.1.1688%20%E4%BE%BF%E6%90%BA%E7%89%B9%E5%88%AB%E7%89%88/</id>
    <published>2020-07-05T02:01:43.000Z</published>
    <updated>2020-07-30T06:38:42.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Bandicam，游戏录制神器，视频录制利器，高清频录制专家，号称世界三大视频录制神器之一！Bandicam是一款由韩国开发的高清游戏及视频录制的电脑工具。它录制的视频文件不仅体积小，而且画质相当清晰，支持H.264预制高清，以较高的压缩率可录制超过分辨率高达2560×1600高画质视频（1080p全高清视频），录制的同时还可以添加个性化 LOGO到视频中，Bandicam支持bmp、png 、jpeg等格式截图。</p><p>专业高清录屏软件Bandicam现已更新至 4.x，4.0版本界面更好看，功能更多</p><p>Bandicam游戏机可以记录程序/ OpenGL和DirectX Fraps（Fraps Alternative，Better thanFraps®）</p><p>您可以在不停机的情况下录制超过24小时（全自动录音功能可以使用）</p><p>您可以将录制的文件上传到YouTube而不进行转换（可以制作720p / 1080p全高清视频）</p><p>录制的文件大小远小于其他软件。</p><p>您可以录制高达3840 x 2160像素分辨率的4K超高清视频</p><p>您将会遇到比其他捕获软件游戏少得多的滞后（使用更低的CPU / GPU / HDD）</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>@果核剥壳</p><p>便携制作</p><p>启动即为破解版，无需屏蔽联网</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><a href="https://img.lguohe.com/uploads/2017/07/Bandicamjt4.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2017/07/Bandicamjt4.png" alt="img"></a></p><h1 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h1><p>andicam现在支持AMD VCE / VCN HEVC编码器。<br>更新了英特尔快速同步视频编码器。<br>改进了HEVC编码器的稳定性。<br>改进了Vulkan挂钩兼容性。<br>错误修复<br>在屏幕录制模式下，橡皮擦功能的撤消/重做无法正常工作。<br>多个命令行参数无法正常工作。<br>例如）bdcam.exe / nosplash / record<br>其他小错误已得到修复。</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://ghboke.ctfile.com/dir/7369060-23599787-7e8657/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-23599787-7e8657/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Bandicam，游戏录制神器，视频录制利器，高清频录制专家，号称世界三大视频录制神器之一！Bandica
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="系统增强" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%BC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Bandizip(跨平台解压缩软件) v7.09 企业激活版</title>
    <link href="https://wuhongbin.github.io/2020/07/04/Bandizip(%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%A7%A3%E5%8E%8B%E7%BC%A9%E8%BD%AF%E4%BB%B6)%20v7.09%20%E4%BC%81%E4%B8%9A%E6%BF%80%E6%B4%BB%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/04/Bandizip(%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%A7%A3%E5%8E%8B%E7%BC%A9%E8%BD%AF%E4%BB%B6)%20v7.09%20%E4%BC%81%E4%B8%9A%E6%BF%80%E6%B4%BB%E7%89%88/</id>
    <published>2020-07-04T03:01:43.000Z</published>
    <updated>2020-07-16T06:04:13.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        虽然 7-Zip 是开源免费压缩工具中的佼佼者，但用得不是很顺手，今天试了下推荐的 Bandizip 却出人意料的好用！Bandizip 是一款来自韩国的免费优秀的文件压缩/解压缩软件，支持 Win 与 Mac，操作方式与 WinRAR 相似，支持压缩和解压 rar、zip、7z 等众多主流格式…</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li>支持操作系统: Windows Vista/7/8/10 (x86/x64/ARM64)</li><li>许可类型：免费软件(EULA)</li><li>全能的压缩/解压/浏览/编辑软件</li><li>可提取30多种格式，包括RAR/RAR5/7Z/ZIP等</li><li>包含密码压缩和分卷压缩功能</li><li>支持多核高速压缩</li></ul><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><ul><li>支持的格式: ZIP, 7Z(lzma2), ZIPX(xz), EXE(sfx), TAR, TGZ, LZH(lh7), ISO(joliet), GZ, XZ</li><li>ZIP文件修改（添加/删除/重命名）</li><li>支持多核并行，压缩速度可提升至多达6倍</li><li>加密压缩</li><li>支持AES256加密算法</li><li>支持4GB 以上大小的文件压缩</li><li>对ZIP格式支持Unicode或MBCS文件名</li><li>对ZIP/7z格式可进行分卷压缩</li></ul><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><ul><li>支持的格式: 7Z, ACE, AES, ALZ, ARJ, BH, BIN, BZ, BZ2, CAB, Compound(MSI), EGG, GZ,  IMG, ISO, ISZ, LHA, LZ, LZH, LZMA, PMA, RAR, RAR5, SFX(EXE), TAR, TBZ,  TBZ2, TGZ, TLZ, TXZ, UDF, WIM, XPI, XZ, Z, ZIP, ZIPX, ZPAQ</li><li>轻松查看压缩包内文件</li><li>可只解压选定文件，支持拖拽解压</li><li>可对ZIP和RAR格式添加注释</li><li>一步解压TGZ/TBZ格式的文件</li></ul><h2 id="功能多样"><a href="#功能多样" class="headerlink" title="功能多样"></a>功能多样</h2><ul><li>测试文件完整性以确定压缩包是否损坏</li><li>支持修改代码页改</li><li>可集成至资源管理器右键菜单</li></ul><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBIaFJ.md.png" alt=""></p><h1 id="破解教程"><a href="#破解教程" class="headerlink" title="破解教程"></a>破解教程</h1><p>7系列版本，安装后，下载破解补丁，破解后，使用激活码如下激活码</p><p>20380808-ENT000002-0E34A52561-166371E0</p><p>20380808-PRO0BFAEBFDAE23C425E-173E2DF1</p><p>邮箱地址：可任意填写，即随意填个假冒邮箱格式</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><strong>官网下载：</strong></p><p>系列版本：【原生无广告】</p><p>安装版：<a href="https://dl.bandisoft.com/bandizip/BANDIZIP-SETUP.EXE" target="_blank" rel="noopener">https://dl.bandisoft.com/bandizip/BANDIZIP-SETUP.EXE</a></p><p>32位便携版：<a href="https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-32BIT.ZIP" target="_blank" rel="noopener">https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-32BIT.ZIP</a></p><p>64位便携版：<a href="https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-64BIT.ZIP" target="_blank" rel="noopener">https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-64BIT.ZIP</a></p><p>7系列版本：</p><p>安装版：<a href="http://dl.bandisoft.com/bandizip.std/BANDIZIP-SETUP-STD-ALL.EXE" target="_blank" rel="noopener">http://dl.bandisoft.com/bandizip.std/BANDIZIP-SETUP-STD-ALL.EXE</a></p><p><strong>破解版下载：</strong></p><p><a href="https://ghpym.lanzous.com/b00zdekyh" target="_blank" rel="noopener">https://ghpym.lanzous.com/b00zdekyh</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        虽然 7-Zip 是开源免费压缩工具中的佼佼者，但用得不是很顺手，今天试了下推荐的 Bandizip 却出
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="系统增强" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%BC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Typora 最好的Markdown编辑器</title>
    <link href="https://wuhongbin.github.io/2020/07/03/Typora%20Markdown%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>https://wuhongbin.github.io/2020/07/03/Typora%20Markdown%E7%BC%96%E8%BE%91%E5%99%A8/</id>
    <published>2020-07-03T09:01:43.000Z</published>
    <updated>2020-07-16T05:46:53.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBhSaj.md.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBfvqg.md.png" alt="typora-img"></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBfzZQ.md.jpg" alt="img"></p><h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><p>0.9.92</p><p>1.导出PDF时无法加载修复主题。<br>2.修复以一体式样式导出PDF / HTML的问题。<br>3.修复编辑大型数学块时不必要的滚动。</p><p>1.导出PDF时无法加载修复主题。</p><p>0.9.90<br>上线中国镜像：<a href="https://gitee.com/typora-mirror/Typora-Mirror/" target="_blank" rel="noopener">https://gitee.com/typora-mirror/Typora-Mirror/</a></p><p>1.添加ABAP代码语法突出显示。</p><p>2.支持<code>id</code>属性作为链接锚。</p><p>3.升级mermaidjs版本，支持链接样式，实体关系图等。</p><p>4.添加土耳其语支持。</p><p>5.对内置主题的小改进。</p><p>6.在“首选项”面板中添加自定义快捷方式条目。</p><p>7.修复韩文的全局搜索。</p><p>8.解决有关复制/粘贴图像的问题。</p><p>9.解决了打印不会弹出选项对话框的问题。</p><p>10.其他修复错误和改进。</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p>官网下载：<a href="https://www.typora.io" target="_blank" rel="noopener">https://www.typora.io</a></p><p>蓝奏云：<a href="https://ghpym.lanzous.com/b00zng7gd" target="_blank" rel="noopener">https://ghpym.lanzous.com/b00zng7gd</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="办公开发" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E5%8A%9E%E5%85%AC%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Office 2016 2020.6.12 绿色精简版/安装版</title>
    <link href="https://wuhongbin.github.io/2020/07/03/Office%202016%202020.6.12%20%E7%BB%BF%E8%89%B2%E7%B2%BE%E7%AE%80%E7%89%88%E5%AE%89%E8%A3%85%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/03/Office%202016%202020.6.12%20%E7%BB%BF%E8%89%B2%E7%B2%BE%E7%AE%80%E7%89%88%E5%AE%89%E8%A3%85%E7%89%88/</id>
    <published>2020-07-03T08:01:43.000Z</published>
    <updated>2020-07-16T05:34:47.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Office 2016 For Windows 四合一Office 2016是微软的一个庞大的办公软件集合，其中包括了Word、Excel、PowerPoint、Access等组件和服务。</p><p>Office2016支持Windows 7、Windows 8和Windows 10 PC、笔记本和平板电脑。用户必须首先卸载Office 2013。两个版本无法同时安装。本站提供Office2016四合一激活破解版下载。</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>采用32位版本制作，关键更新及安全更新至2020年5月，其它改进；</p><p>保留Word、Excel、Ppt、Access 四大组件 (含VBA)，其它全部删除；</p><p>支持打开PDF文档、支持联机模板、支持规划求解、分析等Excel加载项;</p><p>1、自选三合一或四合一安装（access默认取消）<br>2、增加英文语法检查（中文语法检查功能太大没添加!）<br>3、增加 wps 文件关联（不需要可删除data\wps.dat）<br>3、注册表补充些优化项<br>4、已集成到最新2020.5月最新补丁<br>5、重点：鉴于巨硬最新补丁限制XP使用，针对XP新和谐</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2018/03/Office4in1.jpg" alt=""></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://ghboke.ctfile.com/dir/7369060-27575577-1b4639/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-27575577-1b4639/</a></p><p>链接：<a href="https://pan.baidu.com/s/1rLM0aJR8fv4KPBc8lrMYuA" target="_blank" rel="noopener">https://pan.baidu.com/s/1rLM0aJR8fv4KPBc8lrMYuA</a> 提取码：hv2d</p><p><strong>温馨提示：</strong>任选一链接下载即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Office 2016 For Windows 四合一Office 2016是微软的一个庞大的办公软件集合
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="办公开发" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E5%8A%9E%E5%85%AC%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Total Uninstall 6.27.0.565 便携破解版</title>
    <link href="https://wuhongbin.github.io/2020/07/02/Total%20Uninstall%206.27.0.565%20%E4%BE%BF%E6%90%BA%E7%A0%B4%E8%A7%A3%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/02/Total%20Uninstall%206.27.0.565%20%E4%BE%BF%E6%90%BA%E7%A0%B4%E8%A7%A3%E7%89%88/</id>
    <published>2020-07-02T08:01:43.000Z</published>
    <updated>2020-07-16T05:33:24.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Total Uninstall Pro[完全卸载专业版] 官方中文注册版被成为最受欢迎的卸载程序,能帮你监视软件安装的所有过程，记录下它对系统所做的任何改变，比如：添加的文件、对注 册表和系统文件的修改，并制作成安装前和安装后的快照。卸载软件时，不需要使用卸载程序，直接通过该软件便可将其完全地清除出系统，不留下任何痕迹。从而 保证了系统的清洁。</p><p>Total Uninstall(完全卸载)可以监控软件安装过程，或分析系统中已安装的软件。它可以找出特定软件在系统中留下的每一处痕迹，进行完全的卸载。 Total Uninstall 6 采用了全新的UI设计，包含了原生64bit支持、界面优化、内存使用率下降、程序分析速度比原来版本快5倍等让人惊喜的改进！</p><p>Total Uninstall 的“监控软件安装”功能，可以记录特定时间段特定软件对系统做出的更改，对于便携软件的制作，Total Uninstall 是不可缺少的利器。</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>@果核剥壳 便携制作</p><p>支持win32/64位 破解授权，精简不必要的文件</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UByxhT.md.png" alt=""></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://ghboke.ctfile.com/dir/7369060-27314375-a73ca4/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-27314375-a73ca4/</a></p><p>链接: <a href="https://pan.baidu.com/s/1qZ76xdy" target="_blank" rel="noopener">https://pan.baidu.com/s/1qZ76xdy</a> 密码: rfwf</p><p><strong>温馨提示：</strong>任选一链接下载即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Total Uninstall Pro[完全卸载专业版] 官方中文注册版被成为最受欢迎的卸载程序,能帮你监
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="系统增强" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%BC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Stardock Fences 3.0.9.11 破解版</title>
    <link href="https://wuhongbin.github.io/2020/07/02/Stardock%20Fences%203.0.9.11%20%E7%A0%B4%E8%A7%A3%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/02/Stardock%20Fences%203.0.9.11%20%E7%A0%B4%E8%A7%A3%E7%89%88/</id>
    <published>2020-07-02T07:01:43.000Z</published>
    <updated>2020-07-16T05:34:00.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Stardock Fences 是著名的 Stardock 公司新推出的一款软件，用来分类和组织桌面上的图标。它可以将不同的图标放到不同的半透明“容器”当中，你还可以移动和拉伸这个“容器”。这样将图标分类以后，你的桌面再也不会看起来一团糟了。此外，Fences还提供了一个有趣的功能：双击桌面，隐藏所有图标；再次双击桌面，显示所有图标。</p><h1 id="软件特色"><a href="#软件特色" class="headerlink" title="软件特色"></a>软件特色</h1><p>在高DPI的现代显示器上使用围栏。<br>创建阴影区域以整理桌面。<br>在Windows 10上模糊栅栏后面的壁纸。<br>将围栏卷起来到标题栏，以获得更清洁的桌面。<br>双击桌面以隐藏或显示图标。<br>定义规则以组织桌面图标。<br>在多页围栏之间滑动。<br>从任何文件夹创建一个桌面门户。<br>从围栏内浏览文件夹结构。<br>兼容Windows 10</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><a href="https://img.lguohe.com/uploads/2020/02/20200227212528.jpg" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBsQRe.md.png" alt="img"></a></p><h2 id="破解教程"><a href="#破解教程" class="headerlink" title="破解教程"></a>破解教程</h2><p>本文件是一个exe自解压文件，运行后自动解压，得到安装包和破解补丁。</p><p>安装完成后提示注册或者试用，直接关闭，把补丁复制到软件目录，运行点击破解，然后重启电脑即可。</p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="http://ct.ghpym.com/dir/7369060-37562879-355e79" target="_blank" rel="noopener">http://ct.ghpym.com/dir/7369060-37562879-355e79</a></p><p>链接：<a href="https://pan.baidu.com/s/1eVg3YbrwScRMEpGLP3AfVg" target="_blank" rel="noopener">https://pan.baidu.com/s/1eVg3YbrwScRMEpGLP3AfVg</a> 提取码：4zpq</p><p><a href="https://www.lanzous.com/b00z9m2ze" target="_blank" rel="noopener">https://www.lanzous.com/b00z9m2ze</a></p><p>温馨提示：任选一个链接点击下载即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Stardock Fences 是著名的 Stardock 公司新推出的一款软件，用来分类和组织桌面上的图
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="系统增强" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%BC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Motrix(全能下载软件)v1.5.15 绿色版</title>
    <link href="https://wuhongbin.github.io/2020/07/02/Motrix(%E5%85%A8%E8%83%BD%E4%B8%8B%E8%BD%BD%E8%BD%AF%E4%BB%B6)v1.5.15%20%E7%BB%BF%E8%89%B2%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/02/Motrix(%E5%85%A8%E8%83%BD%E4%B8%8B%E8%BD%BD%E8%BD%AF%E4%BB%B6)v1.5.15%20%E7%BB%BF%E8%89%B2%E7%89%88/</id>
    <published>2020-07-02T06:01:43.000Z</published>
    <updated>2020-07-16T05:34:10.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Motrix是一款基于electron开发的跨平台下载软件，核心下载服务还是由aria2c支持，是一款精品的下载工具，支持支持下载 HTTP、FTP、BT、磁力链、百度网盘等资源，是一款不可多得的高颜值下载软件。</p><h1 id="软件特色"><a href="#软件特色" class="headerlink" title="软件特色"></a>软件特色</h1><p>简洁明了的图形操作界面</p><p>支持BT和磁力链任务</p><p>支持下载百度云盘资源</p><p>最高支持 10 个任务同时下载</p><p>单任务最高支持 64 线程下载</p><p>模拟用户代理UA</p><p>下载完成后通知</p><p>支持触控栏快捷健(Mac 专享)</p><p>常驻系统托盘，操作更加便捷</p><p>移除任务时可同时删除相关文件</p><p>国际化(可选择简体中文或英文界面)</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBrJ4U.md.png" alt=""></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p>官网下载：<a href="https://motrix.app/zh-CN/" target="_blank" rel="noopener">https://motrix.app/zh-CN/</a></p><p>绿色版：<a href="https://ghboke.ctfile.com/dir/7369060-33488776-d50dcc/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-33488776-d50dcc/</a></p><p><strong>温馨提示：</strong>绿色版为exe自解压包，解压即可使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Motrix是一款基于electron开发的跨平台下载软件，核心下载服务还是由aria2c支持，是一款精品
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="上传下载" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Stardock Groupy 1.32 破解版</title>
    <link href="https://wuhongbin.github.io/2020/07/01/Stardock%20Groupy%201.32%20%E7%A0%B4%E8%A7%A3%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/01/Stardock%20Groupy%201.32%20%E7%A0%B4%E8%A7%A3%E7%89%88/</id>
    <published>2020-07-01T07:01:43.000Z</published>
    <updated>2020-07-16T05:33:32.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Groupy 是著名的 Stardock 公司开发的一款强大的 Windows 软件，它可以帮助您在 Windows  桌面上组织多个应用程序到分组选项卡中！只需要把一个窗口拖到另外一个已经打开的窗口上，窗口就会自动整合到一起，每个窗口都会自动转换为标签页，只需要在标签页点击不同的标签，即可切换程序。</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>@果核剥壳</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBBbo8.md.png" alt=""></p><h1 id="破解教程"><a href="#破解教程" class="headerlink" title="破解教程"></a>破解教程</h1><p>下载安装包，正常安装，安装完成后，软件会自动打开，这个时候直接任务管理结束软件及进程。</p><p>将补丁复制到软件根目录，然后管理员权限执行补丁，执行完毕后，重启电脑，即可自动激活。</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="http://ct.ghpym.com/dir/7369060-36621513-79f1ec" target="_blank" rel="noopener">http://ct.ghpym.com/dir/7369060-36621513-79f1ec</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Groupy 是著名的 Stardock 公司开发的一款强大的 Windows 软件，它可以帮助您在 Wi
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="系统增强" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%BC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>PotPlayer(网络播放器) v1.7.21264 绿色版</title>
    <link href="https://wuhongbin.github.io/2020/07/01/PotPlayer(%E7%BD%91%E7%BB%9C%E6%92%AD%E6%94%BE%E5%99%A8)%20v1.7.21264%20%E7%BB%BF%E8%89%B2%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/01/PotPlayer(%E7%BD%91%E7%BB%9C%E6%92%AD%E6%94%BE%E5%99%A8)%20v1.7.21264%20%E7%BB%BF%E8%89%B2%E7%89%88/</id>
    <published>2020-07-01T04:01:43.000Z</published>
    <updated>2020-07-16T05:34:19.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        PotPlayer 是 KMPlayer 的原制作者姜龙喜先生（韩国）进入 Daum 公司后的新一代网络播放器。PotPlayer 的优势在于强大的内置解码器；而 KMPlayer 的优势在于强大的定制能力和个性化功能。PotPlayer 使用 VC++ 编写， KMPlayer 为 Delphi 编写。PotPlayer 是 Daum 公司的一款网络播放器，有自己的独立著作权，并非由姜龙喜先生原创，目前由 KMPlayer 的原始作者姜龙喜进行后续开发。目前(1428以后版本)的 KMPlayer 由 PandoraTV 团队负责集体开发。应 PandoraTV 的要求，PotPlayer 不会加入在 KMPlayer 中一些受欢迎功能，但作者答应加入一些近似的功能。</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>@闻雷 @果核剥壳</p><p>绿色便携制作</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UB0T5F.md.png" alt=""></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p>新增58个皮肤，需要的请自行下载皮肤包，解压到程序skin目录即可</p><p><a href="https://www.lanzous.com/b00zausmb" target="_blank" rel="noopener">https://www.lanzous.com/b00zausmb</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        PotPlayer 是 KMPlayer 的原制作者姜龙喜先生（韩国）进入 Daum 公司后的新一代网络播
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="影音播放" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E5%BD%B1%E9%9F%B3%E6%92%AD%E6%94%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>图的应用之关键路径 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/10/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/10/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-10T02:15:43.000Z</published>
    <updated>2020-07-30T05:50:23.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><p><strong>AOE网：</strong>在有向带权图中, 以顶点表示事件, 以有向边表示活动, 以边上权值表示完成该活动的开销(如完成活动所需要的时间), 则称这种有向图为用边 表示活动的网络, 简称 <strong>AOE网</strong> 。</p><p><strong>源点：</strong>没有入边的顶点（有且只有一个）</p><p><strong>汇点：</strong>没有出边的顶点（有且只有一个）</p><p><strong>关键路径：</strong>从原点到汇点最大路径长度的路径称为 <strong>关键路径</strong>, 键路径上的活动为 <strong>关键活动</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/anvC1f.png" alt=""></p><h1 id="基本计算"><a href="#基本计算" class="headerlink" title="基本计算"></a>基本计算</h1><blockquote><p><strong>事件Vk的最早发生时间 Ve(k)</strong></p><p>利用事件的入边，取最大值</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/anxsMT.png" alt=""></p><blockquote><p><strong>事件Vk的最迟发生时间 Vl(k)</strong></p><p>利用事件的出边，取最小值</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/aupgeS.png" alt=""></p><blockquote><p><strong>活动ai的最早开始时间e(i)</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/auEvMd.png" alt=""></p><blockquote><p><strong>活动ai的最迟开始时间l(i)</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/auV3z4.png" alt=""></p><blockquote><p><strong>活动ai的差额d(i) = l(i) - e(i)</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/auVbmn.png" alt=""></p><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/auea8O.png" alt=""></p><blockquote><p>当网中关键路径 <strong>不唯一</strong> 时，只有加快的关键活动或关键活动组合包括在 <strong>所有的关键路径</strong> 上才能缩短工期。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本定义&quot;&gt;&lt;a href=&quot;#基本定义&quot; class=&quot;headerlink&quot; title=&quot;基本定义&quot;&gt;&lt;/a&gt;基本定义&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;AOE网：&lt;/strong&gt;在有向带权图中, 以顶点表示事件, 以有向边表示活动, 以边上权值表示完成该活动
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="关键路径" scheme="https://wuhongbin.github.io/tags/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>图的应用之拓扑排序 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/09/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/09/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-09T06:15:43.000Z</published>
    <updated>2020-07-30T05:48:40.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><blockquote><p><strong>有向无环图：</strong>不存在环的有向图, 简称<strong>DAG图</strong>。    </p><p><strong>AOV网：</strong>若用一个DAG图表示一个工程,其顶点表示活动, 用 有向边&lt;vi, vj&gt;表示活动vi先于活动vj进行的传递关系,则将这种DAG称为<strong>顶点表示活动网络</strong>, 记为<strong>AOV网</strong>。 </p></blockquote><p><strong>拓扑排序：</strong>对DAG所有顶点的一种排序, 使若存在一条从顶点A 到顶点B的路径,在排序中B排在A的后面。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeHxTf.png" alt=""></p><h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><ol><li>从DAG图中选择一个没有前驱的顶点并输出</li><li>从图中删除该顶点和所有以它为起点的有向边</li><li>重复1、2 ，直到当前的DAG图为空或当前图中不存在无前驱的顶点为止。后一种情况说明图中 <strong>有环</strong>。</li></ol><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><h2 id="例1-（无环）"><a href="#例1-（无环）" class="headerlink" title="例1 （无环）"></a>例1 （无环）</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeL9Mj.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeLSzQ.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeLCss.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeqzRg.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeLPLn.png" alt=""></p><h2 id="例2（有环）"><a href="#例2（有环）" class="headerlink" title="例2（有环）"></a>例2（有环）</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeOptK.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeO9fO.png" alt=""></p><blockquote><p><strong>算法结束时没有访问所有顶点,则存在以剩下顶点组成的环。</strong></p></blockquote><h2 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeXi5V.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeXPU0.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeXkCT.png" alt=""></p><blockquote><p><strong>拓扑排序的结果不一定唯一。</strong></p></blockquote><h1 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//温馨提示：以下代码只看思路，不必深究细节</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TopologicalSort</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Initstack(S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) <span class="comment">//入度为0</span></span><br><span class="line">            Push(S,i);<span class="comment">//入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录统计输出顶点的个数</span></span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(S))<span class="comment">//空：图中不存在入度为0的节点   非空：进入循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pop(S, i); <span class="comment">//弹出栈顶元素，弹出一入度为0的顶点</span></span><br><span class="line">        <span class="built_in">print</span>[count++] = i;<span class="comment">//保存当前出栈的入度为0的节点下标  </span></span><br><span class="line">        <span class="keyword">for</span>(p=G.Vertices[i].firstarc; p; p=p-&gt;nextarc)<span class="comment">//遍历边表</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[v]))<span class="comment">//若-1后，入度为0，则入栈</span></span><br><span class="line">                Push(S, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; G.vexnum) <span class="comment">//为真说明图中有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//排序失败</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//排序成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度为 <strong>O（|V| + |E|）</strong></p></blockquote><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><blockquote><p>若邻接矩阵为三角矩阵，则存在拓扑排序；反之不一定成立。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/am9Yf1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;有向无环图：&lt;/strong&gt;不存在环的有向图, 简称&lt;strong&gt;DAG图&lt;/
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="拓扑排序" scheme="https://wuhongbin.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>图的应用之最短路径 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/08/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/08/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-08T08:15:43.000Z</published>
    <updated>2020-07-30T05:48:28.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>在网图和非网图中,最短路径的含义是不同的。          ·</p><p><strong>非网图：</strong> 两个顶点之间经过的边数最少的路径为 <strong>最短路径</strong>。</p><p>​    <strong>网图：</strong> 两个顶点之间带权路径长度最短的路径为 <strong>最短路径</strong>。   </p><p>在带权图当中,把从一个顶点v到另个顶点u所经历的边的权值之和称为,路径的 <strong>带权路径长度</strong>。</p><p>我们把路径起始的第一个顶点称为源点, 最后一个顶点称为终点。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aZDH9e.png" alt=""></p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="迪杰斯特拉（Dijkatra）算法"><a href="#迪杰斯特拉（Dijkatra）算法" class="headerlink" title="迪杰斯特拉（Dijkatra）算法"></a>迪杰斯特拉（Dijkatra）算法</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><blockquote><p>Dijkstra <strong>带权图单源最短路径</strong></p></blockquote><h4 id="辅助数组"><a href="#辅助数组" class="headerlink" title="辅助数组"></a>辅助数组</h4><blockquote><p> <strong>s[]:</strong> 标记已经计算完成的顶点。          </p><p>数组中的值全部初始化为0。源点下标的值初始化为1。</p></blockquote><blockquote><p><strong>dist[]:</strong> 记录从源点vo到其他各顶点当前的最短路径长度。</p><p>数组中的值初始化为源点到格个顶点边的权值，即 dist [i] = arcs [0] [i]</p></blockquote><blockquote><p> <strong>path[]:</strong> 记录从最短路径中顶点的前驱顶点,即path[i] 为v到vi最短路径上ⅵ 的前驱顶点。</p><p>数组中的值初始化：</p><p>若源点v0到该顶点vi有一条有向边(无向边), 则令path[i] = 0  否则 path [i] = -1;</p></blockquote><h4 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h4><ol><li>初始化数组，并集合S初始为 {0}；</li><li>从顶点集合V-S中选出Vj，满足dist[j] = Min(dist [i] l Vi ∈ V-S}，Vj就是当前求得的最短路径的终点，并另S U { j }；</li><li>修改此时从V0出发到集合V-S上任一顶点Vk最短路径的长度：若dist[j]+arcs [j] [k] 则令 dist[k]=dist [j] + arcs [j] [k] ;  path[k]=j;</li><li>重复2、3步，操作n-1次，直到S中包含全部顶点；</li></ol><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aZ2sbj.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aZ2rrQ.png" alt=""></p><h3 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化部分</span></span><br><span class="line">    <span class="keyword">int</span> s[G. vexnum];</span><br><span class="line">    <span class="keyword">int</span> path[G.vexnum];</span><br><span class="line">    <span class="keyword">int</span> dist[G.vexnum];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dist[i] = G.edge[v][i];<span class="comment">//将dist[]数组初始化为源点到格个顶点边的权值</span></span><br><span class="line">        s[i] = <span class="number">0</span>;<span class="comment">//将s[]数组全部初始化为0</span></span><br><span class="line">        <span class="keyword">if</span>(G.edge[v][i] &lt; MAX)<span class="comment">//MAX表示∞，如果权值是∞说明不存在边，无前驱节点记为-1 </span></span><br><span class="line">            path[i] = v;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            path[i]=<span class="number">-1</span>;                         </span><br><span class="line">    &#125;</span><br><span class="line">    s[v] = <span class="number">0</span>;    <span class="comment">//顶点v没有记录过, 赋值为0。 例如: s[u] = 1, 表示顶点u已经记录过</span></span><br><span class="line">    path[v] = <span class="number">-1</span>;  <span class="comment">//v是源点，无前驱节点，记作-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//真正实现部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = MAX;<span class="comment">//临时变脸，记录最小权值  </span></span><br><span class="line">        <span class="keyword">int</span> u;<span class="comment">//临时变脸，记录最小权值边另一头的顶点下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; <span class="built_in">min</span>)<span class="comment">//没被记录过过 &amp;&amp; 权值小</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">min</span> = dist[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        s[u] = <span class="number">1</span>;<span class="comment">//表示顶点u已经记录过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//没被记录过过 &amp;&amp; (v-&gt;u + u-&gt;j) &lt; u-&gt;j</span></span><br><span class="line">            <span class="keyword">if</span>(s[j] == <span class="number">0</span> &amp;&amp; dist[u] + G.Edge[u][j]] &lt; dist[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[u] + G.Edge[u][j]];</span><br><span class="line">                path[j] = u;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度为 O(|V2|)</p></blockquote><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><blockquote><p><strong>不适用于含有负权边的图</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aZzkHs.png" alt=""></p><h2 id="弗洛伊德（Floyd）算法"><a href="#弗洛伊德（Floyd）算法" class="headerlink" title="弗洛伊德（Floyd）算法"></a>弗洛伊德（Floyd）算法</h2><h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><blockquote><p>Floyd <strong>各顶点之间的最短路径</strong></p></blockquote><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p>递推产生一个n阶方阵序列A(-1), A(0, A(k, .…, A(n-1)<br>A(k) [i] [j] 顶点vi到Vj的最短路径长度，且该路径经过的顶点编号不大于k</p><h4 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h4><p>初始化：A(-1) [i] [j] = arcs [i] [j]</p><p>地推方法：A(k) [i] [j] = MIn{A(k-1) [i] [j], A(k-1) [i] [k] + A(k-1) [k] [j]}, k = 0, 1, … , n-1</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeuH0I.png" alt=""></p><h3 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeu7nA.png" alt=""></p><h3 id="参考代码实现-1"><a href="#参考代码实现-1" class="headerlink" title="参考代码实现"></a>参考代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span> <span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化部分</span></span><br><span class="line">    <span class="keyword">int</span> A[G.vexnum][G.vexnum];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)    </span><br><span class="line">            A[i][j] = G.Edge[i][j];  </span><br><span class="line">    <span class="comment">//真正实现部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; j &lt; G.vexnum; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum: j++)</span><br><span class="line"><span class="keyword">if</span>(a[i][j] &gt; a[i][k] + A[k][j])</span><br><span class="line">                   a[i][j] = a[i][k] + A[k][j];            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路径&quot;&gt;&lt;a href=&quot;#最短路径&quot; class=&quot;headerlink&quot; title=&quot;最短路径&quot;&gt;&lt;/a&gt;最短路径&lt;/h1&gt;&lt;p&gt;在网图和非网图中,最短路径的含义是不同的。          ·&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非网图：&lt;/strong&gt; 
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="最短路径" scheme="https://wuhongbin.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
      <category term="迪杰斯特拉(Dijkatra)算法" scheme="https://wuhongbin.github.io/tags/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89-Dijkatra-%E7%AE%97%E6%B3%95/"/>
    
      <category term="弗洛伊德(Floyd)算法" scheme="https://wuhongbin.github.io/tags/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7-Floyd-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>图的应用之最小生成树 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/07/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/07/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-07T08:15:43.000Z</published>
    <updated>2020-07-30T05:48:11.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h1><p><strong>定义：</strong> 连通图包含全部顶点的一个极小连通子图</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/apOGU1.png" alt=""></p><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p><strong>定义：</strong> 对于 <strong>带权无向连通图</strong> G = ( V, E ), G的所有生成树当中边的 <strong>权值之和最小</strong> 的生成树为G的 <strong>最小生成树(MST)</strong> 。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/apXPG6.png" alt=""></p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ol><li><p>最小生成树不一定唯一,即最小生成树的树形不一定唯一。当带权无向连通图G的各边权值不等时或G只有结点数减1条边时,MST唯一    </p></li><li><p>最小生成树的权值是唯一的, 且是最小    </p></li><li><p>最小生成树的边数为顶点数减1</p></li></ol><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="Prim-（普里姆）算法"><a href="#Prim-（普里姆）算法" class="headerlink" title="Prim （普里姆）算法"></a>Prim （普里姆）算法</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li><strong>初始化：</strong>向空的结果树 T =（Vt，Et) 中添加图 G =（V, E) 的任一顶点u0，使 Vt = {u0}，Et为空集；</li><li><strong>循环（直到Vt = V)：</strong>从图G中选择满足 { (u, v) | u∈Vt ，v∈ V-Vt }且具有最小权值的边（u，v），并置Vt = Vt U {v} , Et =Et U (u, v) }。</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9ClrV.png" alt=""></p><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9AdH0.png" alt=""></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote><p><strong>辅助数组理解：</strong></p><p>min_weight [n] ：存放相关顶点间边的权值 </p><p><strong>表示最小生成树中已存放的顶点到未存放顶点的最小权值</strong></p><p>例：假设有 v0，v1，v2，v3，v4 这5个顶点</p><p>min_weight [5] = {0, 2, 0, 0, 0} <strong>表示最小生成树中已存放的顶点到顶点v1的最小权值是2</strong></p><p>adjvex [n] ：存放相关顶点的下标    </p><p>例：假设有 v0，v1，v2，v3，v4 这5个顶点</p><p>adjvex [5] = {0, 0, 1, 0, 1} <strong>表示顶点v2和顶点v4 这两个点和顶点v1间都有边</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MST_Prim</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> min_weight[G.vexnum];<span class="comment">//存放相关顶点间边的权值</span></span><br><span class="line">    <span class="keyword">int</span> adjvex[G.vexnum];<span class="comment">//存放相关顶点的下标 </span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//初始化操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min_weight[i] = G.Edge[<span class="number">0</span>][i];<span class="comment">//将邻接矩阵第0行所有权值加入数组</span></span><br><span class="line">        adjvex[i] = <span class="number">0</span>;<span class="comment">//全部初始化为v0下标</span></span><br><span class="line">    &#125;</span><br><span class="line">                   </span><br><span class="line">    <span class="comment">//正式构造最小生成树的过程               </span></span><br><span class="line">    <span class="keyword">int</span> min_arc;<span class="comment">//临时变量，表示当前最小权值</span></span><br><span class="line">    <span class="keyword">int</span> min_vex;<span class="comment">//临时变量，表示当前最小权值边的顶点数组下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; G.vexnum; i++)   <span class="comment">//由于有一个顶点已在最小生成树中，所以只遍历n-1次</span></span><br><span class="line">    &#123;</span><br><span class="line">        min_arc = INT_MAX;<span class="comment">//初始化最小权值为65535等不可能数值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找出min_weight[]数组中已存的最小权值</span></span><br><span class="line">             <span class="keyword">if</span>(min_weight[j] != <span class="number">0</span> &amp;&amp; min_weight[j] &lt; min_arc)</span><br><span class="line">             &#123;</span><br><span class="line">                 min_arc = min_weight[j];</span><br><span class="line">                 min_vex = j;<span class="comment">//将发现最小权值的下标存入min_vex, 待使用</span></span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        min_weight[min_vex] = <span class="number">0</span>;<span class="comment">//将当前顶点的权值设为0，表示此顶点已完成任务</span></span><br><span class="line">        <span class="comment">//遍历全部顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123; </span><br><span class="line">             <span class="keyword">if</span>(min_weight[j] != <span class="number">0</span> &amp;&amp; G.Edge[min_vex][j] &lt; min_weight[j])</span><br><span class="line">             &#123;</span><br><span class="line">                 min_weight[j] = G.Edge[min_vex][j];</span><br><span class="line">                 adjvex[j] = min_arc;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>结论：</strong></p><p>此算法时间复杂度为 O(V2)，适用于<strong>稠密图</strong></p></blockquote><h2 id="Kruskal（克鲁斯卡尔）算法"><a href="#Kruskal（克鲁斯卡尔）算法" class="headerlink" title="Kruskal（克鲁斯卡尔）算法"></a>Kruskal（克鲁斯卡尔）算法</h2><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li><strong>初始化：</strong>Vt = V，Et = 空集。即是每个顶点构成一棵独立的树，T是一个仅含V个顶点的森林；</li><li><strong>循环（直到T为树）：</strong>按图G的边的权值递增的顺序依次从 E-Et 中选择一条边，若这条边加入后不构成回路，则将其加入E，否则舍弃。</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9WD8s.png" alt=""></p><h3 id="并查集（必看）"><a href="#并查集（必看）" class="headerlink" title="并查集（必看）"></a>并查集（必看）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9jQIA.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9jMad.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9j1PI.png" alt=""></p><h3 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9OeW6.png" alt=""></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;<span class="comment">//两个端点下标</span></span><br><span class="line">    <span class="keyword">int</span> weight;     <span class="comment">//权值</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MST_Kruskal</span><span class="params">(Graph G, Edge* edges, <span class="keyword">int</span>* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heap_sort(edges);<span class="comment">//堆排序</span></span><br><span class="line">    Initial(parent);<span class="comment">//全部初始化为 -1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.arcnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a_root = Find(parent, edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b_root = Find(parent, edges[il.b);</span><br><span class="line">        <span class="keyword">if</span>(a_root != b_root)</span><br><span class="line">        Union(parent, a_root, b_root);<span class="comment">//合并</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>结论：</strong></p><p>此算法时间复杂度为 O(|E|log|E|)，适用于<strong>稀疏图</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;生成树&quot;&gt;&lt;a href=&quot;#生成树&quot; class=&quot;headerlink&quot; title=&quot;生成树&quot;&gt;&lt;/a&gt;生成树&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; 连通图包含全部顶点的一个极小连通子图&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;/img/loa
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="最小生成树" scheme="https://wuhongbin.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="并查集" scheme="https://wuhongbin.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="Prim(普里姆)算法" scheme="https://wuhongbin.github.io/tags/Prim-%E6%99%AE%E9%87%8C%E5%A7%86-%E7%AE%97%E6%B3%95/"/>
    
      <category term="Kruskal(克鲁斯卡尔)算法" scheme="https://wuhongbin.github.io/tags/Kruskal-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>图的遍历之深度优先搜索(DFS) 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/06/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/06/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-06T08:15:43.000Z</published>
    <updated>2020-07-30T05:47:09.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深度度优先搜索"><a href="#深度度优先搜索" class="headerlink" title="深度度优先搜索"></a>深度度优先搜索</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>深度优先搜索(DepthFirstSearch)</strong>,也有称为深度优先遍历,简称为 <strong>DFS</strong>。  </p><blockquote><p>​        还是拿找钥匙例子来说,  无论从哪一间房间开始都可以,将间内的墙角  、床头柜、床上、床下、衣柜、电视柜等挨个寻  找,做到不放过任何一个死角,当所有的抽屉、  储藏柜中全部都找遍,接着再寻找下一个房间。</p></blockquote><h3 id="具体实现思路"><a href="#具体实现思路" class="headerlink" title="具体实现思路"></a>具体实现思路</h3><ol><li><p>首先访问起始顶点v;  </p></li><li><p>接着由v出发访问v的任意一个 <strong>邻接且未被访问</strong> 的邻接顶点Wi  </p></li><li><p>然后再访问与Wi <strong>邻接且未被访问</strong> 的任意顶点 yi;  </p></li><li><p>若w没有邻接且未被访问的顶点时, 退回到它的上一层顶点v;  </p></li><li><p>重复上述过程,直到所有顶点被访问为止。</p></li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/Uz7eqP.png" alt=""></p><blockquote><p><strong>由此看出，深度优先搜索与树的先序遍历类似</strong></p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/Uz7sMR.png" alt=""></p><blockquote><p>小提示：遵循右手原则遍历，蓝色线为走的线</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/Uz7ys1.png" alt=""></p><h3 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/UzbBuR.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_TREE_SIZE]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        visited[i] = FALSE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            DFS(G, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(Graph G, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    <span class="keyword">for</span>(w = FirstNeighbor(G, v); w &gt;= <span class="number">0</span>; w = NextNeighbor(G, v, w))</span><br><span class="line">    <span class="keyword">if</span>(!visited[i])        i</span><br><span class="line">            DFS(G, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>此篇博客仅为本人根据个人理解复习总结所写，如有错误之处，请在下方评论或者联系我，我会第一时间改正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深度度优先搜索&quot;&gt;&lt;a href=&quot;#深度度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;深度度优先搜索&quot;&gt;&lt;/a&gt;深度度优先搜索&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="深度度优先搜索" scheme="https://wuhongbin.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>图的遍历之广度优先搜索(BFS) 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/05/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/05/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-05T06:15:43.000Z</published>
    <updated>2020-07-30T04:07:03.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>从图中某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。</p><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>广度优先搜索（BreadthFirstSearch)</strong>，又称为广度优先遍历，简称 <strong>BFS</strong>。</p><blockquote><p>​        如果以之前我们找钥匙的例子来讲，运用深度优先遍历意味着要先彻底查找完一个房间再开始另一个房间但我们知道，钥匙放在沙发地下等特角奇兄的可能性极低，因此我们运用新的方亲：先看看钥匙是否放在各个房间的显服位置，如果没有，再看看各个房间的抽屉有没有。这样逐步扩大查找的范围的方式我们称为 <strong>广度优先搜索</strong> 。</p></blockquote><h3 id="具体实现思路"><a href="#具体实现思路" class="headerlink" title="具体实现思路"></a>具体实现思路</h3><ol><li>首先访问起始顶点v；</li><li>接着由出发依次访问v的各个 <strong>未被访问过</strong> 的邻接顶点W1, W2….Wi；</li><li>然后依次访问W1, W2…,Wi 的所有 <strong>未被访问过</strong> 的邻接顶点；</li><li>在从这些访问过的顶点出发，访问它们所有 <strong>未被访问过的</strong> 邻接顶点.</li><li>….以此类推；</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvUKr8.png" alt=""></p><blockquote><p><strong>由此看出，广度优先搜索与树的层次遍历类似</strong></p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/UzeahF.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/UzeUtU.png" alt=""></p><h3 id="参考代码实现-邻接矩阵"><a href="#参考代码实现-邻接矩阵" class="headerlink" title="参考代码实现 (邻接矩阵)"></a>参考代码实现 (邻接矩阵)</h3><blockquote><p><strong>温馨提示：请结合本博客另一博文《图的存储结构之邻接矩阵 详细总结》参考学习</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵的广度优先搜索</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_TRUE_SIZE];<span class="comment">//辅助标记数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Mgraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; G.vexnum; i++)<span class="comment">//将辅助标记数组全部初始化为FALSE, G.vexnum表示顶点数</span></span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    initQueue( &amp;Q);<span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c  "</span>, G.vex[i]);<span class="comment">//访问顶点</span></span><br><span class="line">            visited[i] = TRUE;</span><br><span class="line">            EnQueue(&amp;Q, i);</span><br><span class="line">            <span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                DeQueue(&amp;Q, i);</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(G.art[i][j]) == <span class="number">1</span> &amp;&amp; !visited[j])<span class="comment">//等于1 且 未被访问</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%c  "</span>, G.vex[i]);<span class="comment">//访问顶点</span></span><br><span class="line">                        visited[j] = TRUE;</span><br><span class="line">            EnQueue(&amp;Q, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考代码实现-邻接表"><a href="#参考代码实现-邻接表" class="headerlink" title="参考代码实现 (邻接表)"></a>参考代码实现 (邻接表)</h3><blockquote><p><strong>温馨提示：请结合本博客另一博文《图的存储结构之邻接表 详细总结》参考学习</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表的广度优先搜索</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_TRUE_SIZE];<span class="comment">//辅助标记数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Mgraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; G.vexnum; i++)<span class="comment">//将辅助标记数组全部初始化为FALSE, G.vexnum表示顶点数</span></span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    initQueue( &amp;Q);<span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c  "</span>, G.vetices[i].data);<span class="comment">//访问顶点</span></span><br><span class="line">            visited[i] = TRUE;</span><br><span class="line">            EnQueue(&amp;Q, i);</span><br><span class="line">            <span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                DeQueue(&amp;Q, i);</span><br><span class="line">                ArcNode P = G.AdjList[i].first;</span><br><span class="line">                <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; !visited[i])<span class="comment">// 单链表指针为非NULL 且 未被访问</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c  "</span>, G.vetices[p.adjvex].data);<span class="comment">//访问顶点</span></span><br><span class="line">                    visited[j] = TRUE;</span><br><span class="line">                    EnQueue(&amp;Q, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>此篇博客仅为本人根据个人理解复习总结所写，如有错误之处，请在下方评论或者联系我，我会第一时间改正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图的遍历&quot;&gt;&lt;a href=&quot;#图的遍历&quot; class=&quot;headerlink&quot; title=&quot;图的遍历&quot;&gt;&lt;/a&gt;图的遍历&lt;/h2&gt;&lt;p&gt;从图中某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。&lt;/p&gt;
&lt;h2 id=&quot;广度优先搜索
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="广度优先搜索" scheme="https://wuhongbin.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>图的基本操作 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/04/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/04/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-04T03:15:43.000Z</published>
    <updated>2020-07-30T05:46:54.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作一-判断边存在"><a href="#操作一-判断边存在" class="headerlink" title="操作一 判断边存在"></a>操作一 判断边存在</h2><blockquote><p><strong>Adjacent(G, x, y) 判断图G是否存在边 &lt;x, y&gt; 或 (x, y)</strong></p></blockquote><h3 id="实例（无向图）"><a href="#实例（无向图）" class="headerlink" title="实例（无向图）"></a>实例（无向图）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UveNTO.png" alt=""></p><h3 id="实例（有向图）"><a href="#实例（有向图）" class="headerlink" title="实例（有向图）"></a>实例（有向图）</h3><p><strong><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvmT8H.png" alt=""></strong></p><h2 id="操作二-找邻边"><a href="#操作二-找邻边" class="headerlink" title="操作二 找邻边"></a>操作二 找邻边</h2><blockquote><p><strong>Neighbors(G, x) 列出图G中与结点x邻接的边</strong></p></blockquote><h3 id="实例（无向图）-1"><a href="#实例（无向图）-1" class="headerlink" title="实例（无向图）"></a>实例（无向图）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uvnhyn.png" alt=""></p><h3 id="实例（有向图）-1"><a href="#实例（有向图）-1" class="headerlink" title="实例（有向图）"></a>实例（有向图）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uvn4Lq.png" alt=""></p><h2 id="操作三-插入顶点"><a href="#操作三-插入顶点" class="headerlink" title="操作三 插入顶点"></a>操作三 插入顶点</h2><blockquote><p><strong>InsertVertex(G,x) 在图G中插入顶点x</strong></p></blockquote><h3 id="插入顶点F前"><a href="#插入顶点F前" class="headerlink" title="插入顶点F前"></a>插入顶点F前</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvKlE6.png" alt=""></p><h3 id="插入顶点F后"><a href="#插入顶点F后" class="headerlink" title="插入顶点F后"></a>插入顶点F后</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvK1UK.png" alt=""></p><h2 id="操作四-删除顶点"><a href="#操作四-删除顶点" class="headerlink" title="操作四 删除顶点"></a>操作四 删除顶点</h2><blockquote><p><strong>DeleteVertex(G, x) 从图G中删除顶点x</strong></p></blockquote><h3 id="删除顶点A前"><a href="#删除顶点A前" class="headerlink" title="删除顶点A前"></a>删除顶点A前</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvQE6J.png" alt=""></p><h3 id="删除顶点A后"><a href="#删除顶点A后" class="headerlink" title="删除顶点A后"></a>删除顶点A后</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvQAl4.png" alt=""></p><h2 id="操作五-添加边"><a href="#操作五-添加边" class="headerlink" title="操作五 添加边"></a>操作五 添加边</h2><blockquote><p><strong>AddEdge(G, x, y) 若无向边(x,y) 或者 有向边&lt;x, y&gt;不存在,则向图中添加该边</strong></p></blockquote><h3 id="添加边AD前"><a href="#添加边AD前" class="headerlink" title="添加边AD前"></a>添加边AD前</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvlGCT.png" alt=""></p><h3 id="添加边AD后"><a href="#添加边AD后" class="headerlink" title="添加边AD后"></a>添加边AD后</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uvl35V.png" alt=""></p><h2 id="操作六-删除边"><a href="#操作六-删除边" class="headerlink" title="操作六 删除边"></a>操作六 删除边</h2><blockquote><p><strong>RemoveEdge(G, x, y)若 无向边(x, y) 或者 有向边&lt;x, y&gt;存在,则在图G中删除该边</strong></p></blockquote><h3 id="删除边BC前"><a href="#删除边BC前" class="headerlink" title="删除边BC前"></a>删除边BC前</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uv3gHA.png" alt=""></p><h3 id="删除边BC后"><a href="#删除边BC后" class="headerlink" title="删除边BC后"></a>删除边BC后</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uv3cBd.png" alt=""></p><h2 id="操作七-找顶点的邻接点"><a href="#操作七-找顶点的邻接点" class="headerlink" title="操作七 找顶点的邻接点"></a>操作七 找顶点的邻接点</h2><blockquote><p><strong>FirstNeighbor(G, x) 求图G中顶点X的第一个邻接点，若有则返回顶点号。若没有邻接点或图不存在x，则返回 -1。<br>NextNeighbor(G, x) 假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是的最后一个邻接点，则返回 -1。</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uv862T.png" alt=""></p><h2 id="操作八-网获取或设置权值"><a href="#操作八-网获取或设置权值" class="headerlink" title="操作八 网获取或设置权值"></a>操作八 网获取或设置权值</h2><blockquote><p><strong>Get edge value(G, x, y) 获取图G中边(x, y) 或 &lt;x, y&gt; 对应的权值v。</strong>  </p><p><strong>Set edge value(G, x, y) 设置图G中边(x, y) 或 &lt;x, y&gt; 对应的权值为v。</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvG1L4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;操作一-判断边存在&quot;&gt;&lt;a href=&quot;#操作一-判断边存在&quot; class=&quot;headerlink&quot; title=&quot;操作一 判断边存在&quot;&gt;&lt;/a&gt;操作一 判断边存在&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Adjacent(G, x, y) 判断图
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>图的存储结构之邻接多重表 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/03/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/03/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-03T09:15:50.000Z</published>
    <updated>2020-07-30T05:46:00.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        如果我们在无向图的应用中,关注的重点是顶点的话,那么邻接表是不错的选择,但如果我们更关注的是边的操作,比如对已经访问过的边做标记, 或者删除某一条边等操作,邻接表就显得不那么方便了。</p><h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><p><strong>邻接多重表：</strong> 无向图的一种存储结构</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/UOkyiq.png" alt=""></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/UOk6J0.png" alt=""></p><h2 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边表结点</span></span><br><span class="line">    <span class="keyword">int</span> ivex,jvex; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">ilink</span>, *<span class="title">jlink</span>;</span></span><br><span class="line">    <span class="comment">//Inforype info;</span></span><br><span class="line">    <span class="comment">//bool mark;</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span><span class="comment">//顶点结点</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode *firstedge;</span><br><span class="line">&#125;VNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//邻接多重表</span></span><br><span class="line">    VNode adjmulist[MaxVertexNum];</span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;AMLGraph；</span><br></pre></td></tr></table></figure><h2 id="十字链表-VS-邻接多重表"><a href="#十字链表-VS-邻接多重表" class="headerlink" title="十字链表 VS 邻接多重表"></a>十字链表 VS 邻接多重表</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/UOVeGq.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​        如果我们在无向图的应用中,关注的重点是顶点的话,那么邻接表是不错的选择,但如果我们更关注的是边的操作,比如对已经访问过的边
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="图" scheme="https://wuhongbin.github.io/tags/%E5%9B%BE/"/>
    
      <category term="邻接多重表" scheme="https://wuhongbin.github.io/tags/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8/"/>
    
  </entry>
  
</feed>
