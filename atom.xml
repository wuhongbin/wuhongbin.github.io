<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>时光如水の总是无言</title>
  
  <subtitle>wuhongbin&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuhongbin.github.io/"/>
  <updated>2020-07-16T10:27:19.800Z</updated>
  <id>https://wuhongbin.github.io/</id>
  
  <author>
    <name>时光如水の总是无言</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GeoGebra(数学软件)v6.0.591.0 多平台版</title>
    <link href="https://wuhongbin.github.io/2020/07/06/GeoGebra(%E6%95%B0%E5%AD%A6%E8%BD%AF%E4%BB%B6)v6.0.591.0%20%E5%A4%9A%E5%B9%B3%E5%8F%B0%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/06/GeoGebra(%E6%95%B0%E5%AD%A6%E8%BD%AF%E4%BB%B6)v6.0.591.0%20%E5%A4%9A%E5%B9%B3%E5%8F%B0%E7%89%88/</id>
    <published>2020-07-06T03:01:43.000Z</published>
    <updated>2020-07-16T10:27:19.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>本软件是一款跨平台的动态数学教学与绘制软件，功能非常强大，并且是免费的，难能可贵！</p><p>GeoGebra 是一个结合「几何」、「代数」与「微积分」的动态数学软件，它是由美国佛罗里达州亚特兰大学的数学教授Markus Hohenwarter所设计的。 一方面来说，GeoGebra 是一个动态的几何软件。您可以在上面画点、向量、线段、直线、多边形、圆锥曲线，甚至是函数，事后你还可以改变它们的属性。<br>另一方面来说，您也可以直接输入方程和点坐标。所以，GeoGebra 也有处理变数的能力（这些变数可以是一个数字、角度、向量或点坐标），它也可以对函数作微分与积分，找出方程的根或计算函数的极大极小值。<br>所以 GeoGebra 同时具有处理代数与几何的功能，因此 GeoGebra 视窗左边有一个「代数区」，右边有一个「几何区」（也称为「绘图区」），就像下图一样。</p><h3 id="软件特色"><a href="#软件特色" class="headerlink" title="软件特色"></a>软件特色</h3><p>* 可免费用于学习、教学和考评。<br>* 功能强大、使用简单、交互性强。<br>* 支持多种语言。<br>* 以趣味的方式真正观察和体验数学和科学。<br>* 可适于各种课程或项目。<br>* 在世界上有数百万人使用。</p><p><a href="https://img.lguohe.com/uploads/2019/05/20190512213739.jpg" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/05/20190512213739.jpg" alt="img"></a> <a href="https://img.lguohe.com/uploads/2019/05/20190512213443.jpg" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/05/20190512213443.jpg" alt="img"></a></p><h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><p>制图：考试和非考试相同<br>改进了符号输入框（包括通过输入“错误”语法无法更改矢量和类型）<br>错误修正：ggbApplet.setFixed（）不再触发OnUpdate脚本<br>RandomElement（{1 / 2,1 / 3,1 / 4}）效果更好<br>Android：修复HTC手机上的键盘关闭问题</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://ghboke.ctfile.com/dir/7369060-34163107-384f41/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-34163107-384f41/</a></p><p>链接：<a href="https://pan.baidu.com/s/19ezbfdpyE4O5z9SwqXrRPw" target="_blank" rel="noopener">https://pan.baidu.com/s/19ezbfdpyE4O5z9SwqXrRPw</a>  提取码：unwp</p><p><a href="https://www.lanzous.com/b00z91y6b" target="_blank" rel="noopener">https://www.lanzous.com/b00z91y6b</a></p><p><strong>温馨提示：</strong>任选一链接下载即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;本软件是一款跨平台的动态数学教学与绘制软件，功能非常强大，并且是免费的，难能可贵！&lt;/p&gt;
&lt;p&gt;GeoGebra 是一个结
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="办公开发" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E5%8A%9E%E5%85%AC%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>深度扫描 – 强大的跨平台OCR软件</title>
    <link href="https://wuhongbin.github.io/2020/07/06/%E6%B7%B1%E5%BA%A6%E6%89%AB%E6%8F%8F%20%E2%80%93%20%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0OCR%E8%BD%AF%E4%BB%B6/"/>
    <id>https://wuhongbin.github.io/2020/07/06/%E6%B7%B1%E5%BA%A6%E6%89%AB%E6%8F%8F%20%E2%80%93%20%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0OCR%E8%BD%AF%E4%BB%B6/</id>
    <published>2020-07-06T01:01:43.000Z</published>
    <updated>2020-07-16T06:19:31.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        极度扫描 PC 端是由成都微致汇网络科技有限公司旗下的微智团队开发的跨平台高精度 ocr 专业软件，可以完成 pdf 的识别，也可以识别 pdf 里面的表格，公式，还可以导出你想要的类型文件，还支持文档编辑，是你高效率办公的利器。</p><p>果核已经使用了，觉得非常棒，并且软件支持Windows、Mac、Android三个平台，就算是免费功能也挺好用，推荐给大家。</p><p>官方提供原生绿色版，下载解压即用，网络OCR识别，准确率非常高。</p><p><a href="https://img.lguohe.com/uploads/2020/05/20200514155700.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2020/05/20200514155700.png" alt="img"></a></p><p><a href="https://img.lguohe.com/uploads/2020/05/20200514155723.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2020/05/20200514155723.png" alt="img"></a></p><p><a href="https://img.lguohe.com/uploads/2020/05/20200514155840.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2020/05/20200514155840.png" alt="img"></a></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p>软件有会员功能，免费功能能使用截图识别，支持表格，公式提取，支持翻译，文档编辑，会员版本支持识别PDF文件。</p><p>官网下载：<a href="https://jidusm.wrste.com/" target="_blank" rel="noopener">https://jidusm.wrste.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        极度扫描 PC 端是由成都微致汇网络科技有限公司旗下的微智团队开发的跨平台高精度 ocr 专业软件，可以完
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="系统增强" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%BC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Snipaste(截图&amp;贴图)v2.4 Beta 绿色版</title>
    <link href="https://wuhongbin.github.io/2020/07/05/Snipaste(%E6%88%AA%E5%9B%BE&amp;%E8%B4%B4%E5%9B%BE)v2.4%20Beta%20%E7%BB%BF%E8%89%B2%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/05/Snipaste(%E6%88%AA%E5%9B%BE&amp;%E8%B4%B4%E5%9B%BE)v2.4%20Beta%20%E7%BB%BF%E8%89%B2%E7%89%88/</id>
    <published>2020-07-05T03:01:43.000Z</published>
    <updated>2020-07-16T06:15:03.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Snipaste 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上！下载并打开 Snipaste，按下 <code>F1</code> 来开始截图，再按 <code>F3</code>，截图就在桌面置顶显示了。就这么简单！</p><p>你还可以将剪贴板里的文字或者颜色信息转化为图片窗口，并且将它们进行缩放、旋转、翻转、设为半透明，甚至让鼠标能穿透它们！如果你是程序员、设计师，或者是大部分工作时间都在电脑前，贴图功能将改变你的工作方式、提升工作效率。</p><p>Snipaste 使用很简单，但同时也有一些较高级的用法可以进一步提升你的工作效率。感兴趣的话，请抽空读一读<a href="https://docs.snipaste.com/#/zh-cn/" target="_blank" rel="noopener">用户手册</a>。</p><p>Snipaste 是免费软件，它也很安全，没有广告、不会扫描你的硬盘、更不会上传用户数据，它只做它应该做的事。</p><p><a href="https://img.lguohe.com/uploads/2019/07/N3QEb3VA.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/07/N3QEb3VA.png" alt="img"></a></p><h2 id="软件特色"><a href="#软件特色" class="headerlink" title="软件特色"></a>软件特色</h2><h3 id="强大的截图"><a href="#强大的截图" class="headerlink" title="强大的截图"></a>强大的截图</h3><p><a href="https://img.lguohe.com/uploads/2019/07/N3038l46.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/07/N3038l46.png" alt="img"></a></p><ul><li>自动检测界面元素区域</li><li>像素级的鼠标移动控制、截图范围控制</li><li>取色器 (试试 <code>F1</code>, <code>C</code>, <code>F3</code>)</li><li><strong>历史记录回放</strong> (<code>,</code>/<code>.</code>)</li><li>支持多屏</li><li>支持高分屏</li></ul><h3 id="把图片作为窗口置顶显示"><a href="#把图片作为窗口置顶显示" class="headerlink" title="把图片作为窗口置顶显示"></a>把图片作为窗口置顶显示</h3><p><a href="https://img.lguohe.com/uploads/2019/07/P9A3LpoY.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/07/P9A3LpoY.png" alt="img"></a></p><ul><li>支持将剪贴板中的以下内容转为图片<ul><li>图像</li><li>纯文本</li><li>HTML 文本</li><li>颜色信息</li><li>图像文件：PNG, JPG, BMP, ICO, <strong>GIF</strong> 等</li></ul></li><li>图片窗口支持的操作<ul><li>缩放 (<code>鼠标滚轮</code> 或者 <code>+</code>/<code>-</code>)<br>对于 GIF 图片则是加速/减速</li><li>旋转 (<code>1</code>/<code>2</code>)<br>对于 GIF 图片则是 上一帧/下一帧</li><li>镜像翻转 (<code>3</code>/<code>4</code>)</li><li>设置透明度 (<code>Ctrl</code> + <code>鼠标滚轮</code> 或者 <code>Ctrl</code>+ <code>+</code>/<code>-</code>)</li><li>鼠标穿透 (<code>X</code>, 取消则按 <code>F4</code>)</li><li>缩略图 (<code>Shift</code> + <code>双击</code>)</li><li>图像标注 (<code>空格键</code>)</li><li>隐藏 (<code>左键双击</code>)</li><li>…</li></ul></li><li>取色 (<code>Alt</code>)</li><li>文件拖放</li><li><strong>贴图分组</strong></li><li><strong>自动备份、恢复</strong></li></ul><h3 id="方便地标注图像"><a href="#方便地标注图像" class="headerlink" title="方便地标注图像"></a>方便地标注图像</h3><p><a href="https://img.lguohe.com/uploads/2019/07/vu1nkxdD.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/07/vu1nkxdD.png" alt="img"></a></p><ul><li>丰富的画图工具<ul><li>矩形</li><li>椭圆</li><li>线条</li><li>箭头</li><li>铅笔</li><li>马克笔</li><li>文字</li></ul></li><li>高级标注工具<ul><li>马赛克</li><li>高斯模糊</li><li>橡皮擦</li></ul></li><li>撤销、重做</li></ul><h3 id="自定义设置"><a href="#自定义设置" class="headerlink" title="自定义设置"></a>自定义设置</h3><p><a href="https://img.lguohe.com/uploads/2019/07/TNqoS229.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/07/TNqoS229.png" alt="img"></a></p><p>主题色、界面字体、通知栏图标等<br>快捷键<br>丰富的功能性选项</p><h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><p>修复无法以管理员权限开机启动<br>修复中文字体描边 #1475<br>[Mac] 修复首选项窗口在深色模式下的样式错误<br>[Mac] 修复菜单栏图标的菜单点击无效的问题 #1467</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://ghboke.ctfile.com/dir/7369060-34701258-d02fe8/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-34701258-d02fe8/</a></p><p>链接：<a href="https://pan.baidu.com/s/14EVfjqFNLfF8WJptxcK0Ug" target="_blank" rel="noopener">https://pan.baidu.com/s/14EVfjqFNLfF8WJptxcK0Ug</a>    提取码：4ngr</p><p><a href="https://www.lanzous.com/b00zdqjod" target="_blank" rel="noopener">https://www.lanzous.com/b00zdqjod</a></p><p><strong>温馨提示：</strong> 任选一链接下载即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Snipaste 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上！下载并打开 Snipaste，
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="系统增强" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%BC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Bandicam v4.6.1.1688 便携特别版</title>
    <link href="https://wuhongbin.github.io/2020/07/05/Bandicam%20v4.6.1.1688%20%E4%BE%BF%E6%90%BA%E7%89%B9%E5%88%AB%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/05/Bandicam%20v4.6.1.1688%20%E4%BE%BF%E6%90%BA%E7%89%B9%E5%88%AB%E7%89%88/</id>
    <published>2020-07-05T02:01:43.000Z</published>
    <updated>2020-07-16T06:10:11.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Bandicam，游戏录制神器，视频录制利器，高清频录制专家，号称世界三大视频录制神器之一！Bandicam是一款由韩国开发的高清游戏及视频录制的电脑工具。它录制的视频文件不仅体积小，而且画质相当清晰，支持H.264预制高清，以较高的压缩率可录制超过分辨率高达2560×1600高画质视频（1080p全高清视频），录制的同时还可以添加个性化 LOGO到视频中，Bandicam支持bmp、png 、jpeg等格式截图。</p><p>专业高清录屏软件Bandicam现已更新至 4.x，4.0版本界面更好看，功能更多</p><p>Bandicam游戏机可以记录程序/ OpenGL和DirectX Fraps（Fraps Alternative，Better thanFraps®）</p><p>您可以在不停机的情况下录制超过24小时（全自动录音功能可以使用）</p><p>您可以将录制的文件上传到YouTube而不进行转换（可以制作720p / 1080p全高清视频）</p><p>录制的文件大小远小于其他软件。</p><p>您可以录制高达3840 x 2160像素分辨率的4K超高清视频</p><p>您将会遇到比其他捕获软件游戏少得多的滞后（使用更低的CPU / GPU / HDD）</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>@果核剥壳</p><p>便携制作</p><p>启动即为破解版，无需屏蔽联网</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><a href="https://img.lguohe.com/uploads/2017/07/Bandicamjt4.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2017/07/Bandicamjt4.png" alt="img"></a></p><h1 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h1><p>andicam现在支持AMD VCE / VCN HEVC编码器。<br>更新了英特尔快速同步视频编码器。<br>改进了HEVC编码器的稳定性。<br>改进了Vulkan挂钩兼容性。<br>错误修复<br>在屏幕录制模式下，橡皮擦功能的撤消/重做无法正常工作。<br>多个命令行参数无法正常工作。<br>例如）bdcam.exe / nosplash / record<br>其他小错误已得到修复。</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://ghboke.ctfile.com/dir/7369060-23599787-7e8657/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-23599787-7e8657/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Bandicam，游戏录制神器，视频录制利器，高清频录制专家，号称世界三大视频录制神器之一！Bandica
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="系统增强" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%BC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Bandizip(跨平台解压缩软件) v7.09 企业激活版</title>
    <link href="https://wuhongbin.github.io/2020/07/04/Bandizip(%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%A7%A3%E5%8E%8B%E7%BC%A9%E8%BD%AF%E4%BB%B6)%20v7.09%20%E4%BC%81%E4%B8%9A%E6%BF%80%E6%B4%BB%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/04/Bandizip(%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%A7%A3%E5%8E%8B%E7%BC%A9%E8%BD%AF%E4%BB%B6)%20v7.09%20%E4%BC%81%E4%B8%9A%E6%BF%80%E6%B4%BB%E7%89%88/</id>
    <published>2020-07-04T03:01:43.000Z</published>
    <updated>2020-07-16T06:04:13.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        虽然 7-Zip 是开源免费压缩工具中的佼佼者，但用得不是很顺手，今天试了下推荐的 Bandizip 却出人意料的好用！Bandizip 是一款来自韩国的免费优秀的文件压缩/解压缩软件，支持 Win 与 Mac，操作方式与 WinRAR 相似，支持压缩和解压 rar、zip、7z 等众多主流格式…</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li>支持操作系统: Windows Vista/7/8/10 (x86/x64/ARM64)</li><li>许可类型：免费软件(EULA)</li><li>全能的压缩/解压/浏览/编辑软件</li><li>可提取30多种格式，包括RAR/RAR5/7Z/ZIP等</li><li>包含密码压缩和分卷压缩功能</li><li>支持多核高速压缩</li></ul><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><ul><li>支持的格式: ZIP, 7Z(lzma2), ZIPX(xz), EXE(sfx), TAR, TGZ, LZH(lh7), ISO(joliet), GZ, XZ</li><li>ZIP文件修改（添加/删除/重命名）</li><li>支持多核并行，压缩速度可提升至多达6倍</li><li>加密压缩</li><li>支持AES256加密算法</li><li>支持4GB 以上大小的文件压缩</li><li>对ZIP格式支持Unicode或MBCS文件名</li><li>对ZIP/7z格式可进行分卷压缩</li></ul><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><ul><li>支持的格式: 7Z, ACE, AES, ALZ, ARJ, BH, BIN, BZ, BZ2, CAB, Compound(MSI), EGG, GZ,  IMG, ISO, ISZ, LHA, LZ, LZH, LZMA, PMA, RAR, RAR5, SFX(EXE), TAR, TBZ,  TBZ2, TGZ, TLZ, TXZ, UDF, WIM, XPI, XZ, Z, ZIP, ZIPX, ZPAQ</li><li>轻松查看压缩包内文件</li><li>可只解压选定文件，支持拖拽解压</li><li>可对ZIP和RAR格式添加注释</li><li>一步解压TGZ/TBZ格式的文件</li></ul><h2 id="功能多样"><a href="#功能多样" class="headerlink" title="功能多样"></a>功能多样</h2><ul><li>测试文件完整性以确定压缩包是否损坏</li><li>支持修改代码页改</li><li>可集成至资源管理器右键菜单</li></ul><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBIaFJ.md.png" alt=""></p><h1 id="破解教程"><a href="#破解教程" class="headerlink" title="破解教程"></a>破解教程</h1><p>7系列版本，安装后，下载破解补丁，破解后，使用激活码如下激活码</p><p>20380808-ENT000002-0E34A52561-166371E0</p><p>20380808-PRO0BFAEBFDAE23C425E-173E2DF1</p><p>邮箱地址：可任意填写，即随意填个假冒邮箱格式</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><strong>官网下载：</strong></p><p>系列版本：【原生无广告】</p><p>安装版：<a href="https://dl.bandisoft.com/bandizip/BANDIZIP-SETUP.EXE" target="_blank" rel="noopener">https://dl.bandisoft.com/bandizip/BANDIZIP-SETUP.EXE</a></p><p>32位便携版：<a href="https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-32BIT.ZIP" target="_blank" rel="noopener">https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-32BIT.ZIP</a></p><p>64位便携版：<a href="https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-64BIT.ZIP" target="_blank" rel="noopener">https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-64BIT.ZIP</a></p><p>7系列版本：</p><p>安装版：<a href="http://dl.bandisoft.com/bandizip.std/BANDIZIP-SETUP-STD-ALL.EXE" target="_blank" rel="noopener">http://dl.bandisoft.com/bandizip.std/BANDIZIP-SETUP-STD-ALL.EXE</a></p><p><strong>破解版下载：</strong></p><p><a href="https://ghpym.lanzous.com/b00zdekyh" target="_blank" rel="noopener">https://ghpym.lanzous.com/b00zdekyh</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        虽然 7-Zip 是开源免费压缩工具中的佼佼者，但用得不是很顺手，今天试了下推荐的 Bandizip 却出
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="系统增强" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%BC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>AnyDesk(远程连接软件)v6.0.5 个人版</title>
    <link href="https://wuhongbin.github.io/2020/07/04/AnyDesk(%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%BD%AF%E4%BB%B6)v6.0.5%20%E4%B8%AA%E4%BA%BA%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/04/AnyDesk(%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%BD%AF%E4%BB%B6)v6.0.5%20%E4%B8%AA%E4%BA%BA%E7%89%88/</id>
    <published>2020-07-04T02:01:43.000Z</published>
    <updated>2020-07-16T05:56:37.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        AnyDesk使您可以从任何地方远程工作。每当您需要访问远程屏幕时，无论是在办公室楼层还是在世界的另一端，您都可以使用AnyDesk。而且AnyDesk无需要太多复制的控制操作，只需要你在某一设备上下载、安装并启动AnyDesk.exe文件即可开始使用。</p><p>1、远程桌面的新视角</p><p>AnyDesk是从底层向上设计是突破性的。其核心是DeskRT，一个新的视频编解码器，是专门为图形用户界面设计。</p><p>2、帧率</p><p>AnyDesk传输通过局域网和许多互联网连接每秒60帧。</p><p>3、延迟</p><p>延迟在尽可能低的水平是工作在远程桌面上的关键。延迟越低，更快的远程PC响应您的输入。</p><p>4、通信</p><p>AnyDesk带宽效率使得它可以流畅的可用带宽为100 KB/秒完成办公任务。</p><p>5、访问</p><p>忘记可靠性低和繁琐的防火墙配置。使用你的个人电脑的任何地方，没有任何麻烦。</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UB5Kv6.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UB5ugx.md.png" alt=""></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p>官网下载：<a href="https://anydesk.com/zhs/" target="_blank" rel="noopener">https://anydesk.com/zhs/</a></p><p><a href="https://ghboke.ctfile.com/dir/7369060-33675277-e5d1c5/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-33675277-e5d1c5/</a></p><p>链接：<a href="https://pan.baidu.com/s/1-yKsxXCS6zr1Ro_sJ2DHzw" target="_blank" rel="noopener">https://pan.baidu.com/s/1-yKsxXCS6zr1Ro_sJ2DHzw</a>   提取码：bcu0</p><p><strong>温馨提示：</strong>任选一链接下载即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        AnyDesk使您可以从任何地方远程工作。每当您需要访问远程屏幕时，无论是在办公室楼层还是在世界的另一端，
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="系统增强" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%BC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Typora 最好的Markdown编辑器</title>
    <link href="https://wuhongbin.github.io/2020/07/03/Typora%20Markdown%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>https://wuhongbin.github.io/2020/07/03/Typora%20Markdown%E7%BC%96%E8%BE%91%E5%99%A8/</id>
    <published>2020-07-03T09:01:43.000Z</published>
    <updated>2020-07-16T05:46:53.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBhSaj.md.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBfvqg.md.png" alt="typora-img"></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBfzZQ.md.jpg" alt="img"></p><h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><p>0.9.92</p><p>1.导出PDF时无法加载修复主题。<br>2.修复以一体式样式导出PDF / HTML的问题。<br>3.修复编辑大型数学块时不必要的滚动。</p><p>1.导出PDF时无法加载修复主题。</p><p>0.9.90<br>上线中国镜像：<a href="https://gitee.com/typora-mirror/Typora-Mirror/" target="_blank" rel="noopener">https://gitee.com/typora-mirror/Typora-Mirror/</a></p><p>1.添加ABAP代码语法突出显示。</p><p>2.支持<code>id</code>属性作为链接锚。</p><p>3.升级mermaidjs版本，支持链接样式，实体关系图等。</p><p>4.添加土耳其语支持。</p><p>5.对内置主题的小改进。</p><p>6.在“首选项”面板中添加自定义快捷方式条目。</p><p>7.修复韩文的全局搜索。</p><p>8.解决有关复制/粘贴图像的问题。</p><p>9.解决了打印不会弹出选项对话框的问题。</p><p>10.其他修复错误和改进。</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p>官网下载：<a href="https://www.typora.io" target="_blank" rel="noopener">https://www.typora.io</a></p><p>蓝奏云：<a href="https://ghpym.lanzous.com/b00zng7gd" target="_blank" rel="noopener">https://ghpym.lanzous.com/b00zng7gd</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="办公开发" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E5%8A%9E%E5%85%AC%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Office 2016 2020.6.12 绿色精简版/安装版</title>
    <link href="https://wuhongbin.github.io/2020/07/03/Office%202016%202020.6.12%20%E7%BB%BF%E8%89%B2%E7%B2%BE%E7%AE%80%E7%89%88%E5%AE%89%E8%A3%85%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/03/Office%202016%202020.6.12%20%E7%BB%BF%E8%89%B2%E7%B2%BE%E7%AE%80%E7%89%88%E5%AE%89%E8%A3%85%E7%89%88/</id>
    <published>2020-07-03T08:01:43.000Z</published>
    <updated>2020-07-16T05:34:47.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Office 2016 For Windows 四合一Office 2016是微软的一个庞大的办公软件集合，其中包括了Word、Excel、PowerPoint、Access等组件和服务。</p><p>Office2016支持Windows 7、Windows 8和Windows 10 PC、笔记本和平板电脑。用户必须首先卸载Office 2013。两个版本无法同时安装。本站提供Office2016四合一激活破解版下载。</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>采用32位版本制作，关键更新及安全更新至2020年5月，其它改进；</p><p>保留Word、Excel、Ppt、Access 四大组件 (含VBA)，其它全部删除；</p><p>支持打开PDF文档、支持联机模板、支持规划求解、分析等Excel加载项;</p><p>1、自选三合一或四合一安装（access默认取消）<br>2、增加英文语法检查（中文语法检查功能太大没添加!）<br>3、增加 wps 文件关联（不需要可删除data\wps.dat）<br>3、注册表补充些优化项<br>4、已集成到最新2020.5月最新补丁<br>5、重点：鉴于巨硬最新补丁限制XP使用，针对XP新和谐</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2018/03/Office4in1.jpg" alt=""></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://ghboke.ctfile.com/dir/7369060-27575577-1b4639/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-27575577-1b4639/</a></p><p>链接：<a href="https://pan.baidu.com/s/1rLM0aJR8fv4KPBc8lrMYuA" target="_blank" rel="noopener">https://pan.baidu.com/s/1rLM0aJR8fv4KPBc8lrMYuA</a> 提取码：hv2d</p><p><strong>温馨提示：</strong>任选一链接下载即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Office 2016 For Windows 四合一Office 2016是微软的一个庞大的办公软件集合
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="办公开发" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E5%8A%9E%E5%85%AC%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Total Uninstall 6.27.0.565 便携破解版</title>
    <link href="https://wuhongbin.github.io/2020/07/02/Total%20Uninstall%206.27.0.565%20%E4%BE%BF%E6%90%BA%E7%A0%B4%E8%A7%A3%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/02/Total%20Uninstall%206.27.0.565%20%E4%BE%BF%E6%90%BA%E7%A0%B4%E8%A7%A3%E7%89%88/</id>
    <published>2020-07-02T08:01:43.000Z</published>
    <updated>2020-07-16T05:33:24.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Total Uninstall Pro[完全卸载专业版] 官方中文注册版被成为最受欢迎的卸载程序,能帮你监视软件安装的所有过程，记录下它对系统所做的任何改变，比如：添加的文件、对注 册表和系统文件的修改，并制作成安装前和安装后的快照。卸载软件时，不需要使用卸载程序，直接通过该软件便可将其完全地清除出系统，不留下任何痕迹。从而 保证了系统的清洁。</p><p>Total Uninstall(完全卸载)可以监控软件安装过程，或分析系统中已安装的软件。它可以找出特定软件在系统中留下的每一处痕迹，进行完全的卸载。 Total Uninstall 6 采用了全新的UI设计，包含了原生64bit支持、界面优化、内存使用率下降、程序分析速度比原来版本快5倍等让人惊喜的改进！</p><p>Total Uninstall 的“监控软件安装”功能，可以记录特定时间段特定软件对系统做出的更改，对于便携软件的制作，Total Uninstall 是不可缺少的利器。</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>@果核剥壳 便携制作</p><p>支持win32/64位 破解授权，精简不必要的文件</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UByxhT.md.png" alt=""></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://ghboke.ctfile.com/dir/7369060-27314375-a73ca4/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-27314375-a73ca4/</a></p><p>链接: <a href="https://pan.baidu.com/s/1qZ76xdy" target="_blank" rel="noopener">https://pan.baidu.com/s/1qZ76xdy</a> 密码: rfwf</p><p><strong>温馨提示：</strong>任选一链接下载即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Total Uninstall Pro[完全卸载专业版] 官方中文注册版被成为最受欢迎的卸载程序,能帮你监
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="系统增强" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%BC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Stardock Fences 3.0.9.11 破解版</title>
    <link href="https://wuhongbin.github.io/2020/07/02/Stardock%20Fences%203.0.9.11%20%E7%A0%B4%E8%A7%A3%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/02/Stardock%20Fences%203.0.9.11%20%E7%A0%B4%E8%A7%A3%E7%89%88/</id>
    <published>2020-07-02T07:01:43.000Z</published>
    <updated>2020-07-16T05:34:00.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Stardock Fences 是著名的 Stardock 公司新推出的一款软件，用来分类和组织桌面上的图标。它可以将不同的图标放到不同的半透明“容器”当中，你还可以移动和拉伸这个“容器”。这样将图标分类以后，你的桌面再也不会看起来一团糟了。此外，Fences还提供了一个有趣的功能：双击桌面，隐藏所有图标；再次双击桌面，显示所有图标。</p><h1 id="软件特色"><a href="#软件特色" class="headerlink" title="软件特色"></a>软件特色</h1><p>在高DPI的现代显示器上使用围栏。<br>创建阴影区域以整理桌面。<br>在Windows 10上模糊栅栏后面的壁纸。<br>将围栏卷起来到标题栏，以获得更清洁的桌面。<br>双击桌面以隐藏或显示图标。<br>定义规则以组织桌面图标。<br>在多页围栏之间滑动。<br>从任何文件夹创建一个桌面门户。<br>从围栏内浏览文件夹结构。<br>兼容Windows 10</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><a href="https://img.lguohe.com/uploads/2020/02/20200227212528.jpg" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBsQRe.md.png" alt="img"></a></p><h2 id="破解教程"><a href="#破解教程" class="headerlink" title="破解教程"></a>破解教程</h2><p>本文件是一个exe自解压文件，运行后自动解压，得到安装包和破解补丁。</p><p>安装完成后提示注册或者试用，直接关闭，把补丁复制到软件目录，运行点击破解，然后重启电脑即可。</p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="http://ct.ghpym.com/dir/7369060-37562879-355e79" target="_blank" rel="noopener">http://ct.ghpym.com/dir/7369060-37562879-355e79</a></p><p>链接：<a href="https://pan.baidu.com/s/1eVg3YbrwScRMEpGLP3AfVg" target="_blank" rel="noopener">https://pan.baidu.com/s/1eVg3YbrwScRMEpGLP3AfVg</a> 提取码：4zpq</p><p><a href="https://www.lanzous.com/b00z9m2ze" target="_blank" rel="noopener">https://www.lanzous.com/b00z9m2ze</a></p><p>温馨提示：任选一个链接点击下载即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Stardock Fences 是著名的 Stardock 公司新推出的一款软件，用来分类和组织桌面上的图
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="系统增强" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%BC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Motrix(全能下载软件)v1.5.15 绿色版</title>
    <link href="https://wuhongbin.github.io/2020/07/02/Motrix(%E5%85%A8%E8%83%BD%E4%B8%8B%E8%BD%BD%E8%BD%AF%E4%BB%B6)v1.5.15%20%E7%BB%BF%E8%89%B2%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/02/Motrix(%E5%85%A8%E8%83%BD%E4%B8%8B%E8%BD%BD%E8%BD%AF%E4%BB%B6)v1.5.15%20%E7%BB%BF%E8%89%B2%E7%89%88/</id>
    <published>2020-07-02T06:01:43.000Z</published>
    <updated>2020-07-16T05:34:10.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Motrix是一款基于electron开发的跨平台下载软件，核心下载服务还是由aria2c支持，是一款精品的下载工具，支持支持下载 HTTP、FTP、BT、磁力链、百度网盘等资源，是一款不可多得的高颜值下载软件。</p><h1 id="软件特色"><a href="#软件特色" class="headerlink" title="软件特色"></a>软件特色</h1><p>简洁明了的图形操作界面</p><p>支持BT和磁力链任务</p><p>支持下载百度云盘资源</p><p>最高支持 10 个任务同时下载</p><p>单任务最高支持 64 线程下载</p><p>模拟用户代理UA</p><p>下载完成后通知</p><p>支持触控栏快捷健(Mac 专享)</p><p>常驻系统托盘，操作更加便捷</p><p>移除任务时可同时删除相关文件</p><p>国际化(可选择简体中文或英文界面)</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBrJ4U.md.png" alt=""></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p>官网下载：<a href="https://motrix.app/zh-CN/" target="_blank" rel="noopener">https://motrix.app/zh-CN/</a></p><p>绿色版：<a href="https://ghboke.ctfile.com/dir/7369060-33488776-d50dcc/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-33488776-d50dcc/</a></p><p><strong>温馨提示：</strong>绿色版为exe自解压包，解压即可使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Motrix是一款基于electron开发的跨平台下载软件，核心下载服务还是由aria2c支持，是一款精品
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="上传下载" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Stardock Groupy 1.32 破解版</title>
    <link href="https://wuhongbin.github.io/2020/07/01/Stardock%20Groupy%201.32%20%E7%A0%B4%E8%A7%A3%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/01/Stardock%20Groupy%201.32%20%E7%A0%B4%E8%A7%A3%E7%89%88/</id>
    <published>2020-07-01T07:01:43.000Z</published>
    <updated>2020-07-16T05:33:32.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Groupy 是著名的 Stardock 公司开发的一款强大的 Windows 软件，它可以帮助您在 Windows  桌面上组织多个应用程序到分组选项卡中！只需要把一个窗口拖到另外一个已经打开的窗口上，窗口就会自动整合到一起，每个窗口都会自动转换为标签页，只需要在标签页点击不同的标签，即可切换程序。</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>@果核剥壳</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBBbo8.md.png" alt=""></p><h1 id="破解教程"><a href="#破解教程" class="headerlink" title="破解教程"></a>破解教程</h1><p>下载安装包，正常安装，安装完成后，软件会自动打开，这个时候直接任务管理结束软件及进程。</p><p>将补丁复制到软件根目录，然后管理员权限执行补丁，执行完毕后，重启电脑，即可自动激活。</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="http://ct.ghpym.com/dir/7369060-36621513-79f1ec" target="_blank" rel="noopener">http://ct.ghpym.com/dir/7369060-36621513-79f1ec</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        Groupy 是著名的 Stardock 公司开发的一款强大的 Windows 软件，它可以帮助您在 Wi
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="系统增强" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%BC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>PotPlayer(网络播放器) v1.7.21264 绿色版</title>
    <link href="https://wuhongbin.github.io/2020/07/01/PotPlayer(%E7%BD%91%E7%BB%9C%E6%92%AD%E6%94%BE%E5%99%A8)%20v1.7.21264%20%E7%BB%BF%E8%89%B2%E7%89%88/"/>
    <id>https://wuhongbin.github.io/2020/07/01/PotPlayer(%E7%BD%91%E7%BB%9C%E6%92%AD%E6%94%BE%E5%99%A8)%20v1.7.21264%20%E7%BB%BF%E8%89%B2%E7%89%88/</id>
    <published>2020-07-01T04:01:43.000Z</published>
    <updated>2020-07-16T05:34:19.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        PotPlayer 是 KMPlayer 的原制作者姜龙喜先生（韩国）进入 Daum 公司后的新一代网络播放器。PotPlayer 的优势在于强大的内置解码器；而 KMPlayer 的优势在于强大的定制能力和个性化功能。PotPlayer 使用 VC++ 编写， KMPlayer 为 Delphi 编写。PotPlayer 是 Daum 公司的一款网络播放器，有自己的独立著作权，并非由姜龙喜先生原创，目前由 KMPlayer 的原始作者姜龙喜进行后续开发。目前(1428以后版本)的 KMPlayer 由 PandoraTV 团队负责集体开发。应 PandoraTV 的要求，PotPlayer 不会加入在 KMPlayer 中一些受欢迎功能，但作者答应加入一些近似的功能。</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>@闻雷 @果核剥壳</p><p>绿色便携制作</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UB0T5F.md.png" alt=""></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p>新增58个皮肤，需要的请自行下载皮肤包，解压到程序skin目录即可</p><p><a href="https://www.lanzous.com/b00zausmb" target="_blank" rel="noopener">https://www.lanzous.com/b00zausmb</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h1&gt;&lt;p&gt;​        PotPlayer 是 KMPlayer 的原制作者姜龙喜先生（韩国）进入 Daum 公司后的新一代网络播
      
    
    </summary>
    
    
      <category term="软件推荐" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
      <category term="影音播放" scheme="https://wuhongbin.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E5%BD%B1%E9%9F%B3%E6%92%AD%E6%94%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>哈夫曼树 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/20/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/20/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-20T04:46:43.000Z</published>
    <updated>2020-06-28T08:37:08.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h2><p>设二叉树具有n个带权值的叶节点，那么从根节点到各个叶节点的路径长度与相应节点权值的乘积的和，叫做二叉树的 <strong><font color=red>带权路径长度</font></strong>。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHXvHe.png" alt=""></p><p> <strong><font color=red>权：</font></strong> 权代表的是叶子结点的数据信息,是具体的值。也就是结点所储存的值</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHjYE4.png" alt=""></p><p>具有最小带权路径长度的二叉树称为 <strong><font color=red>哈夫曼树 (也称最优数)</font></strong> 。</p><p>相同的叶节点构造出不同的二叉树</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHjX2q.md.png" alt=""></p><h2 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h2><p>构造哈夫曼树的 <strong><font color=red>原则：</font></strong></p><p>① 权值越大的叶节点越靠近根节点</p><p>② 权值越小的叶节点越远离根节点</p><p>构造哈夫曼树的 <strong><font color=red>过程：</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHvMIH.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHxoNQ.md.png" alt=""></p><p><strong><font color=red>哈夫曼树的特点：</font></strong> <strong>n1 = 0</strong></p><p><strong>n = n0 + n1 + n2  =  n0 + n2  =  2n0 - 1</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YttzLR.md.png" alt=""></p><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>规定哈夫曼树中的 <strong><font color=red>左分支为0，右分支为1</font></strong> ，则从根节点到每个节点所经过的分支对应的0和1组成的序列便为该节点对应字符的编码。这样的编码称为 <strong><font color=red>哈夫曼编码</font></strong>。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/Ybp961.md.png" alt=""></p><p>在一组字符的哈夫曼编码中，不可能出现一个字符的哈夫曼编码是另一个字符哈夫曼编码的 <strong><font color=red>前缀</font></strong>。</p><p>例如，有4个字符的编码如下：100,  001,  0，1</p><p>这是哈夫曼编码吗？显然是错误的，因为0是001的前缀，不可能。</p><p>所以哈夫曼编码也称为 <strong><font color=red>前缀编码</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/Ybpc9J.md.png" alt=""></p><p>分析：选 <strong>D</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/Ybpb3d.md.png" alt=""></p><p>分析：选 <strong>A</strong>。哈夫曼树一定是二叉树，但不一定是完全二叉树。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;哈夫曼树的定义&quot;&gt;&lt;a href=&quot;#哈夫曼树的定义&quot; class=&quot;headerlink&quot; title=&quot;哈夫曼树的定义&quot;&gt;&lt;/a&gt;哈夫曼树的定义&lt;/h2&gt;&lt;p&gt;设二叉树具有n个带权值的叶节点，那么从根节点到各个叶节点的路径长度与相应节点权值的乘积的和，叫做二叉
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="哈夫曼树" scheme="https://wuhongbin.github.io/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>线索二叉树 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/20/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/20/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-20T02:46:43.000Z</published>
    <updated>2020-06-28T08:37:36.916Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下 线索二叉树知识点…</p><a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>对于具有n个节点的二叉树，采用二叉链存储时，每个节点有两个指针域，总共有 <strong>2n</strong> 个指针域。</p><p>其中只有 n-1 个节点被有效指针指向，即有 <strong>n-1</strong> 个非空指针域。</p><p>所以共有 2n - (n-1) = <strong>n+1</strong> 个空链域。</p><p><strong><font color=green>解释：</font></strong> <strong>除根节点</strong> （根节点没有指针指向）外，每个节点都有且仅有一个指向自己的指针，所以N个节点的二叉树，需要N-1个指针域，则空指针域有N+1个。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>① 采用某种方法遍历二叉树的结果是一个节点的 <strong><font color=red>线性序列</font></strong> 。</p><p>② <strong><font color=red>修改空链域</font></strong> 改为存放指向节点的前趋和后继节点的地址。</p><p>③ 这样的指向该线性序列中的 “ 前趋 ” 和 “ 后继 ” 的指针，称作 <strong><font color=red>线索 (thread)</font></strong> 。</p><p>④ 创建线索的过程称为 <strong><font color=red>线索化</font></strong> 。</p><p>⑤ <strong><font color=red>线索化的</font></strong> 二叉树称为 线索二叉树。</p><p>⑥ 显然线索二叉树与采用的遍历方法相关，有 <strong><font color=red>先序线索二叉树、中序线索二叉树和后序线索二叉树</font></strong>。</p><p>⑦ 线索二叉树的目的是提高 <strong><font color=red>该遍历过程</font></strong> 的效率。</p><h2 id="设计线索二叉树"><a href="#设计线索二叉树" class="headerlink" title="设计线索二叉树"></a>设计线索二叉树</h2><p>在节点的存储结构上增加 <strong><font color=red>两个标志位</font></strong> 来区分这两种情况：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHB8it.png" alt=""></p><p>这样，每个节点的存储结构如下：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHBYz8.png" alt=""></p><p>为了方便算法设计，在线索二叉树中再增加 <strong><font color=red>一个头节点</font></strong> 。</p><p>线索化二叉树中节点的类型定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;           <span class="comment">//节点数据域</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;          <span class="comment">//增加的线索标记</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">lchild</span>;</span>    <span class="comment">//左孩子或者线索指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">rchild</span>;</span>    <span class="comment">//右孩子或者线索指针    </span></span><br><span class="line">&#125;TBTNode;      <span class="comment">//线索树节点类型定义</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHrD2V.md.png" alt=""></p><h2 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h2><p>建立某种次序的线索化二叉树过程：</p><p>(1) 以该遍历方法遍历一棵二叉树。</p><p>(2) 在遍历的过程中，检查当前访问节点的左、右指针域是否为空：</p><p>​        ① 如果左指针域为空，将它改为指向前趋节点的线索；</p><p>​        ② 如果右指针域为空，将它改为指向后继节点的线索。</p><p>下面以 <strong><font color=red>中序线索二叉树</font></strong> 为例，设计建立线索二叉树的算法。</p><h3 id="建立中序线索二叉树的算法"><a href="#建立中序线索二叉树的算法" class="headerlink" title="建立中序线索二叉树的算法"></a>建立中序线索二叉树的算法</h3><p> ① <strong><font color=red>CreaThread(b)算法：</font></strong> 对以二叉链存储的二叉树b进行中序线索化，并返回线索化后头节点的指针root。</p><p>② <strong><font color=red>Thread(p)算法：</font></strong> 对以 *p 为根节点的二叉树子树的中序线索化。</p><p>在中序遍历中：</p><p>① p总是指向当前线索化的节点。</p><p>② pre 作为全局变量，指向刚刚访问过的节点。</p><p>③  ＊pre  是 ＊p 的中序前趋节点， ＊ p 是 ＊pre  的中序后继节点。</p><p>  <img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHcweU.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHgAmT.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">TBTNode * pre;      <span class="comment">//全局变量</span></span><br><span class="line"><span class="function">TBTNode * <span class="title">CreatThread</span><span class="params">(TBTNode * b)</span>      <span class="comment">//中序线索化二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TBTNode * root;</span><br><span class="line">    root = (TBTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TBTNode));  <span class="comment">//创建头节点</span></span><br><span class="line">    root-&gt;ltag = <span class="number">0</span>; </span><br><span class="line">    root-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    root-&gt;rchild = b;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        root-&gt;lchild = root;<span class="comment">//空二叉树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;lchild = b; </span><br><span class="line">        pre = root;<span class="comment">//pre是*p的前趋节点，供加加线索用</span></span><br><span class="line">        Thread(b);<span class="comment">//中序遍历线索化二叉树</span></span><br><span class="line">        pre-&gt;rchild = root;<span class="comment">//最后处理，加入指向头节点的线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        root-&gt;rchild = pre;<span class="comment">//头节点线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread</span><span class="params">(TBTNode *&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//中序遍历递归算法</span></span><br><span class="line">        Thread(p-&gt;lchild);<span class="comment">//左子树线索化</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)<span class="comment">//前趋线索化</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;lchild = pre;<span class="comment">//建立当前节点的前趋线索</span></span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;ltag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)<span class="comment">//后继线索化</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;rchild = p;<span class="comment">//建立前趋节点的前趋线索</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;rtag = <span class="number">0</span>;</span><br><span class="line">        pre = p; </span><br><span class="line">        Thread(p-&gt;rchild);<span class="comment">//递归调用右子树线索化 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历线索化二叉树"><a href="#遍历线索化二叉树" class="headerlink" title="遍历线索化二叉树"></a>遍历线索化二叉树</h2><p>遍历某种次序的线索二叉树，就是从该次序下的 <strong><font color=red>开始节点</font></strong> 出发，反复找到该节点在该次序下的后继节点，直到头节点。</p><p>以中序线索二叉树为例，开始节点时根节点的最左下节点。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YH78Fx.md.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在中序线索二叉树中中序遍历的过程:</span><br><span class="line">p指向根节点;</span><br><span class="line">while p ≠ root 时循环</span><br><span class="line">&#123;</span><br><span class="line">找开始节点 *p;</span><br><span class="line">访问 *p 节点;</span><br><span class="line">while(*p 节点有右线索)</span><br><span class="line">一直访问下去;</span><br><span class="line">    p 转向右孩子节点;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHHN40.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThInOrder</span><span class="params">(TBTNode * tb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TBTNode * p = tb-&gt;lchild;<span class="comment">//p指向根节点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=tb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">            p = p-&gt;lchild;<span class="comment">//找开始节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);<span class="comment">//访问开始节点</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rtag == <span class="number">1</span> &amp;&amp; p-&gt;rchild != tb)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>优点：</font></strong> 中序遍历算法既没有递归也没有用栈，空间效率得到提高。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下 线索二叉树知识点…&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="线索二叉树" scheme="https://wuhongbin.github.io/tags/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的构造 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-19T02:46:43.000Z</published>
    <updated>2020-06-28T08:36:48.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>同一棵而二叉树（假设每个节点值唯一）具有  <strong><font color=blue>唯一</font></strong>的先序序列、中序序列、后序序列。</p><p>但 <strong><font color=blue>不同的二叉树</font></strong> 可能具有相同的先序序列，中序序列或后序序列。</p><p><strong>例如：</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4TXsP.md.png" alt=""></p><blockquote><p><strong><font color=blue>结论：</font></strong></p><p>① 给定一棵二叉树（假设每个节点值唯一）的先序、中序和后序序列可以唯一构造（确定）出该二叉树。</p><p>② 仅由先序、中序或后序序列中的 <strong>一种</strong>，无法唯一构造出该二叉树。</p></blockquote><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p><strong>那么问题来了？如果给定先序、中序和后序序列中任意两个，是否可以唯一构造出该二叉树呢？</strong></p><blockquote><p><strong><font color=blue>答案：</font></strong></p><p>① 同时给定一棵二叉树的 <strong><font color=green>先序序列和中序序列 </font></strong> 就能唯一确定这棵二叉树</p><p>② 同时给定一棵二叉树的 <strong><font color=green>中序序列和后序序列 </font></strong> 就能唯一确定这棵二叉树</p></blockquote><h3 id="定理1："><a href="#定理1：" class="headerlink" title="定理1："></a><strong><font color=red>定理1：</font></strong></h3><p>任何n（N&gt;0）个不同节点的二叉树，都可以由它的<strong>中序序列和先序序列</strong>唯一确定。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4HUBV.md.png" alt=""></p><p><strong>例如：</strong> 已知先序序列为 ABDGCEF ，中序序列为 DGBAECF，则构造二叉树的过程如下所示。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4bra8.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YIG9mD.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由上述定理得到以下算法</span></span><br><span class="line"><span class="function">BTNOde * <span class="title">CreateBT1</span><span class="params">(<span class="keyword">char</span> * pre, <span class="keyword">char</span> * in, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * s; <span class="keyword">char</span> * p; <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    s = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));  <span class="comment">//创建根节点</span></span><br><span class="line">    s-&gt;data = *pre;</span><br><span class="line">    <span class="keyword">for</span>(p = in;p &lt; in+n;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*p == *pre)<span class="comment">//在in中找为*pre的位置k</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = p-in;</span><br><span class="line">s-&gt;lchild = CreateBT1(pre+<span class="number">1</span>, in, k);<span class="comment">//构造左子树</span></span><br><span class="line">    s-&gt;rchild = CreateBT1(pre+k+<span class="number">1</span>, p+<span class="number">1</span>, n-k<span class="number">-1</span>);<span class="comment">//构造右子树</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定理2："><a href="#定理2：" class="headerlink" title="定理2："></a><strong><font color=red>定理2：</font></strong></h3><p>任何n（N&gt;0）个不同节点的二叉树，都可以由它的<strong>中序序列和后序序列</strong>唯一确定。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4qrO1.md.png" alt=""></p><p><strong>例如：</strong> 已知中序序列为 DGBAECF，后序序列 GDBEFCA 则构造二叉树的过程如下所示。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4qqk8.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YI0lAf.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由上述定理得到以下算法</span></span><br><span class="line"><span class="function">BTNOde * <span class="title">CreateBT2</span><span class="params">(<span class="keyword">char</span> * post, <span class="keyword">char</span> * in, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * b; <span class="keyword">char</span> r, * p; <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    r = *(post+n<span class="number">-1</span>);                       <span class="comment">//根节点值</span></span><br><span class="line">    b = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));  <span class="comment">//创建二叉树根节点*b</span></span><br><span class="line">    b-&gt;data = r;</span><br><span class="line">    <span class="keyword">for</span>(p = in;p &lt; in+n;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*p == r)<span class="comment">//在in中找为*pre的位置k</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = p-in;<span class="comment">//k为根节点在in中的下标</span></span><br><span class="line">s-&gt;lchild = CreateBT2(post, in, k);<span class="comment">//构造左子树</span></span><br><span class="line">    s-&gt;rchild = CreateBT2(post + k, p+<span class="number">1</span>, n-k<span class="number">-1</span>);<span class="comment">//构造右子树</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题1："><a href="#例题1：" class="headerlink" title="例题1："></a><strong><font color=red>例题1：</font></strong></h3><p>设计一个算法将二叉树的<strong>顺序存储结构</strong>转化成<strong>二叉链存储结构</strong>。</p><p><strong><font color=green>解：</font></strong>设二叉树的顺序存储结构为a，由f(a,1)返回创建的二叉链存储结构的根节点指针b</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YI50VU.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode * <span class="title">trans1</span><span class="params">(SqBTree a, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * b;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[i] == <span class="string">'#'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//当节点不存在时返回NULL</span></span><br><span class="line">    b = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));   <span class="comment">//创建根节点</span></span><br><span class="line">    b -&gt; data = a[i];</span><br><span class="line">    b -&gt; lchild = trans1(a, <span class="number">2</span>*i);     <span class="comment">//递归创建左子树</span></span><br><span class="line">    b -&gt; rchild = trans1(a, <span class="number">2</span>*i+<span class="number">1</span>);     <span class="comment">//递归创建左子树</span></span><br><span class="line">    <span class="keyword">return</span>(b);<span class="comment">//返回根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此算法是先序遍历的思路</span></span><br></pre></td></tr></table></figure><h3 id="例题2："><a href="#例题2：" class="headerlink" title="例题2："></a><strong><font color=red>例题2：</font></strong></h3><p>设计一个算法将二叉树的<strong>二叉链存储结构</strong>转化成<strong>顺序存储结构</strong>。</p><p><strong><font color=green>解：</font></strong>f(b，a，i)：由二叉链b创建a[i]为根节点的顺序存储结构a</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YIoA1A.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">trans2</span><span class="params">(BTNode * b, SqBTree a, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = b -&gt; data;<span class="comment">//创建根节点</span></span><br><span class="line">        trans2(b -&gt; lchild, a, <span class="number">2</span>*i);     <span class="comment">//递归创建左子树</span></span><br><span class="line">        trans2(b -&gt; rchild, a, <span class="number">2</span>*i+<span class="number">1</span>);     <span class="comment">//递归创建左子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此算法是先序遍历的思路</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;p&gt;同一棵而二叉树（假设每个节点值唯一）具有  &lt;strong&gt;&lt;font color=blue&gt;唯一&lt;/font&gt;&lt;/strong&gt;的先序序列
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="构造二叉树" scheme="https://wuhongbin.github.io/tags/%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux(deepin-uos)系统安装后无法使用无线网问题解决</title>
    <link href="https://wuhongbin.github.io/2020/05/16/Linux(deepin-uos)%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E6%97%A0%E7%BA%BF%E7%BD%91%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://wuhongbin.github.io/2020/05/16/Linux(deepin-uos)%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E6%97%A0%E7%BA%BF%E7%BD%91%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</id>
    <published>2020-05-16T03:10:43.000Z</published>
    <updated>2020-06-28T08:32:02.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人笔记本电脑型号已测试，联想Y7000，安装deepin/uos后，100%遇到此问题。</p><h2 id="问题检查"><a href="#问题检查" class="headerlink" title="问题检查"></a>问题检查</h2><p><strong>驱动问题</strong></p><p>如果通过命令<code>ifconfig</code>没能发现类似<code>wlp7s0</code>的无线网络，可以判断是这个问题。</p><p><strong>无线网卡被hard blocked的问题</strong></p><p>运行命令<code>rfkill list all</code>，出现如下结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:ideapad_wlan: Wireless LAN </span><br><span class="line">Soft blocked: no </span><br><span class="line">Hard blocked:yes </span><br><span class="line">1:ideapad_bluetooth: Bluetooth </span><br><span class="line">Soft blocked: no </span><br><span class="line">Hard blocked: yes </span><br><span class="line">2:phy0: Wireless LAN </span><br><span class="line">Soft blocked: no </span><br><span class="line">Hard blocked:no </span><br><span class="line">3:hci0: Bluetooth </span><br><span class="line">Soft blocked: yes </span><br><span class="line">Hard blocked: no</span><br></pre></td></tr></table></figure><p>可以看到，优先级前的ideapad_wlan的Hard blocked 默认为yes，即deepin默认关闭了硬件wifi开关，而联想拯救者Y7000的wifi只有软件开关，没有硬件开关的启动，所以引起了wifi无法开启的问题。</p><p><strong>网卡驱动的电源管理问题</strong></p><p>使用命令<code>dmesg</code>查看日志，如果出现</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/16/Y68IZ8.png" alt=""></p><p>那很可能就是这个问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>驱动问题解决方案：</strong></p><p>如果确认是驱动问题，则可以尝试通过重装驱动解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install --reinstall firmware-realtek</span><br></pre></td></tr></table></figure><p><strong>无线网卡被hard blocked解决方案：</strong></p><p>禁用 *<em>ideapad_laptop *</em>驱动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;blacklist ideapad_laptop&quot; | sudo tee &#x2F;etc&#x2F;modprobe.d&#x2F;backlist-ideapad.conf</span><br></pre></td></tr></table></figure><p><strong>网卡驱动的电源管理问题解决方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;options r8822be aspm&#x3D;0&quot; | sudo tee &#x2F;etc&#x2F;modprobe.d&#x2F;r8822be.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本人笔记本电脑型号已测试，联想Y7000，安装deepin/uos后，100%遇到此问题。&lt;/p&gt;
&lt;h2 id=&quot;问题检查&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="L i n u x" scheme="https://wuhongbin.github.io/categories/L-i-n-u-x/"/>
    
    
      <category term="Linux" scheme="https://wuhongbin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统分区方案</title>
    <link href="https://wuhongbin.github.io/2020/05/16/Linux%E7%B3%BB%E7%BB%9F%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88/"/>
    <id>https://wuhongbin.github.io/2020/05/16/Linux%E7%B3%BB%E7%BB%9F%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88/</id>
    <published>2020-05-16T03:10:43.000Z</published>
    <updated>2020-06-28T08:26:52.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单分区方案"><a href="#简单分区方案" class="headerlink" title="简单分区方案"></a>简单分区方案</h2><p>实际上，很多时候我们只需要分两个区：<code>/</code>和交换分区，日常使用基本不会有任何影响，甚至于交换分区对于现在的电脑来说都不是必要的，我们完全可以只分配一个根分区。linux只需要一个/根分区就可以正常运行。</p><h2 id="常用分区方案"><a href="#常用分区方案" class="headerlink" title="常用分区方案"></a>常用分区方案</h2><p>以使用 <strong>100G 空间</strong> 安装 linux 为例，各目录含义，请参考文章结尾附录。</p><table><thead><tr><th align="center">目录类型</th><th align="center">挂载点</th><th align="center">分区格式</th><th align="center">大小</th></tr></thead><tbody><tr><td align="center">根目录</td><td align="center">/</td><td align="center">ext4</td><td align="center">20-40G</td></tr><tr><td align="center">家目录</td><td align="center">/home</td><td align="center">ext4</td><td align="center">剩余所有空间</td></tr><tr><td align="center">交换分区</td><td align="center">swap</td><td align="center">无</td><td align="center">2G</td></tr></tbody></table><p><strong><font color=red>注意：</font></strong> 交换分区 无挂载点 分区格式选择交换分区（swap） 最大不建议超过真实内存大小，除非内存小于2G，你的内存大于4G，推荐2G即可，没必要有些人推荐的与内存相当。</p><h2 id="DIY分区方案"><a href="#DIY分区方案" class="headerlink" title="DIY分区方案"></a>DIY分区方案</h2><p>更高级的分区，我们就要了解一下自己电脑的使用场景。</p><p>linux的整体目录就是一个树状结构，根据文章结尾的附录一，我们会知道/分区下的各个目录存放的内容都是不一样的，所以他们的内容变化速度也会不一样。</p><p>了解了这些，试想一个场景，如果我们只分配一个/分区，内容增加速度快的目录，比如个人桌面系统的/home，服务器的/var目录可能会迅速占领大部分的存储容量，以至于当存储容量用尽时出现电脑无法开机的现象。</p><p>为了避免出现这样的情形，我们可以给电脑分区，然后将分区‘挂载’到根分区的指定目录，限制目录的大小，同时保护一些重要目录，比如/boot，这样，即便目录某个目录扩张很快，最终也只会占用我们分配的大小，不会影响到电脑的正常运行。所以第二种方法里，我们把/boot和/home单独分了出来，避免/分区的内容扩张影响到系统启动，同时，分配/home分区可以在电脑系统崩溃，重装系统时避免个人文件丢失，直接将分区挂载上去，个人的数据就不会丢失。</p><p>但是有的时候，我们要安装linux是给服务器安装的，这时，/home就不应该分配这么多空间了，因为对于个人电脑桌面系统，我们可能需要安装很多的软件、文件和视频音乐等，会导致/home目录变得十分臃肿，而其他目录相对来说比较小。不过对于服务器来说，更占用存储的地方可能集中在了/var目录，比如日志文件，比如web服务器的根目录，一般都在/var目录中，这时，我们就应该给/var目录分配更多的空间，保证服务器的正常运行。当然，如果你的服务器目录结构是自己组织的，你就要按照你自己电脑的情况来分析你的电脑该如何来选择分区。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><table><thead><tr><th align="center">目录名</th><th align="center">简介</th></tr></thead><tbody><tr><td align="center">swap</td><td align="center">类似于windows的虚拟内存文件</td></tr><tr><td align="center">/</td><td align="center">根目录，根目录下最好只有目录，文件放在目录下，不要放在根目录中。</td></tr><tr><td align="center">/boot</td><td align="center">包括操作系统的内核和启动过程需要用的文件</td></tr><tr><td align="center">/root</td><td align="center">超级管理员的家目录</td></tr><tr><td align="center">/home</td><td align="center">家目录，用来存放用户文件</td></tr><tr><td align="center">/etc</td><td align="center">大部分的配置文件默认都放在这里</td></tr><tr><td align="center">/dev</td><td align="center">Linux系统中，所有的硬件都以文件的形式放在这个目录中</td></tr><tr><td align="center">/lost+found</td><td align="center">突然停电或者非正常关机，存放临时文件</td></tr><tr><td align="center">/sbin</td><td align="center">管理员才能运行的一些程序</td></tr><tr><td align="center">/opt</td><td align="center">存储第三方软件的目录</td></tr><tr><td align="center">/proc</td><td align="center">存储进程相关的信息，用于方便的访问进程信息，伪文件系统，所有的内容都存储在内存中</td></tr><tr><td align="center">/mnt</td><td align="center">一般我们将手动挂载的分区放在这里（例如新加一款硬盘，可以挂载在这里）</td></tr><tr><td align="center">/media</td><td align="center">系统自动挂载的分区放在这里</td></tr><tr><td align="center">/lib</td><td align="center">用于存放库文件</td></tr><tr><td align="center">/usr</td><td align="center"></td></tr><tr><td align="center">/usr/lib</td><td align="center">同/lib</td></tr><tr><td align="center">/usr/sbin</td><td align="center">同/sbin</td></tr><tr><td align="center">/usr/local/bin</td><td align="center">系统实用程序</td></tr><tr><td align="center">/usr/local/sbin</td><td align="center">同/sbin</td></tr><tr><td align="center">/usr/local/lib</td><td align="center">同/lib</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简单分区方案&quot;&gt;&lt;a href=&quot;#简单分区方案&quot; class=&quot;headerlink&quot; title=&quot;简单分区方案&quot;&gt;&lt;/a&gt;简单分区方案&lt;/h2&gt;&lt;p&gt;实际上，很多时候我们只需要分两个区：&lt;code&gt;/&lt;/code&gt;和交换分区，日常使用基本不会有任何影响，甚至
      
    
    </summary>
    
    
      <category term="L i n u x" scheme="https://wuhongbin.github.io/categories/L-i-n-u-x/"/>
    
    
      <category term="Linux分区" scheme="https://wuhongbin.github.io/tags/Linux%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>彻底删除烦人的Linux系统引导项文件</title>
    <link href="https://wuhongbin.github.io/2020/05/16/%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E7%83%A6%E4%BA%BA%E7%9A%84Linux%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E9%A1%B9%E6%96%87%E4%BB%B6/"/>
    <id>https://wuhongbin.github.io/2020/05/16/%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E7%83%A6%E4%BA%BA%E7%9A%84Linux%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E9%A1%B9%E6%96%87%E4%BB%B6/</id>
    <published>2020-05-16T02:10:43.000Z</published>
    <updated>2020-06-28T08:27:45.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在使用win10 + deepin的过程中，由于 deepin 系统安装失败/重装时，需要删除掉deepin系统引项。</p><p>常用的做法是在win10安装<strong>EasyUEFI</strong>,使用其中的 <strong>管理EFI启动项</strong> 来对deepin启动项进行删除，可能的原因是之前无意中将 deepin 的启动项文件损坏了，结果删除时总是显示无效的文件。但是明明deepin启动项仍然存在于BIOS启动项选项里面。意思就是它明明存在，但是你就是删不掉。</p><p>如果你在 win10安装<strong>EasyUEFI</strong> 删除引导无效，请看以下教程。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>使用快捷键 <code>win+x</code>，打开 <code>Windows PowerShell(管理员)(A)</code>，依次输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">diskpart         #打开diskpart</span><br><span class="line">list disk        #列出系统中拥有的磁盘，我笔记本上有两块磁盘，记得当时ubuntu启动项文件安装到了SSD所在的磁盘0中</span><br><span class="line">select disk 0    #选择EFI引导分区所在的磁盘，请根据实际情况选择</span><br><span class="line">list partition   #列出所选磁盘拥有的分区</span><br><span class="line">select partition 1    #选择EFI引导分区，类型为系统的分区，就是EFI引导分区</span><br><span class="line">assign letter&#x3D;p:      #为所选分区分配盘符，请分配空闲盘符</span><br><span class="line">exit                 # 退出</span><br><span class="line">taskkill &#x2F;im explorer.exe &#x2F;f   #关闭explorer</span><br><span class="line">explorer.exe     #再以管理员身份打开explorer</span><br></pre></td></tr></table></figure><p>此时，在<strong>我的电脑</strong>中会发现，新增加了一个磁盘分区p，但是直接双击打开仍然打不开，于是直接在刚才的PowerShell命令行中进行操作了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p:  #转到p磁盘</span><br><span class="line">ls  #查看p磁盘下的文件信息，正常的话会看见一个名为EFI的文件夹，回想上面在EasyUEFI中看到的ubuntu启动项的文件路径，ubuntu启动项文件就在这个EFI文件夹下面</span><br><span class="line">cd EFI  #进入EFI文件夹</span><br><span class="line">ls       #此时会看到一个名为ubuntu的文件夹，终于找到它了！同时还会看到一个名为Microsoft的文件夹，它应该就是win10系统的启动项文件</span><br><span class="line">cd ubuntu    #进入ubuntu文件夹</span><br><span class="line">ls       #查看有哪些启动项文件，这里会看见EasyUEFI&#x2F;文件路径中提到的shimx64.efi文件</span><br><span class="line">cd ..  #跳回EFI文件夹</span><br><span class="line">del ubuntu  #再将ubuntu文件夹整个删掉，斩草除根！</span><br><span class="line">ls      #此时会发现已经没有ubuntu文件夹了！</span><br></pre></td></tr></table></figure><p>自此，清理 ubuntu 启动项文件的工作就结束了,不用管刚才分配的 <strong>p盘符</strong>，关掉 PowerShell，关掉笔记本重启，重启后之前分配的p盘符会自动移除。</p><p><strong><font color=red>温馨提示：</font></strong>其他 Linux 系统只需找到对应名字的引导文件删除即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在使用win10 + deepin的过程中，由于 deepin 系统安装失败/重装时，需要删除掉deepin系统引项。&lt;/p&gt;
&lt;p&gt;常用的
      
    
    </summary>
    
    
      <category term="L i n u x" scheme="https://wuhongbin.github.io/categories/L-i-n-u-x/"/>
    
    
      <category term="Linux引导" scheme="https://wuhongbin.github.io/tags/Linux%E5%BC%95%E5%AF%BC/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的遍历及其应用 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-13T09:46:43.000Z</published>
    <updated>2020-06-28T08:35:50.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树遍历的概念"><a href="#二叉树遍历的概念" class="headerlink" title="二叉树遍历的概念"></a>二叉树遍历的概念</h2><p><strong><font color=red>二叉树的遍历</font></strong> 是指按照一定次序访问树中所有节点，并且 <strong><font color=red>每个节点仅被访问一次</font></strong> 的过程。</p><p>遍历是二叉树最基本的运算，是二叉树其他运算的基础。</p><p><strong>二叉树的组成：</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/Yd2JFf.png" alt=""></p><h3 id="1-先序遍历过程"><a href="#1-先序遍历过程" class="headerlink" title="1. 先序遍历过程"></a><strong><font color=red>1. 先序遍历过程</font></strong></h3><p>先序遍历NLR二叉树的过程是：</p><p>① 访问根节点;</p><p>② 先序遍历左子树;</p><p>③ 先序遍历右子树。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdR9tf.md.png" alt=""></p><h3 id="2-中序遍历过程"><a href="#2-中序遍历过程" class="headerlink" title="2. 中序遍历过程"></a><strong><font color=red>2. 中序遍历过程</font></strong></h3><p>中序遍历LNR二叉树的过程是：</p><p>① 中序遍历左子树；</p><p>② 访问根节点；</p><p>③ 中序遍历右子树。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdRi9S.md.png" alt=""></p><h3 id="3-后序遍历过程"><a href="#3-后序遍历过程" class="headerlink" title="3. 后序遍历过程"></a><strong><font color=red>3. 后序遍历过程</font></strong></h3><p>中序遍历LNR二叉树的过程是：</p><p>① 后序遍历左子树；</p><p>② 后序遍历右子树；</p><p>③ 访问根节点。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdRCh8.md.png" alt=""></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a><strong><font color=green>例题</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdftfK.md.png" alt=""></p><h2 id="二叉树遍历递归算法"><a href="#二叉树遍历递归算法" class="headerlink" title="二叉树遍历递归算法"></a>二叉树遍历递归算法</h2><p>由二叉树的三种遍历过程直接得到3种递归算法</p><h3 id="先序遍历的递归算法"><a href="#先序遍历的递归算法" class="headerlink" title="先序遍历的递归算法"></a><strong><font color=blue>先序遍历的递归算法</font></strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(b-&gt;lchild);</span><br><span class="line">        PreOrder(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 <strong>访问</strong> 是直接输出节点值。实际上，访问节点可以对该节点进行各种操作，如计数，删除节点等。</p><h3 id="中序遍历的递归算法"><a href="#中序遍历的递归算法" class="headerlink" title="中序遍历的递归算法"></a><strong><font color=blue>中序遍历的递归算法</font></strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrder(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">        InOrder(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历的递归算法"><a href="#后序遍历的递归算法" class="headerlink" title="后序遍历的递归算法"></a><strong><font color=blue>后序遍历的递归算法</font></strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrder(b-&gt;lchild);</span><br><span class="line">        PostOrder(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层次遍历算法"><a href="#层次遍历算法" class="headerlink" title="层次遍历算法"></a>层次遍历算法</h2><p>层次遍历过程：</p><p>对于一棵二叉树，从根节点开始，按从上到下，从左到右的顺序访问每一个节点。</p><p>每个节点仅仅访问一次。</p><h3 id="算法设计思路"><a href="#算法设计思路" class="headerlink" title="算法设计思路"></a>算法设计思路</h3><p>使用一个队列。</p><p>Ⅰ 将根节点进队;</p><p>Ⅱ <strong><font color=blue>队不空时循环</font></strong>：从队列中列出一个节点 *p 访问它；</p><p>​    ① 若它有左孩子节点，将左孩子节点进队；</p><p>​    ② 若它有右孩子节点，将右孩子节点进队。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BTNode * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * p;</span><br><span class="line">    BTNode *qu[MaxSize];  <span class="comment">//定义环形队列，存放节点指针</span></span><br><span class="line">    <span class="keyword">int</span> front,rear;       <span class="comment">//定义对头和队尾指针</span></span><br><span class="line">    front = rear = <span class="number">0</span>;     <span class="comment">//置队列为空队列</span></span><br><span class="line">    rear++;</span><br><span class="line">    qu[rear] = b;         <span class="comment">//根节点指针进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(front != rear)  <span class="comment">//队列不为空循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        front = (front + <span class="number">1</span>)%MaxSize;</span><br><span class="line">        p = qu[front];    <span class="comment">//队头出队列</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);  <span class="comment">//访问节点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)   <span class="comment">//有左孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear = (rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">            qu[rear] = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)   <span class="comment">//有右孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear = (rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">            qu[rear] = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法的时间复杂度为O(n)</strong></p><h2 id="二叉树3种递归遍历算法的应用"><a href="#二叉树3种递归遍历算法的应用" class="headerlink" title="二叉树3种递归遍历算法的应用"></a>二叉树3种递归遍历算法的应用</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><strong><font color=green>基本思路</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/Yw1DA0.md.png" alt=""></p><p><strong><font color=green>例1：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法，计算一棵给定二叉树的所有节点个数</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwGAkq.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Nodes</span><span class="params">(BTNode * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Nodes(b-&gt;lchild)+Nodes(b-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//先左子树，再右子树，最后根节点，是后序遍历的思路</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>提示</font></strong>:<strong>本例算法可以基于任何一种遍历算法</strong></p><p><strong><font color=green>例2：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法，计算一棵给定二叉树的所有叶子节点个数</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwGp6g.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafNodes</span><span class="params">(BTNode * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; b-&gt;rchlid == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        num1 = LeafNodes(b-&gt;lchild);</span><br><span class="line">        num2 = LeafNodes(b-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> (num1+num2);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>提示</font></strong>:<strong>本例算法可以基于任何一种遍历算法</strong></p><p><strong><font color=green>例3：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法把二叉树b复制到二叉树t中</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwJUP0.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(BTNode * b, BTNode * t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">        t-&gt;data = b-&gt;data;<span class="comment">//复制一个根节点*t</span></span><br><span class="line">        Copy(b-&gt;lchild, t-&gt;lchild);    <span class="comment">//递归复制左子树</span></span><br><span class="line">        Copy(b-&gt;rchild, t-&gt;rchild);     <span class="comment">//递归复制右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>先根节点，再左子树，最后右子树，是先序遍历的思路</p><p><strong><font color=green>例4：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法把二叉树b的左、右子树进行交换。要求 <font color=red>不破坏原二叉树</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwYGQO.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(BTNode * b, BTNode * t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">        t-&gt;data = b-&gt;data;<span class="comment">//复制一个根节点*t</span></span><br><span class="line">        Swap(b-&gt;lchild, t-&gt;rchild);    <span class="comment">//递归交换左子树</span></span><br><span class="line">        Swap(b-&gt;rchild, t-&gt;lchild);     <span class="comment">//递归交换右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=green>例5：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法level()求二叉树b中值为x的节点的层次（假设所有节点值唯一）。</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwtDE9.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwtrNR.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/Ywt0HJ.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">(BTNode * b, ElemType x, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空树时返回0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;data == x)<span class="comment">//找到节点时</span></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        l = level(b-&gt;lchild, x, h+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> level(b-&gt;rchild, x, h+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> l;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>注意：</font></strong>基于<strong>先序遍历</strong>算法思想</p><h2 id="层次遍历算法的应用"><a href="#层次遍历算法的应用" class="headerlink" title="层次遍历算法的应用"></a>层次遍历算法的应用</h2><p><strong><font color=green>例1：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法输出从根节点到每个叶子节点的逆路径。</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwNJVH.png" alt=""></p><p><strong>解：</strong> 设计的队列为非环形队列qu，将所有已访问过的节点指针进队，并在队列中保存双亲节点的位置。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwNxsO.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AllPath</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snode</span>;</span></span><br><span class="line">    &#123;</span><br><span class="line">        BTNode * node;     <span class="comment">//存放当前节点指针</span></span><br><span class="line">        <span class="keyword">int</span> parent;   <span class="comment">//存放双亲节点在队列中的位置</span></span><br><span class="line">    &#125;qu[MaxSize];   <span class="comment">//定义非环形队列</span></span><br><span class="line">    BTNode *q;</span><br><span class="line">    <span class="keyword">int</span> front, rear, p;    <span class="comment">//定义队头和队尾指针</span></span><br><span class="line">    front = rear = <span class="number">-1</span>;     <span class="comment">//置队列为空队列</span></span><br><span class="line">    rear++;</span><br><span class="line">    qu[rear].node = b;     <span class="comment">//根节点指针进去队列</span></span><br><span class="line">    qu[rear].parent = <span class="number">-1</span>;  <span class="comment">//根节点没有双亲节点</span></span><br><span class="line">    <span class="keyword">while</span>(front != rear)   <span class="comment">//队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        front++;   <span class="comment">//front是当前节点*q在qu中的位置</span></span><br><span class="line">        q = qu[front].node;  <span class="comment">//队列出队列，该节点指针仍在qu中</span></span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; q-&gt;rchild == <span class="literal">NULL</span>)  <span class="comment">//*q为叶子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = front;     <span class="comment">//输出*q到根节点的逆路径序列</span></span><br><span class="line">            <span class="keyword">while</span>(qu[p].parent != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c-&gt;"</span>, qu[p].node-&gt;data);</span><br><span class="line">                p = qu[p].parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c\m"</span>, qu[p].node-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild != <span class="literal">NULL</span>)   <span class="comment">//*q节点有左孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear++;</span><br><span class="line">            qu[rear].node = q-&gt;lchild;</span><br><span class="line">            qu[rear].parent = front;  <span class="comment">//*q的左孩子的双亲位置为front</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild != <span class="literal">NULL</span>)   <span class="comment">//*q节点有右孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear++;</span><br><span class="line">            qu[rear].node = q-&gt;rchild;</span><br><span class="line">            qu[rear].parent = front;  <span class="comment">//*q的右孩子的双亲位置为front</span></span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树遍历的概念&quot;&gt;&lt;a href=&quot;#二叉树遍历的概念&quot; class=&quot;headerlink&quot; title=&quot;二叉树遍历的概念&quot;&gt;&lt;/a&gt;二叉树遍历的概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;font color=red&gt;二叉树的遍历&lt;/font&gt;&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="遍历二叉树" scheme="https://wuhongbin.github.io/tags/%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
