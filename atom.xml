<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>时光如水の总是无言</title>
  
  <subtitle>wuhongbin&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuhongbin.github.io/"/>
  <updated>2020-09-13T03:03:04.821Z</updated>
  <id>https://wuhongbin.github.io/</id>
  
  <author>
    <name>时光如水の总是无言</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Qt 使用大神自定义控件快速创建树状导航栏</title>
    <link href="https://wuhongbin.github.io/2020/07/08/Qt%20%E4%BD%BF%E7%94%A8%E5%A4%A7%E7%A5%9E%E6%8F%92%E4%BB%B6%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E6%A0%91%E7%8A%B6%E5%AF%BC%E8%88%AA%E6%A0%8F/"/>
    <id>https://wuhongbin.github.io/2020/07/08/Qt%20%E4%BD%BF%E7%94%A8%E5%A4%A7%E7%A5%9E%E6%8F%92%E4%BB%B6%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E6%A0%91%E7%8A%B6%E5%AF%BC%E8%88%AA%E6%A0%8F/</id>
    <published>2020-07-08T04:10:43.000Z</published>
    <updated>2020-09-13T03:03:04.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本博客仅仅记录自己的采坑过程以及帮助网友避坑，方便以后快速使用自定义控件，避免重复出错。</p><h1 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h1><p>大神 Github Qt 自定义控件项目地址：<a href="https://github.com/feiyangqingyun/qucsdk" target="_blank" rel="noopener">https://github.com/feiyangqingyun/qucsdk</a></p><h1 id="插件简介"><a href="#插件简介" class="headerlink" title="插件简介"></a>插件简介</h1><ul><li>1:设置节点数据相当方便,按照对应格式填入即可,分隔符,</li><li>2:可设置提示信息 是否显示+宽度</li><li>3:可设置行分隔符 是否显示+高度+颜色</li><li>4:可设置选中节点线条突出显示+颜色+左侧右侧位置</li><li>5:可设置选中节点三角形突出显示+颜色+左侧右侧位置</li><li>6:可设置父节点的 选中颜色+悬停颜色+默认颜色</li><li>7:可设置子节点的 选中颜色+悬停颜色+默认颜色</li><li>8:可设置父节点文字的 图标边距+左侧距离+字体大小+高度</li><li>9:可设置子节点文字的 图标边距+左侧距离+字体大小+高度</li><li>10:可设置节点展开模式 单击+双击+禁用</li></ul><h1 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h1><ol><li><p>插件法的自定义控件使用，务必保证编译器完全一致。</p></li><li><p>将对应的quc.dll和libquc.a 或者 quc.lib(MSVC编译器才有)集成到项目中。</p></li><li><p>使用到哪个控件，只需要将对应控件的头文件集成到项目中即可。集成方法是将该头文件复制到sdk目录（因为pro文件写的是从sdk目录读取头文件），也可以自己定义目录。</p></li><li><p>项目的pro文件加入代码</p></li><li><pre><code class="C++">INCLUDEPATH += $$PWD/sdkCONFIG(debug, debug|<span class="built_in">release</span>){LIBS += -L$$PWD/sdk/ -lqucd} <span class="keyword">else</span> {LIBS += -L$$PWD/sdk/ -lquc}&lt;!--￼<span class="number">0</span>--&gt;</code></pre></li></ol><p>多次研究尝试后发现这些十六进制均是字体图标，到字体图标网站查询替换成自己喜欢的的<strong>免费</strong>图标</p><p>Font Awesome 图标地址： <a href="https://fontawesome.com/cheatsheet/free/solid" target="_blank" rel="noopener">https://fontawesome.com/cheatsheet/free/solid</a></p><h1 id="调用实例"><a href="#调用实例" class="headerlink" title="调用实例"></a>调用实例</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;listView-&gt;setParentFontSize(<span class="number">22</span>);<span class="comment">//设置父节点字体大小</span></span><br><span class="line">ui-&gt;listView-&gt;setParentMargin(<span class="number">70</span>);<span class="comment">//设置父节点文字偏移距离</span></span><br><span class="line">ui-&gt;listView-&gt;setParentHeight(<span class="number">48</span>);<span class="comment">//设置父节点高度</span></span><br><span class="line"><span class="comment">//设置父节点的 选中颜色+悬停颜色+默认颜色</span></span><br><span class="line">ui-&gt;listView-&gt;setParentBgNormalColor(QColor(<span class="number">19</span>,<span class="number">161</span>,<span class="number">255</span>));</span><br><span class="line">ui-&gt;listView-&gt;setParentBgSelectedColor(QColor(<span class="number">84</span>,<span class="number">110</span>,<span class="number">255</span>));</span><br><span class="line">ui-&gt;listView-&gt;setParentBgHoverColor(QColor(<span class="number">84</span>,<span class="number">110</span>,<span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">ui-&gt;listView-&gt;setChildFontSize(<span class="number">18</span>);<span class="comment">//设置子点字体大小</span></span><br><span class="line">ui-&gt;listView-&gt;setChildMargin(<span class="number">110</span>);<span class="comment">//设置子点文字偏移距离</span></span><br><span class="line">ui-&gt;listView-&gt;setChildIconMargin(<span class="number">80</span>);<span class="comment">//设置子点图标距离</span></span><br><span class="line">ui-&gt;listView-&gt;setChildHeight(<span class="number">40</span>);<span class="comment">//设置子点高度</span></span><br><span class="line"><span class="comment">//子节点的 选中颜色+悬停颜色+默认颜色</span></span><br><span class="line">ui-&gt;listView-&gt;setChildBgNormalColor(QColor(<span class="number">172</span>,<span class="number">217</span>,<span class="number">255</span>));</span><br><span class="line">ui-&gt;listView-&gt;setChildBgHoverColor(QColor(<span class="number">84</span>,<span class="number">110</span>,<span class="number">255</span>));</span><br><span class="line">ui-&gt;listView-&gt;setChildBgSelectedColor(QColor(<span class="number">84</span>,<span class="number">110</span>,<span class="number">255</span>));</span><br><span class="line">ui-&gt;listView-&gt;setChildTextNormalColor(QColor(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));<span class="comment">////设置子点文字默认颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  管理||0||  父节点   查询图书|图书管理|||0xf002    子节点</span></span><br><span class="line">ui-&gt;listView-&gt;setItems(<span class="string">"图书管理||0||,查询图书|图书管理|||0xf002,新增图书|图书管理|||0xf067,逾期管理||0||,查询逾期|逾期管理|||0xf002,账户管理||0||,查询读者|账户管理|||0xf002,新增读者|账户管理|||0xf067"</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>其他样式设置自行查看对应自定义控件头文件方法列表</strong></p></blockquote><h1 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h1><p>这个自定义控件是基于listView控件改写的，需要在UI界面拖一个 listView 控件 <strong>提升为自定义控件使用</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本博客仅仅记录自己的采坑过程以及帮助网友避坑，方便以后快速使用自定义控件，避免重复出错。&lt;/p&gt;
&lt;h1 id=&quot;下载插件&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Qt 笔记" scheme="https://wuhongbin.github.io/categories/Qt-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Qt" scheme="https://wuhongbin.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt 信号与槽的自动关联机制</title>
    <link href="https://wuhongbin.github.io/2020/07/03/Qt%20%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E8%87%AA%E5%8A%A8%E5%85%B3%E8%81%94%E6%9C%BA%E5%88%B6/"/>
    <id>https://wuhongbin.github.io/2020/07/03/Qt%20%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E8%87%AA%E5%8A%A8%E5%85%B3%E8%81%94%E6%9C%BA%E5%88%B6/</id>
    <published>2020-07-03T04:10:43.000Z</published>
    <updated>2020-09-03T15:32:27.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于一些简单的事件判别，如点击按钮。无需写代码关联信号和槽函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;Btnshowhello,SIGNAL(clicked(<span class="keyword">bool</span>)),<span class="keyword">this</span>,SLOT(BtnshowhelloSlot()));</span><br></pre></td></tr></table></figure><h1 id="信号与槽的自动关联机制"><a href="#信号与槽的自动关联机制" class="headerlink" title="信号与槽的自动关联机制"></a>信号与槽的自动关联机制</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> on_&lt;object name&gt;_&lt;signal name&gt;(&lt;signal parameters&gt;);</span><br></pre></td></tr></table></figure><h1 id="例"><a href="#例" class="headerlink" title="例"></a>例</h1><p>按钮已在对应的.ui文件中放置，命名为 <strong>CloseBtn</strong></p><p>头文件中声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FORGETPWDWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FORGETPWDWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForgetPwdWindow</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ForgetPwdWindow</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~ForgetPwdWindow();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_CloseBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ForgetPwdWindow *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// FORGETPWDWINDOW_H</span></span></span><br></pre></td></tr></table></figure><p>CPP文件实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"forgetpwdwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_forgetpwdwindow.h"</span></span></span><br><span class="line"></span><br><span class="line">ForgetPwdWindow::ForgetPwdWindow(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::ForgetPwdWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ForgetPwdWindow::~ForgetPwdWindow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ForgetPwdWindow::on_CloseBtn_clicked</span><span class="params">()</span>        <span class="comment">//按下关闭按钮</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    emit <span class="keyword">this</span>-&gt;ForgetPwdWindowBack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对于一些简单的事件判别，如点击按钮。无需写代码关联信号和槽函数。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;ta
      
    
    </summary>
    
    
      <category term="Qt 笔记" scheme="https://wuhongbin.github.io/categories/Qt-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Qt" scheme="https://wuhongbin.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt 实时显示系统时间</title>
    <link href="https://wuhongbin.github.io/2020/07/03/Qt%20%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
    <id>https://wuhongbin.github.io/2020/07/03/Qt%20%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/</id>
    <published>2020-07-03T04:10:43.000Z</published>
    <updated>2020-09-03T15:38:37.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们用一个label控件来实时显示系统时间，用到 QTimer 和 QDateTime 这个两个类。</p><h1 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h1><blockquote><p><strong>头文件：</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDateTime&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~MainWindow();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">timerUpdate</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><blockquote><p><strong>实现函数：</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mainwindow.h"</span></span></span><br><span class="line"> </span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    QTimer *timer = <span class="keyword">new</span> QTimer(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(timer,SIGNAL(timeout()),<span class="keyword">this</span>,SLOT(timerUpdate()));</span><br><span class="line">    timer-&gt;start(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::timerUpdate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QDateTime time = QDateTime::currentDateTime();</span><br><span class="line">    QString str = time.toString(<span class="string">"yyyy-MM-dd hh:mm:ss dddd"</span>);</span><br><span class="line">    ui-&gt;label-&gt;setText(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>运行效果如下：</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20180202135649452?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDAzODg5MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们用一个label控件来实时显示系统时间，用到 QTimer 和 QDateTime 这个两个类。&lt;/p&gt;
&lt;h1 id=&quot;正题&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Qt 笔记" scheme="https://wuhongbin.github.io/categories/Qt-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Qt" scheme="https://wuhongbin.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt 窗口阴影效果的实现</title>
    <link href="https://wuhongbin.github.io/2020/07/02/Qt%20%E7%AA%97%E5%8F%A3%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://wuhongbin.github.io/2020/07/02/Qt%20%E7%AA%97%E5%8F%A3%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-02T04:10:43.000Z</published>
    <updated>2020-09-03T15:36:08.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天正好搞一下窗口的阴影，发现一篇文章写的真是不错。毫不犹豫滴转过来了，感谢作者分享。</p><p>转自：<a href="http://blog.sina.com.cn/s/blog_a6fb6cc90101eoop.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_a6fb6cc90101eoop.html</a></p><h1 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h1><p>前面就窗口阴影已经写过一篇博客，使用九宫格的思路实现的，在我看来，凡是用程序能实现的尽量不要使用图片代替（在保证效率的前提下），今天再次分享关于我的一些小见解！</p><p>  先看效果：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20140507161202265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcm9iZXJ0a3Vu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20140507161214687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcm9iZXJ0a3Vu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>窗口阴影任意调节，包括阴影像素、是否圆角等。直接上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DropShadowWidget::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPainterPath path;</span><br><span class="line">    path.setFillRule(Qt::WindingFill);</span><br><span class="line">    path.addRect(<span class="number">10</span>, <span class="number">10</span>, <span class="keyword">this</span>-&gt;<span class="built_in">width</span>()<span class="number">-20</span>, <span class="keyword">this</span>-&gt;<span class="built_in">height</span>()<span class="number">-20</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.setRenderHint(QPainter::Antialiasing, <span class="literal">true</span>);</span><br><span class="line">    painter.fillPath(path, QBrush(Qt::white));</span><br><span class="line"> </span><br><span class="line">    <span class="function">QColor <span class="title">color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        QPainterPath path;</span><br><span class="line">        path.setFillRule(Qt::WindingFill);</span><br><span class="line">        path.addRect(<span class="number">10</span>-i, <span class="number">10</span>-i, <span class="keyword">this</span>-&gt;<span class="built_in">width</span>()-(<span class="number">10</span>-i)*<span class="number">2</span>, <span class="keyword">this</span>-&gt;<span class="built_in">height</span>()-(<span class="number">10</span>-i)*<span class="number">2</span>);</span><br><span class="line">        color.setAlpha(<span class="number">150</span> - qSqrt(i)*<span class="number">50</span>);</span><br><span class="line">        painter.setPen(color);</span><br><span class="line">        painter.drawPath(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得加上这行代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAttribute(Qt::WA_TranslucentBackground);</span><br></pre></td></tr></table></figure><p>保证不被绘制上的部分透明，关于这行代码在一些Qt版本中会有副作用。</p><p>比如：最小化后窗体子组件失去焦点等问题。具体可以看Qt的这个Bug</p><p>（Widget  with Qt::FramelessWindowHint and Qt::WA_TranslucentBackground stops painting after minimize/restore）</p><p>一直使用的是VS集成Qt5插件（非OpenGL版本），一直存在这个问题，寻找各方面资料无果（真的很久，搞不夸张的说大半年应该是有的）。最后改换OpenGL版本的居然好了。。。问题的解决方式太过于诡异，真让人哭笑不得。在此记过，希望对后来人有帮助。</p><h2 id="为子部件添加阴影"><a href="#为子部件添加阴影" class="headerlink" title="为子部件添加阴影"></a>为子部件添加阴影</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QGraphicsDropShadowEffect *shadow_effect = <span class="keyword">new</span> QGraphicsDropShadowEffect(<span class="keyword">this</span>);</span><br><span class="line">shadow_effect-&gt;setOffset(<span class="number">-5</span>, <span class="number">5</span>);</span><br><span class="line">shadow_effect-&gt;setColor(Qt::gray);</span><br><span class="line">shadow_effect-&gt;setBlurRadius(<span class="number">8</span>);</span><br><span class="line">network_group_box-&gt;setGraphicsEffect(shadow_effect);</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20140507161403171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcm9iZXJ0a3Vu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天正好搞一下窗口的阴影，发现一篇文章写的真是不错。毫不犹豫滴转过来了，感谢作者分享。&lt;/p&gt;
&lt;p&gt;转自：&lt;a href=&quot;http://
      
    
    </summary>
    
    
      <category term="Qt 笔记" scheme="https://wuhongbin.github.io/categories/Qt-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Qt" scheme="https://wuhongbin.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt 隐藏标题栏后实现窗口拖动、设置窗口透明</title>
    <link href="https://wuhongbin.github.io/2020/07/02/Qt%20%E9%9A%90%E8%97%8F%E6%A0%87%E9%A2%98%E6%A0%8F%E5%90%8E%E5%AE%9E%E7%8E%B0%E7%AA%97%E5%8F%A3%E6%8B%96%E5%8A%A8%E3%80%81%E8%AE%BE%E7%BD%AE%E7%AA%97%E5%8F%A3%E9%80%8F%E6%98%8E/"/>
    <id>https://wuhongbin.github.io/2020/07/02/Qt%20%E9%9A%90%E8%97%8F%E6%A0%87%E9%A2%98%E6%A0%8F%E5%90%8E%E5%AE%9E%E7%8E%B0%E7%AA%97%E5%8F%A3%E6%8B%96%E5%8A%A8%E3%80%81%E8%AE%BE%E7%BD%AE%E7%AA%97%E5%8F%A3%E9%80%8F%E6%98%8E/</id>
    <published>2020-07-02T02:10:43.000Z</published>
    <updated>2020-09-03T15:05:55.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="隐藏标题栏"><a href="#隐藏标题栏" class="headerlink" title="隐藏标题栏"></a>隐藏标题栏</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setWindowFlags(Qt::CustomizeWindowHint);</span><br><span class="line">setWindowFlags(Qt::FramelessWindowHint);</span><br></pre></td></tr></table></figure><blockquote><p><strong>两个函数都可以去掉标题栏，区别是第一个可以鼠标缩放窗口, 第二个不可以</strong>         </p></blockquote><h1 id="隐藏标题栏、任务栏显示、窗口置顶"><a href="#隐藏标题栏、任务栏显示、窗口置顶" class="headerlink" title="隐藏标题栏、任务栏显示、窗口置顶"></a>隐藏标题栏、任务栏显示、窗口置顶</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setWindowFlags(Qt::FramelessWindowHint | Qt::Tool | Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure><blockquote><p><strong>温馨提示：以上代码均在窗口构造函数中使用</strong></p></blockquote><h1 id="隐藏标题栏后实现拖动"><a href="#隐藏标题栏后实现拖动" class="headerlink" title="隐藏标题栏后实现拖动"></a>隐藏标题栏后实现拖动</h1><p>隐藏标题栏后窗体是无法拖动的，这个时候就需要重写mousePressEvent、mouseMoveEvent和mouseReleaseEvent。</p><h2 id="添加成员变量"><a href="#添加成员变量" class="headerlink" title="添加成员变量"></a>添加成员变量</h2><p>添加一个成员变量QPoint</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPoint m_lastPos;</span><br></pre></td></tr></table></figure><h2 id="重写鼠标点击事件"><a href="#重写鼠标点击事件" class="headerlink" title="重写鼠标点击事件"></a>重写鼠标点击事件</h2><p>重写mousePressEvent、mouseMoveEvent和mouseReleaseEvent函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_lastPos = event-&gt;globalPos();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;x() + (event-&gt;globalX() - m_lastPos.x()),</span><br><span class="line">               <span class="keyword">this</span>-&gt;y() + (event-&gt;globalY() - m_lastPos.y()));</span><br><span class="line">    m_lastPos = event-&gt;globalPos();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 其实这里的mouseReleaseEvent函数可以不用重写</span></span><br><span class="line">    m_lastPos = event-&gt;globalPos();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><blockquote><p><strong>解决鼠标按下其他控件后移动鼠标到QWidget区域时界面移动的问题</strong></p></blockquote><p>按照上面的写法，会出现一个问题，就是在按住当前界面上的控件时，当按住这个动作一直存在并将鼠标从控件移动到QWidget的区域时，界面也会跟着移动，并且这样的移动时直接跳了过去，这样就很不完美，而且在界面很小，控件很多的情况下，拖动显得非常卡顿，所以我们就需要在mouse事件中添加一个判断，判断当前鼠标按下是否是处于QWidget所在的区域。</p><p>修改很简单，在自定义QWidget界面类中添加一个bool型变量isPressedWidget。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isPressedWidget;</span><br></pre></td></tr></table></figure><p>然后在mousePressEvent、mouseMoveEvent和mouseReleaseEvent三个函数中各添上一行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_lastPos = event-&gt;globalPos();</span><br><span class="line">    isPressedWidget = <span class="literal">true</span>; <span class="comment">// 当前鼠标按下的即是QWidget而非界面上布局的其它控件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isPressedWidget) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;x() + (event-&gt;globalX() - m_lastPos.x()),</span><br><span class="line">                   <span class="keyword">this</span>-&gt;y() + (event-&gt;globalY() - m_lastPos.y()));</span><br><span class="line">        m_lastPos = event-&gt;globalPos();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 其实这里的mouseReleaseEvent函数可以不用重写</span></span><br><span class="line">    m_lastPos = event-&gt;globalPos();</span><br><span class="line">    isPressedWidget = <span class="literal">false</span>; <span class="comment">// 鼠标松开时，置为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设置窗口透明"><a href="#设置窗口透明" class="headerlink" title="设置窗口透明"></a>设置窗口透明</h1><p>在对窗体设置了背景图片，如果背景图片是不规则矩形，则在背景图片后，窗体会露出一部分很丑，这个时候可以将窗体的属性设为透明属性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAttribute(Qt::WA_TranslucentBackground);</span><br></pre></td></tr></table></figure><h1 id="设置窗体透明度"><a href="#设置窗体透明度" class="headerlink" title="设置窗体透明度"></a>设置窗体透明度</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setWindowOpacity(<span class="number">0.7</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;隐藏标题栏&quot;&gt;&lt;a href=&quot;#隐藏标题栏&quot; class=&quot;headerlink&quot; title=&quot;隐藏标题栏&quot;&gt;&lt;/a&gt;隐藏标题栏&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Qt 笔记" scheme="https://wuhongbin.github.io/categories/Qt-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Qt" scheme="https://wuhongbin.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>排序之外部排序 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/20/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/20/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-20T02:15:43.000Z</published>
    <updated>2020-08-14T07:18:41.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p><strong>外部排序</strong> 通常采用归并排序方法。<br>首先，根据缓冲区的大小将外存上含有n个记录的文件分成若干长度为h的子文件，依次读入内存并利用有限的内部排序算法对它们进行排序，并将排序后得到的有序子文件重新写回外村，通常称这些有序子文件为 <strong>归并段或顺串</strong><br>然后，对这些归并段进行逐趟归并，使归并段逐渐由小到大直至得到整个有序文件</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCB076.png" alt=""></p><h2 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h2><p><strong>外部排序的总时间 = 内部排序所需时间 + 外存信息读写时间 + 内部归并所需时间</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCBgcd.png" alt=""></p><h2 id="失败树"><a href="#失败树" class="headerlink" title="失败树"></a>失败树</h2><p><strong>S趟归并总共需要比较的次数:</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCrXkV.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCyK8U.png" alt=""></p><p><strong>失败树：</strong> 树形选择排序的一种变体,可视为一棵完全二叉树  </p><p>每个叶结点存放各归并段在归并过程中当前参加比较的记录,  </p><p>内部结点用来记忆左右子树中的“失败者胜利者向上继续  进行比较,直到根结点</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCyPgg.png" alt=""></p><h2 id="置换-选择排序"><a href="#置换-选择排序" class="headerlink" title="置换-选择排序"></a>置换-选择排序</h2><p>设初始待排序文件为F, 初始归并段文件为FO, 内存工作区为WA, 内存工作区可容纳w个记录。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ol><li>从待排序文件F输入w个记录到工作区WA;  </li><li>从内存工作区WA中选出其中关键字取最小值的记录,记为 MINIMAX;  </li><li>将MINIMAX记录输出到FO中; </li><li>若F未读完,则从F输入下一个记录到WA中; </li><li>从WA中所有MINIMAX关键字比记录的关键字大的记录中选出最小的关键字记录,作为新的 MINIMAX;  </li><li>重复3~5, 直到WA中选不出新的MINIMA记录位置, 由此得到一 个初始归并段,输出一个归并段的结束标志到FO中;  </li><li>重复2~6, 直到WA为空。由此得到全部初始归并段。</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dC2rSf.png" alt=""></p><h1 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCRe9P.png" alt=""></p><p><strong>归并树：</strong> 用来描述m归并,并只有度为0和度为m的结点的严格m叉树</p><p>设由置换选择排序得到9个初始归并段  其记录的长度依次为9, 30, 12, 18, 3, 17, 2, 6, 24</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCo1Mt.png" alt=""></p><blockquote><p><strong>总IO次数为2*WPL=484</strong><br><strong>大带权路径长度之和为归并过程中的总读记录数</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCoLJH.png" alt=""></p><blockquote><p><strong>当叶子节点数不够时,增加权值为0的结点用来构造哈夫曼树</strong></p></blockquote><h3 id="补充虚段个数"><a href="#补充虚段个数" class="headerlink" title="补充虚段个数"></a>补充虚段个数</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCTs1A.png" alt=""></p><p><strong>例子：</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dC7rUU.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;外部排序&lt;/strong&gt; 通常采用归并排序方法。&lt;br&gt;首先，根据缓冲区的大小将外存上含有n个记录的文件分
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="排序" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="外排序" scheme="https://wuhongbin.github.io/tags/%E5%A4%96%E6%8E%92%E5%BA%8F/"/>
    
      <category term="败者树" scheme="https://wuhongbin.github.io/tags/%E8%B4%A5%E8%80%85%E6%A0%91/"/>
    
      <category term="最佳归并树" scheme="https://wuhongbin.github.io/tags/%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91/"/>
    
      <category term="置换-选择排序" scheme="https://wuhongbin.github.io/tags/%E7%BD%AE%E6%8D%A2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序之内部排序算法的比较与应用 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/19/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%8E%E5%BA%94%E7%94%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/19/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%8E%E5%BA%94%E7%94%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-19T10:15:43.000Z</published>
    <updated>2020-08-13T10:22:23.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><blockquote><p><strong>时空复杂度</strong>    <strong>稳定性</strong>    <strong>一趟排序的特点</strong> </p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/13/dpmV0K.png" alt=""></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p><strong>考虑因素:</strong>  数目、元素大小、关键字结构及分布、稳定性、存储  结构、辅助空间等 </p><ol><li>若n较小时(n≤50),可采用直接插入排序 或 简单选择排序 ；若n较大时, 则采用快排、堆排或归并排序</li><li>若n很大, 记录关键字位数较少且可分解, 采用基数排序    </li><li>当文件的n个关键字随机分布是,任何借助于“比较”的排序,  至少需要O(nlog2n)的时间  </li><li>若初始基本有序,则采用直接插入或冒泡排序  </li><li>当记录元素比较大, 应避免大量移动的排序算法,尽量采用 链式存储</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;比较&quot;&gt;&lt;a href=&quot;#比较&quot; class=&quot;headerlink&quot; title=&quot;比较&quot;&gt;&lt;/a&gt;比较&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;时空复杂度&lt;/strong&gt;    &lt;strong&gt;稳定性&lt;/strong&gt;    &lt;strong
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="排序" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="内排序" scheme="https://wuhongbin.github.io/tags/%E5%86%85%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序之基数排序 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/19/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/19/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-19T09:15:43.000Z</published>
    <updated>2020-08-13T10:23:30.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><blockquote><p><strong>不基于比较</strong></p></blockquote><p>借助 “分配” 和 “收集” 两种操作对单逻辑关键字进行排序  分为最高位优先(MSD)和最低位优先(LSD)。<br>以r为基数的最低位优先基数排序的过程:</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/13/dpivP1.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/13/dpiX5R.png" alt=""></p><h1 id="分配和收集"><a href="#分配和收集" class="headerlink" title="分配和收集"></a>分配和收集</h1><p>在排序时使用r个队列Q0，Q1，…，Qr-1  </p><p><strong>分配:</strong> 开始时,把Q0，Q1，Qr-1各个队列置空, 然后依次考察每一个结点的关键字  </p><p>若a的关键字中k1=k,就把a放入队列Q当中  </p><p><strong>收集:</strong> 把Q0, Q1，…，Qr-1 各个队列中的结点依次收尾相接, 得到一个新的结点序列组成线性表  </p><blockquote><p><strong>d次分配收集后, 序列会排成有序的序列</strong></p></blockquote><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/13/dpkmk9.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p><strong>基数排序：</strong></p><p>时间复杂度(平均)：O (d(n+r))    </p><p>空间复杂度：O (r)</p><p>是一个  <strong>稳定</strong>  算法</p><p><strong>不基于比较</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本定义&quot;&gt;&lt;a href=&quot;#基本定义&quot; class=&quot;headerlink&quot; title=&quot;基本定义&quot;&gt;&lt;/a&gt;基本定义&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;不基于比较&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;借助 “分
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="排序" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="基数排序" scheme="https://wuhongbin.github.io/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序之归并排序 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/19/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/19/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-19T02:15:43.000Z</published>
    <updated>2020-08-13T10:25:04.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><p>​        归并排序( MergeSort)就是利用归并的思想实现的排序方法。它的原 理是假设初始序列有n个记录,则可以看成是n个有序的子序列, 每个子 序列的长度为1,然后两两归并, 得到 n/2 个长度为2或1的有序子序 列; 再两两归并，…，如此重复, 直至得到一个长度为n的有序序列为 止, 这种排序方法称为 <strong>2路归并排序</strong>。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/13/az2ld0.png" alt="">         </p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/13/az21oV.png" alt=""></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="合并两个有序线性表"><a href="#合并两个有序线性表" class="headerlink" title="合并两个有序线性表"></a>合并两个有序线性表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个辅助数组，下标0的位置不使用，所以n+1</span></span><br><span class="line">ElemType *B = (ElemType *)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"><span class="comment">//low 第一个表起始位置， mid 第一个表终止位置，high第二个表终止位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span>(k = low; k &lt;= high; k++)</span><br><span class="line">        B[k] = A[k];</span><br><span class="line">    <span class="keyword">for</span>(i = low, j = mid +<span class="number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i] &lt;= B[j])</span><br><span class="line">            A[k] = B[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        A[k++] = B[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high)</span><br><span class="line">        A[k++] = B[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序代码"><a href="#归并排序代码" class="headerlink" title="归并排序代码"></a>归并排序代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">        MergeSort(A, low, mid);</span><br><span class="line">        MergeSort(A, mid+<span class="number">1</span>, high);</span><br><span class="line">        Merge(A, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p><strong>归并排序：</strong></p><p>时间复杂度(平均)：O (nlog2n)    </p><p>空间复杂度：O (n)</p><p>是一个  <strong>稳定</strong>  算法</p><p>适用于<strong>顺序存储</strong> 和 <strong>链式存储</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本定义&quot;&gt;&lt;a href=&quot;#基本定义&quot; class=&quot;headerlink&quot; title=&quot;基本定义&quot;&gt;&lt;/a&gt;基本定义&lt;/h1&gt;&lt;p&gt;​        归并排序( MergeSort)就是利用归并的思想实现的排序方法。它的原 理是假设初始序列有n个记录,则可
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="排序" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="归并排序" scheme="https://wuhongbin.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序之选择排序 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/18/%E6%8E%92%E5%BA%8F%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/18/%E6%8E%92%E5%BA%8F%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-18T12:15:43.000Z</published>
    <updated>2020-08-13T05:40:19.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>每一趟在后面n-i+1(i=1,2，…，n-1)个待排序元素中选取关键字最小的元素, 作为有序子序列的第i个元素, 直到n-1做完, 待排序元素只剩下1个。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/aveFKO.png" alt=""></p><blockquote><p><strong>一趟排序会将一个元素放置在最终的位置上</strong></p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++)</span><br><span class="line"><span class="keyword">if</span>(A[j] &lt; A[<span class="built_in">min</span>])</span><br><span class="line"><span class="built_in">min</span> = j;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">min</span> != i)</span><br><span class="line">&#123;</span><br><span class="line">temp = A[i];</span><br><span class="line">A[i] = A[<span class="built_in">min</span>];</span><br><span class="line">A[<span class="built_in">min</span>] = temp;                         </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/avniHe.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>直接选择排序：</strong></p><p>时间复杂度(平均)：O (n2)    时间复杂度与初始序列无关</p><p>空间复杂度：O (1)</p><p>是一个  <strong>不稳定</strong>  算法</p><p>适用于<strong>顺序存储</strong> 和 <strong>链式存储</strong></p></blockquote><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>n个关键字序列L[1…n] 称为 <strong>堆</strong>, 当且仅当该序列满足:  </p><ol><li><p>若 L(i) ≤ L(2i) 且 L(i) ≤ L(2i+1), 则称该堆为 <strong>小根堆</strong></p></li><li><p>若L(i) ≥ L(2i)且L(i) ≥ L(2i+1), 则称该堆为 <strong>大根堆</strong> (1 ≤ i ≤ [n/2]取下界)</p></li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/av1Cut.png" alt=""></p><p>在排序过程中将L[1…n]视为一棵完全二叉树的顺序存储结构</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/av1Kuq.png" alt=""></p><h2 id="用二叉树表示小根堆-大根堆"><a href="#用二叉树表示小根堆-大根堆" class="headerlink" title="用二叉树表示小根堆 || 大根堆"></a>用二叉树表示小根堆 || 大根堆</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/av3Pz9.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/av3CRJ.png" alt=""></p><h2 id="堆的初始化-大根堆"><a href="#堆的初始化-大根堆" class="headerlink" title="堆的初始化 (大根堆)"></a>堆的初始化 (大根堆)</h2><p>对所有具有双亲结点含义编号从大到小 ( [n/2]取下界 ~ 1)做出如下调整:  </p><ol><li>若孩子结点皆小于双亲结点,则该结点的调整结束  </li><li>若存在孩子结点大于双亲结点,则将最大的孩子结点与双亲结点交换,并对该孩子结点进行1)、2),直到出现1)或到叶  节点为止</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/avGxdP.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/avGzIf.png" alt=""></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        AdjustDown(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(ElemType A[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];<span class="comment">//暂存，下标0处之前没有值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*k; i &lt;= len; i*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; len &amp;&amp; A[i] &lt; A[i+<span class="number">1</span>])<span class="comment">//判断左孩子和右孩子哪个大</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i])</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//不需要调整</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[k] = A[i];<span class="comment">//将调整节点值赋值给双亲节点</span></span><br><span class="line">            k = i;<span class="comment">//将调整节点下标赋给k</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];<span class="comment">//将双亲节点值赋值给调整节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>初始建堆 O (n)</strong></p></blockquote><blockquote><p><strong>堆排序 不断地输出堆顶元素, 并向下调整</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BuildMaxHeap(A, len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(A[i], A[<span class="number">1</span>]);</span><br><span class="line">        AdjustDown(A, <span class="number">1</span>, i<span class="number">-1</span>)</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>堆排序：</strong></p><p>时间复杂度(平均)：O (nlog2n)    </p><p>空间复杂度：O (1)</p><p>是一个  <strong>不稳定</strong>  算法</p><p>适用于<strong>顺序存储</strong> （<strong>链式存储</strong>）</p></blockquote><h2 id="堆的插入"><a href="#堆的插入" class="headerlink" title="堆的插入"></a>堆的插入</h2><p>将新结点放置在末端然后进行向上调整</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/avdj1K.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/avdXp6.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustUp</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];</span><br><span class="line">    <span class="keyword">int</span> i = k/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; A[i] &lt; A[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        A[k] = A[i];</span><br><span class="line">        k = i;</span><br><span class="line">        i = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;直接选择排序&quot;&gt;&lt;a href=&quot;#直接选择排序&quot; class=&quot;headerlink&quot; title=&quot;直接选择排序&quot;&gt;&lt;/a&gt;直接选择排序&lt;/h1&gt;&lt;h2 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="排序" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="直接选择排序" scheme="https://wuhongbin.github.io/tags/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆排序" scheme="https://wuhongbin.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序之交换排序 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/17/%E6%8E%92%E5%BA%8F%E4%B9%8B%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/17/%E6%8E%92%E5%BA%8F%E4%B9%8B%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-17T12:15:43.000Z</published>
    <updated>2020-08-12T05:19:38.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>​        假设待排序表长为n，从后往前（从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]&gt;A[i])，则交换他们直到序列比较结束。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajdEuQ.png" alt=""></p><blockquote><p><strong>一次冒泡会将一个元素放置到它最终的位置上</strong></p><p><strong>表长为n，排序完成需要进行n-1次冒泡</strong></p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">//可以减少无用冒泡次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt; i; j--)</span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>].key &gt; A[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = A[j<span class="number">-1</span>];</span><br><span class="line">                A[j<span class="number">-1</span>] = A[j];</span><br><span class="line">                A[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>加入bool变量作用：</strong></p><p>当序列中有逆序存在时，flag = true；说明本次冒泡交换完成；</p><p>如果 flag = false，即序列中没有逆序，说明序列已排序完成，结束循环，停止之后的无效冒泡；</p><p><strong>如果没有加入bool变量：</strong></p><p>无论序列是否排序完成，都会执行完指定次数的冒泡，其中很可能有许多次无效的冒泡。浪费大量时间。</p></blockquote><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajB1v8.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajBlgf.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>冒泡排序：</strong></p><p>时间复杂度(平均)：O (n2)</p><p>空间复杂度：O (1)</p><p>是一个  <strong>稳定</strong>  算法</p><p>适用于<strong>顺序存储</strong> 和 <strong>链式存储</strong></p></blockquote><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h2><p>​        在待排序表L[1 … n]中任取一个元素pivot作为基准, 通过一趟排序将待排序表划分为具有如下特点的两部分:</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajDySP.png" alt=""></p><blockquote><p><strong>一次划分会将一个元素 pivot 放置到它最终的位置上</strong></p></blockquote><h2 id="划分-Partition-思路"><a href="#划分-Partition-思路" class="headerlink" title="划分(Partition)思路"></a>划分(Partition)思路</h2><p>​        初始化标记low为划分部分第一个元素的位置，high为最后一个元素的位置，然后不断地移动两标记并交换元素：</p><ol><li>high向前移动找到第一个比pivot小的元素</li><li>low向后移动找到第一个比pivot大的元素</li><li>交换当前两个位置的元素</li><li>继续移动标记，执行1，2，3的过程，直到 low大于等于high为止。</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElemType pivot = A[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot)<span class="comment">//找一个比基准值小的数</span></span><br><span class="line">            high--;</span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt;= pivot)<span class="comment">//找一个比基准值大的数</span></span><br><span class="line">            low++;</span><br><span class="line">        A[high] = A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotpos = Partition(A, low, high);</span><br><span class="line">        QuickSort(A, low, pivotpos<span class="number">-1</span>);</span><br><span class="line">        QuickSort(A, pivotpos+<span class="number">1</span>, high); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajR2IU.png" alt=""></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajfu1H.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajfKcd.png" alt=""></p><blockquote><p><strong>冒泡排序：</strong></p><p>时间复杂度(平均)：O (nlog2n)</p><p>空间复杂度：O (log2n)</p><p>是一个  <strong>不稳定</strong>  算法</p><p>适用于<strong>顺序存储</strong> （<strong>链式存储</strong>）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;h2 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="排序" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="冒泡排序" scheme="https://wuhongbin.github.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="https://wuhongbin.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序之插入排序 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/16/%E6%8E%92%E5%BA%8F%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/16/%E6%8E%92%E5%BA%8F%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-16T12:15:43.000Z</published>
    <updated>2020-08-11T12:47:38.361Z</updated>
    
    <content type="html"><![CDATA[<p><strong>插入排序：</strong>每次将一个待排序的序列插入到一个前面已排好序的子序列当中</p><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aOwJRU.png" alt=""></p><p>初始L[1]是一个已经排好序的子序列  </p><p>对于元素L(i)(L(2)~L(n))插入到前面已经排好序的子序列当中  </p><ol><li>查找出L(i)在L[1…i-1]中的插入位置k</li><li>将L[k…i-1]中的所有元素全部后移一个位置</li><li>将L(i)复制到L(k)</li></ol><blockquote><p><strong>此算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，所以空间复杂度为O(1)</strong></p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void InsertSort(ElemType A[], int n)</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line">for(i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">A[0] &#x3D; A[i];  &#x2F;&#x2F;A[0]是哨兵，保存每次待插入的元素</span><br><span class="line">for(j &#x3D; i-1; A[0].key &lt; A[j]; j--)&#x2F;&#x2F;从后往前比较</span><br><span class="line">A[j + 1] &#x3D; A[j];</span><br><span class="line">A[j + 1] &#x3D; A[0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aOrbhq.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aOrHNn.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p><strong>直接插入排序：</strong></p><p>时间复杂度(平均)：O (n2)</p><p>空间复杂度：O (1)</p><p>是一个  <strong>稳定</strong>  算法</p><p>适用于<strong>顺序存储</strong> 和 <strong>链式存储</strong></p></blockquote><h1 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h1><h2 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h2><p>在 <strong>直接插入排序</strong> 中 ，利用的是 <strong>顺序查找</strong> 的思想。</p><p>在 <strong>直接插入排序</strong> 中加入了 <strong>折半查找</strong> 的思想 就是 <strong>折半插入排序</strong></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++)<span class="comment">//O(n)</span></span><br><span class="line">&#123;</span><br><span class="line">A[<span class="number">0</span>] = A[i];  <span class="comment">//A[0]是哨兵，保存每次待插入的元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//折半查找部分</span></span><br><span class="line">        low = <span class="number">1</span>; high = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)<span class="comment">//O(log2n)</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid].key &gt; A[<span class="number">0</span>].key)</span><br><span class="line">                high = mid <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//移动O(n)</span></span><br><span class="line"><span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= high+<span class="number">1</span>; j--)<span class="comment">//从后往前比较 high+1是找到的插入元素的位置</span></span><br><span class="line">A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">        </span><br><span class="line">A[high + <span class="number">1</span>] = A[<span class="number">0</span>];<span class="comment">// high+1 也可以表示成low</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入位置分析"><a href="#插入位置分析" class="headerlink" title="插入位置分析"></a>插入位置分析</h2><ol><li>A[mid].key &gt; A[0].key <strong>条件成立：</strong>一开始high，low，mid均指向同一位置；若条件成立，则 high = mid -1，也就是原来的元素大于插入的元素，所以原来元素应该后移，插入的元素放在原来元素mid的位置，也就是 high+1的位置 （或者说是low的位置）</li><li>A[mid].key &gt; A[0].key <strong>条件不成立：</strong> 一开始high，low，mid均指向同一位置；若条件不成立，则 low = mid + 1，也就是原来的元素小于插入的元素，原来元素位置不变，插入的元素放在原来元素后一位置，也是 high+1的位置 （或者说是low的位置）</li><li>综上，可确定插入位置均是 high+1 或者 low 的位置</li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>折半插入排序：</strong></p><p>时间复杂度(平均)：O (n2)</p><p>空间复杂度：O (1)</p><p>是一个  <strong>稳定</strong>  算法</p><p>仅仅适用于<strong>顺序存储</strong></p></blockquote><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>先将排序表分割成d个形如l[i, i+d, i+2, … ，i+kd的“特殊”子表, 分别进行直接插入排序, 当整个表中的元素已呈“基本有序时”, 再对全体记录进行一次直接插入排序<br><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aO4nQs.png" alt="">    </p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aO4GYF.png" alt=""></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> dk = n/<span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk = dk/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = dk +<span class="number">1</span>; i &lt;= n; ++i)   <span class="comment">//各个组同时进行直接插入排序</span></span><br><span class="line">            <span class="keyword">if</span>(A[i].key &lt; A[i-dk].key)</span><br><span class="line">            &#123;</span><br><span class="line">                A[<span class="number">0</span>] = A[i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i-dk; j &gt; <span class="number">0</span> &amp;&amp; A[<span class="number">0</span>].key &lt; A[j].key; j-=dk)</span><br><span class="line">                    A[j+dk] = A[j];</span><br><span class="line">                A[j+dk] = A[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aOzN11.png" alt=""></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>希尔排序:</strong></p><p>时间复杂度(平均)：O (n2)</p><p>空间复杂度：O (1)</p><p>是一个  <strong>不稳定</strong>  算法</p><p>仅仅适用于<strong>顺序存储</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;插入排序：&lt;/strong&gt;每次将一个待排序的序列插入到一个前面已排好序的子序列当中&lt;/p&gt;
&lt;h1 id=&quot;直接插入排序&quot;&gt;&lt;a href=&quot;#直接插入排序&quot; class=&quot;headerlink&quot; title=&quot;直接插入排序&quot;&gt;&lt;/a&gt;直接插入排序&lt;/h1
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="排序" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="直接插入排序" scheme="https://wuhongbin.github.io/tags/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="折半插入排序" scheme="https://wuhongbin.github.io/tags/%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="希尔排序" scheme="https://wuhongbin.github.io/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序的基本概念 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/16/%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/16/%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-16T11:15:43.000Z</published>
    <updated>2020-08-11T09:59:17.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><p><strong>排序：</strong>重新排列表中的元素,使表中的元素满足按关键字递增或递减   </p><p><strong>输入：</strong>n个记录R1, R2,R 3, …, Rn, 对应关键字k1, k2, k3, …, kn  </p><p><strong>输出：</strong>输入序列的重新排列R1’, R2’, R3’, …, Rn’, k1’ &lt;= k2’ &lt;= … &lt;= kn’ (其中 &lt;= 可以换成其他有比较含义的符号)</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aON48e.png" alt=""></p><h1 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h1><p>若待排序表中有两个元素R和R,其对应的关键字k=k,且在排序前Ri  在Rj前面,若使用某排序算法后,R仍然在Rj前面。则称这个排序算法是稳定的,否则称排序算法不稳定。</p><blockquote><p><strong>算法的稳定性是算法的性质,并 不能衡量一个算法的优劣</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aOUurR.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aOUnM9.png" alt=""></p><h1 id="内部排序和外部排序"><a href="#内部排序和外部排序" class="headerlink" title="内部排序和外部排序"></a>内部排序和外部排序</h1><p><strong>内部排序：</strong> 指在排序期间元素全部存放在内存中的排序    </p><p><strong>外部排序：</strong> 指在排序期间元素无法全部同时存放在内存中,必须在排序  的过程中根据要求不断地在内、外存之间进行移动</p><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aOaKSg.png" alt=""></p><blockquote><p><strong>时空复杂度决定内部排序算法的性能</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本定义&quot;&gt;&lt;a href=&quot;#基本定义&quot; class=&quot;headerlink&quot; title=&quot;基本定义&quot;&gt;&lt;/a&gt;基本定义&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;排序：&lt;/strong&gt;重新排列表中的元素,使表中的元素满足按关键字递增或递减   &lt;/p&gt;
&lt;p&gt;&lt;str
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="排序" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>查找之哈希表 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/15/%E6%9F%A5%E6%89%BE%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/15/%E6%9F%A5%E6%89%BE%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-15T07:15:50.000Z</published>
    <updated>2020-09-02T14:28:02.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>散列函数：</strong> 一个把查找表中的关键字映射成该关键字对应的地址的函数。</p><p><strong>散列表：</strong>   也称哈希表，根据关键字而直接进行访问的数据结构。他建立了关键字与存储地址之间的一种直接映射关系。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/abRRmD.png" alt=""></p><h1 id="构造散列函数"><a href="#构造散列函数" class="headerlink" title="构造散列函数"></a>构造散列函数</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ol><li>散列函数的定义域必须包含全部需要存储的关键字,而值域的范围则依赖于  散列表的大小或地址范围。</li><li>散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中,从而  减少冲突的发生。  </li><li>散列函数应尽量简单,能够在较短时间内计算出任一关键字对应的散列地址。</li></ol><h2 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h2><p><strong>定义：</strong> 直接取关键字的某个线性函数值为散列地址。<br>            Hash(key)=a*key + b,  其中a,b为常数</p><p><strong>优点：</strong>方法简单，不会产生冲突</p><p><strong>缺点：</strong> 若关键字分部不连续，则会造成空间浪费</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/abIpOP.png" alt=""></p><h2 id="除留取余法-重要"><a href="#除留取余法-重要" class="headerlink" title="除留取余法 (重要)"></a>除留取余法 (重要)</h2><p>Hash(key)=key%p<br>假定散列表表长为m，取一个不大于m但最接近或等于m的质数p</p><blockquote><p><strong>选好p是关键，可以减少冲突的可能</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aboOxA.png" alt=""></p><h2 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h2><blockquote><p><strong>适用于关键字已知的集合,若更换关键字则需要重新构造散列函数。</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/abTiGQ.png" alt=""></p><p>利用图中红色圈住区域计算散列地址</p><h2 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h2><p>这种方法取关键字的平方值的中间几位作为散列地址 </p><blockquote><p><strong>适用于关键字的每位取值不均匀或均小于散列地址所需要的位数</strong>  </p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/ab7AYD.png" alt=""></p><h2 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h2><p>将关键字分割成位数相同的几部分,然后取这几部分的叠加和作为散列地址</p><blockquote><p><strong>适用于关键字的位数多,而且关键字中的每位上数字分布大致均匀</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/ab7Efe.png" alt=""></p><h1 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h1><blockquote><p><strong>问题：冲突不可能绝对避免, 那如何处理冲突？？</strong><br><strong>答案：为产生冲突的关键字寻找下一个“空”的Hash地址</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/ab7BkT.png" alt=""></p><h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><p><strong>开放定址法：</strong>是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。<br>H=（H(key)+di)%m, i = 0,1,2..…k(k &lt;= m-1); m为散列表表长，di为增量序列</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aq9e5d.png" alt=""></p><h3 id="计算增量序列"><a href="#计算增量序列" class="headerlink" title="计算增量序列"></a>计算增量序列</h3><h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><blockquote><p> <strong>例:</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aq9qJA.png" alt=""></p><blockquote><p><strong>缺点：</strong> 造成堆积现象，大大降低查找效率</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aq9LRI.png" alt=""></p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aqChfs.png" alt=""></p><h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>由于在开放定址法中，如果删除某个元素后，就会破坏查找某个元素的查找序列。所以有了拉链法</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aqiaRA.png" alt=""></p><h3 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h3><p><strong>拉链法：</strong>是指把所有同义词存放在一个线性链表中，这个线性链表由地址唯一标识，即散列表中每个单元存放该链表头指针。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aqaALq.png" alt=""></p><blockquote><p><strong>拉链法适用于经常进行插入和删除的情况</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aqaDOI.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先，初始化: Addr = hash(key)</p><ol><li>检测查找表中地址为Addr的位置上是否有记录, 若无记录, 则返回查找失败; 若有记录,则比较它与key值, 若相等则返回成功, 否则执行步骤 2</li><li>用给定的处理冲突方法计算“下一散列地址,把Addr置为此地址, 转入步骤 1</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aqdUH0.png" alt=""></p><h1 id="查找效率"><a href="#查找效率" class="headerlink" title="查找效率"></a>查找效率</h1><p>查找效率取决于 散列函数、处理冲突的方法和填裝因子      </p><p><strong>填装因子：</strong> 一般记为a,表示表的装满程度</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aqdOVP.png" alt=""></p><blockquote><p><strong>散列表的平均查找长度依赖于散列表的填装因子</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;散列函数：&lt;/strong&gt; 一个把查找表中的关键字映射成该关键字对应的地址的函数。&lt;/p&gt;
&lt;p&gt;&lt;str
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="查找" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="哈希表" scheme="https://wuhongbin.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="散列表" scheme="https://wuhongbin.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>查找之B+树 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/14/%E6%9F%A5%E6%89%BE%E4%B9%8BB+%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/14/%E6%9F%A5%E6%89%BE%E4%B9%8BB+%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-14T07:15:50.000Z</published>
    <updated>2020-08-09T10:30:01.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><p>一棵m阶B+树满足如下特性:  </p><ol><li>每个分支结点最多有m棵子树子结点)</li><li>若根结点不是终端结点,则至少有两棵子树</li><li>除根结点外的所有非叶结点至少有 (m/2)取上界 棵子树, <strong>子树和关键字个数相等</strong></li><li>所有叶结点包含全部关键字及指向相应记录的指针,叶结点中将关键字按大小顺序排列, 并且相邻结点按大小顺序连接起来</li><li>所有分支结点(可视为索引的索引)中仅包含他的各个子结点(下一级索引块)中关键字的最大值及指向其子结点的指针</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aT7t8s.png" alt=""></p><h1 id="B-树-VS-B树"><a href="#B-树-VS-B树" class="headerlink" title="B+树 VS B树"></a>B+树 VS B树</h1><ol><li><p>在B+树中, 具有η个关键字的结点值含有n棵子树,即每个关键字对应一棵子树</p><p>在B树中, 具有n个关键字的结点含有n+1棵子树</p></li><li><p>在B+树中,叶结点包含信息, 所有非叶结点仅起索引作用, 非叶结点中的毎个索引项只含有对应子树的最大关键字和指向该子树关键字的指针, 不 含有该关键字对应记录的存储地址</p></li><li><p>在B+树中, 叶结点包含全部关键字,即在非叶结点中出现的关键字也会 出现在叶结点中棵子树</p><p>在B树中,叶结点包含的关键字和其他结点包含的关键字是不重复的</p></li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aTHLY4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本定义&quot;&gt;&lt;a href=&quot;#基本定义&quot; class=&quot;headerlink&quot; title=&quot;基本定义&quot;&gt;&lt;/a&gt;基本定义&lt;/h1&gt;&lt;p&gt;一棵m阶B+树满足如下特性:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个分支结点最多有m棵子树子结点)&lt;/li&gt;
&lt;li&gt;若根结点不
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="查找" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="B+树" scheme="https://wuhongbin.github.io/tags/B-%E6%A0%91/"/>
    
      <category term="多路平衡查找树" scheme="https://wuhongbin.github.io/tags/%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>查找之B树 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/14/%E6%9F%A5%E6%89%BE%E4%B9%8BB%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/14/%E6%9F%A5%E6%89%BE%E4%B9%8BB%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-14T02:15:50.000Z</published>
    <updated>2020-08-09T10:45:13.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><p><strong>B树</strong> 又称多路平衡查找树，B树中所有结点的 <strong>孩子结点数</strong> 的最大值称为B树的阶。</p><blockquote><p>一棵m阶B树或为空树，或为满足如下特性的m叉树：</p><ol><li><p>树中每个结点至多有m棵子树（即至多含有m-1个关键字）</p></li><li><p>若根结点不是终端结点，则至少有两棵子树</p></li><li><p>除根结点外的所有非叶结点至少有 <strong>m/2 (取上界)</strong>  棵子树（即 *<em>m/2 (取上界) *</em>- 1 个关键字）</p></li><li><p>非叶结点的结构：</p><p>   <img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/ao7tfA.png" alt="">                     </p></li><li><p>所有的叶结点都出现在同一层次上，并不带任何信息</p></li></ol></blockquote><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aoHuNQ.png" alt=""></p><p>首先，这棵B树中 <strong>孩子结点数的最大值是3</strong>，所以这棵树的 <strong>阶为3</strong>，即为 <strong>3阶B树</strong></p><ol><li><p>由图中可看出，树中每个结点至多有3棵子树（即至多含有2个关键字）</p></li><li><p>例如 10，15，20 结点，不是终端结点，至少有两棵子树</p></li><li><p>m/2 (取上界)  = 3/2(取上界) = <strong>2</strong>，m/2 (取上界) - 1  =  3/2(取上界) - 1 = <strong>1</strong>，满足要求</p></li><li><p>Ki :  18 &lt; 33,   Pi 和 Pi-1 ：12 &lt; 18 , 48 &gt; 33 ,  满足要求</p></li><li><p>如图，最下面的叶结点均在一层，且不带任何信息</p></li></ol><h1 id="问题探究"><a href="#问题探究" class="headerlink" title="问题探究"></a>问题探究</h1><blockquote><p><strong>n个关键字,阶数为m,高度为h的B ? ? ?</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aoxTA0.png" alt=""></p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aTFEJ1.png" alt=""></p><blockquote><ol><li>在B树中找结点             <strong>磁盘</strong></li><li>在结点中找关键字        <strong>内存</strong></li></ol></blockquote><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ol><li><p><strong>定位</strong></p><p>查找插入该关键字的位置，即最底层中的某个非叶子结点（规定一定是插入在最底层的某个非叶子结点内）</p></li><li><p><strong>插入</strong><br>若插入后，不破会m阶B树的定义，即插入后结点关键字个数在属于区间[m/2 -1, m-1]，则直接插入；<br>若插入后，关键字数量大于m-1，则对插入后的结点进行分裂操作；<br>分裂：<br>插入后的结点中间位置（[m/2]）关键字并入父结点中，<br>中间结点左侧结点留在原先的结点中，右侧结点放入新的节点中，<br>若并入父节点后，父结点关键字数量超出范围，继续想上分裂，直到符合要求为止。</p></li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aT27X4.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aT2bnJ.png" alt=""></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aTRm38.png" alt=""></p><h3 id="终端节点删除"><a href="#终端节点删除" class="headerlink" title="终端节点删除"></a>终端节点删除</h3><ol><li><strong>直接删除</strong></li></ol><p>若被删除关键字所在结点关键字总数 &gt;「m/2 ] - 1 , 表明删除后仍满足B树定义, 直接删除 </p><ol start="2"><li><strong>兄弟够借</strong></li></ol><p>若被删除关键字所在结点关键字总数 =「m/2 ] - 1 ,且与此结点邻近的兄弟结点的关键字个数&gt;「m/2] , 则需要从兄弟结点借一个关键字,此过程需要调整该结点、双亲结点和兄弟结点的关键字</p><ol start="3"><li><strong>兄弟不够借</strong></li></ol><p>若被删除关键字所在结点关键字总数=「m/2] - 1, 且与此结点邻近的兄弟结点的关键字个数=「m/2] -1, 则删除关键字, 并与一个不够借的兄弟结点和双亲结点中两兄弟子树中间的关键字合并。合并后若双亲结点因减少一个结点导致不符合定义, 则继续执行2、3步骤 。</p><blockquote><p><strong>下面请仔细观察图（想着上方步骤）</strong></p></blockquote><blockquote><p><strong>直接删除</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aThfrF.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aThhb4.png" alt=""></p><blockquote><p><strong>兄弟够借</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aThWKU.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aTh5VJ.png" alt=""></p><blockquote><p><strong>兄弟不够借</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aT4Eqg.png" alt=""></p><h3 id="非终端节点删除"><a href="#非终端节点删除" class="headerlink" title="非终端节点删除"></a>非终端节点删除</h3><ol><li>若小于k的子树中关键字个数 &gt; [m/2] -1, 则找出k的前驱值k,并用k来取代k,再递归地删除k即可。  </li><li>若大于k的子树中关键字个数 &gt; [m/2] -1, 则找出k的后继值k,并用k来取代k,再递归地删除k即可。    </li><li>若前后两子树关键字个数均为「m/2] -1, 则直接两个子结点合并,  然后删除k即可。</li></ol><blockquote><p><strong>前驱值：</strong>结点左边子树的最右边的结点的关键字</p><p><strong>后驱值：</strong>结点右边子树的最左边的结点的关键字</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aTTkfs.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aTTZ60.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aTTEpn.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本定义&quot;&gt;&lt;a href=&quot;#基本定义&quot; class=&quot;headerlink&quot; title=&quot;基本定义&quot;&gt;&lt;/a&gt;基本定义&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;B树&lt;/strong&gt; 又称多路平衡查找树，B树中所有结点的 &lt;strong&gt;孩子结点数&lt;/strong&gt; 
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="查找" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="多路平衡查找树" scheme="https://wuhongbin.github.io/tags/%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    
      <category term="B树" scheme="https://wuhongbin.github.io/tags/B%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>查找之平衡二叉树 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/13/%E6%9F%A5%E6%89%BE%E4%B9%8B%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/13/%E6%9F%A5%E6%89%BE%E4%B9%8B%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-13T11:15:50.000Z</published>
    <updated>2020-08-08T11:11:04.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>AVL</strong>, 任意结点的平衡因子的 <strong>绝对值不超过一</strong>。<strong>平衡二叉树是一种二叉排序树</strong><br><strong>平衡因子：</strong>    左子树高度 - 右子树高度</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a50559.png" alt=""></p><blockquote><p><strong>根节点平衡因子是2，不是平衡二叉树</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a504UJ.png" alt=""></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><blockquote><p><strong>高度为h的最小平衡二叉树的结点数Nh</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5BzeU.png" alt=""></p><h1 id="平衡二叉树的判断"><a href="#平衡二叉树的判断" class="headerlink" title="平衡二叉树的判断"></a>平衡二叉树的判断</h1><blockquote><p><strong>利用递归的后序遍历过程:</strong></p><ol><li><p>判断左子树是一棵平衡二叉树  </p></li><li><p>判断右子树是一棵平衡二叉树 </p></li><li><p>判断以该结点为根的二叉树为平衡二叉树</p></li></ol></blockquote><blockquote><p><strong>判断条件</strong></p><p>若左子树和右子树均为平衡二叉树且左子树与右子树高度差的绝对值小于等于1,  则平衡。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5rJ3R.png" alt=""></p><blockquote><p>b 代表平衡性，1表示平衡，0表示不平衡</p><p>h 代表树的高度</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Judge_AVL</span><span class="params">(BiTree bt, <span class="keyword">int</span> &amp;balance, <span class="keyword">int</span> &amp;h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bl = <span class="number">0</span>, br = <span class="number">0</span>, hl = <span class="number">0</span>, hr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        h = <span class="number">0</span>;</span><br><span class="line">        balance = <span class="number">1</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        h = <span class="number">1</span>;</span><br><span class="line">        balance = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Judge_AVL(bt-&gt;lchild, bl, hl);</span><br><span class="line">        Judge_AVL(bt-&gt;rchild, br, hr);</span><br><span class="line">        <span class="keyword">if</span>(hl &gt; hr)</span><br><span class="line">            h = hl + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            h = hr + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(h1 - hr) &lt; <span class="number">2</span> &amp;&amp; bl == <span class="number">1</span> &amp;&amp; br == <span class="number">1</span>)</span><br><span class="line">            balance = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            balance = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><blockquote><p><strong>先插入后调整</strong></p><p>每次调整 <strong>最小不平衡子树</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aI3dX9.png" alt=""></p><h2 id="LL平衡旋转-右单旋转"><a href="#LL平衡旋转-右单旋转" class="headerlink" title="LL平衡旋转(右单旋转)"></a>LL平衡旋转(右单旋转)</h2><p>*<em>原因: *</em> 在结点A的左孩子的左子树上插入了新结点 </p><p>*<em>调整方法: *</em> 右旋操作: 将A的左孩子B代替A,将A结点称为B的右子树根结点,而B的原右子树则作为A的左子树</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aIGHyQ.png" alt=""></p><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aIJq1O.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aIJLcD.png" alt=""></p><h2 id="RR平衡旋转-左单旋转"><a href="#RR平衡旋转-左单旋转" class="headerlink" title="RR平衡旋转(左单旋转)"></a>RR平衡旋转(左单旋转)</h2><p><strong>原因：</strong>在结点A的右孩子的右子树上插入了新结点  </p><p><strong>调整方法：</strong> 左旋操作: 将A的右孩子B代替A, 将A结点称为B的左子树 根结点, 而B的原左子树则作为A的右子树。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aItiI1.png" alt=""></p><h3 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aItCZ9.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aItPaR.png" alt=""></p><h2 id="LR平衡旋转-先左后右双旋转"><a href="#LR平衡旋转-先左后右双旋转" class="headerlink" title="LR平衡旋转(先左后右双旋转)"></a>LR平衡旋转(先左后右双旋转)</h2><p><strong>原因：</strong>在结点A的左孩子的右子树上插入了新结点<br><strong>调整方法：</strong>先左旋后右旋操作：将A的左孩子B的右孩子结点C代替B，然后再将C结点向上代替A的位置。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aINC6S.png" alt=""></p><h3 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aIN9l8.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aINpSf.png" alt=""></p><h2 id="RL平衡旋转-先右后左旋转"><a href="#RL平衡旋转-先右后左旋转" class="headerlink" title="RL平衡旋转(先右后左旋转)"></a>RL平衡旋转(先右后左旋转)</h2><p><strong>原因：</strong>在结点A的右孩子的左子树上插入了新结点  </p><p><strong>调整方法：</strong> 先右旋后左旋操作:将A的右孩子B的左孩子结点C代替B,  然后再将C结点向上代替A的位置。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aINTNn.png" alt=""></p><h3 id="例-3"><a href="#例-3" class="headerlink" title="例"></a>例</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aINoAs.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aIN57j.png" alt=""></p><blockquote><p><strong>再次提醒：以上4种方式的前提是 最小不平衡子树</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;AVL&lt;/strong&gt;, 任意结点的平衡因子的 &lt;strong&gt;绝对值不超过一&lt;/strong&gt;。&lt;strong&gt;平衡二叉
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="查找" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="平衡二叉树" scheme="https://wuhongbin.github.io/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>查找之二叉排序树 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/13/%E6%9F%A5%E6%89%BE%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/13/%E6%9F%A5%E6%89%BE%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-13T09:15:50.000Z</published>
    <updated>2020-08-08T11:12:00.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>二叉排序树 <strong>BST</strong>，也称 <strong>二又查找树</strong> 。<br>二叉排序树或者为空树，或者为非空树，当为非空树时有如下特点：</p><ol><li><p>若左子树非空，则左子树上所有结点关键字值 <strong>均小于</strong> 根结点的关键字。</p></li><li><p>若右子树排空，则右子树上所有结点关键字值 <strong>均大于</strong> 根结点的关键字。</p></li><li><p>左、右子树本身也分别是一棵二叉排序树。</p></li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a4zcO1.png" alt=""></p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉树非空时，查找根结点，若相等则查找成功；</p><p>若不等，则当小于根结点值时，查找左子树；当大于根结点的值时，查找右子树。</p><p>当查找到叶节点仍没查找到相应的值，则查找失败。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5pIsA.png" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BST_search</span><span class="params">(BiTree T, Elemrype key, BSTNode * &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//传入三个参数  二叉排序树， 查找值， 记录当前结点的双亲系结点指针</span></span><br><span class="line">    p = <span class="literal">NULL</span>；</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span> &amp;&amp; key != T-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        p = T;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; T-&gt;data)</span><br><span class="line">           T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> T;<span class="comment">//返回查找结点的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度为 O (h) ，h为二叉排序树的高度</p></blockquote><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>若二叉排序树为空, 则直接插入结点;</p><p>若二叉排序树非空, 当值小于根结点时,插入左子树; 当值大于根结点时, 插入右子树;</p><p>当值等于根结点时不进行插入。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BiTree &amp;T, KeyType k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)   <span class="comment">//为空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        T-&gt;key = k;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchlid = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k = T-&gt;key)    <span class="comment">//等于时</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-&gt;key)   <span class="comment">//非空小于</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;lchild, k);</span><br><span class="line">    <span class="keyword">else</span>   <span class="comment">//非空大于</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;rchild, k);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造二排序树"><a href="#构造二排序树" class="headerlink" title="构造二排序树"></a>构造二排序树</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>读入一个元素并建立结点, 若二叉树为空将其作为根结点；</p><p>若二叉排序树非空, 当值小于根结点时,插入左子树; 当值大于根结点时,插入右子树;</p><p>当值等于根结点时不进行插入。</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_BST</span><span class="params">(BiTree &amp;T, KeyType str[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     T = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">     &#123;</span><br><span class="line">         BST_Insert(T, str[i]);</span><br><span class="line">         i++;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5e1Hg.png" alt=""></p><blockquote><p><strong>如果元素的值相同，但是顺序不同，构造出的二叉排序树也是不同的</strong></p></blockquote><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><blockquote><p><strong>若被删除结点z是叶结点, 则直接删除;</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5mVqU.png" alt=""></p><blockquote><p><strong>若被删除结点z只有一棵子树,则让z的子树成为z父结点的子树, 代替z结点。</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5mQR1.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5mlxx.png" alt=""></p><blockquote><p><strong>若被删除结点z有两棵子树,则让z的中序序列直接后继代替z,并删去直接后继结点。</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5mrsf.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5mDQP.png" alt=""></p><h1 id="问题探究"><a href="#问题探究" class="headerlink" title="问题探究"></a>问题探究</h1><blockquote><p><strong>思考：在二叉排序树中删除并插入某节点, 得到的二叉排序树是否与原来相同？？？</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5n4tH.png" alt=""></p><p><strong>结论：可能相同也可能不同</strong></p><h1 id="查找效率"><a href="#查找效率" class="headerlink" title="查找效率"></a>查找效率</h1><p><strong>平均查找长度（ASL）取决于树的高度</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5un3R.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;二叉排序树 &lt;strong&gt;BST&lt;/strong&gt;，也称 &lt;strong&gt;二又查找树&lt;/strong&gt; 。&lt;br&gt;二叉排序树或者为空树，或
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="查找" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="二叉排序树" scheme="https://wuhongbin.github.io/tags/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>查找之分块查找 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/12/%E6%9F%A5%E6%89%BE%E4%B9%8B%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/12/%E6%9F%A5%E6%89%BE%E4%B9%8B%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-12T07:15:50.000Z</published>
    <updated>2020-07-31T10:32:06.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>分块查找：</strong>又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/al8Cfe.png" alt=""></p><h1 id="如何分块"><a href="#如何分块" class="headerlink" title="如何分块"></a>如何分块</h1><ol><li>将查找表分为若干子块。块内的元素可以无序，但块间是有序的，即对于所有块有第i块的最大关键字小于第i+1块的所有记录的关键字。</li><li>建立索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。</li></ol><blockquote><p><strong>块内无序块间有序</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/alGHM9.png" alt=""></p><h1 id="如何查找"><a href="#如何查找" class="headerlink" title="如何查找"></a>如何查找</h1><ol><li>在索引表中确定待查记录所在的块,可以 <strong>顺序查找或折半查找</strong> 索引表。  </li><li>在块内进行 <strong>顺序查找</strong></li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/alGHM9.png" alt=""></p><p>分块查找的平均查找长度为 <strong>索引查找(LI)和块内查找(LS)之和</strong>。  </p><p>设长度为n的查找表均匀分为b块,每块有s个记录</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/alYxjH.png" alt=""></p><blockquote><p>若块内和块间均采用 <strong>顺序查找</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/altpDA.png" alt=""></p><blockquote><p>若块内采用顺序查找，块间均采用 <strong>折半查找</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/altSud.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;分块查找：&lt;/strong&gt;又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="查找" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="分块查找" scheme="https://wuhongbin.github.io/tags/%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>查找之折半查找 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/06/11/%E6%9F%A5%E6%89%BE%E4%B9%8B%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/06/11/%E6%9F%A5%E6%89%BE%E4%B9%8B%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-11T11:15:50.000Z</published>
    <updated>2020-07-31T08:27:47.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>折半查找：</strong>又称二分查找，仅适用于 <strong>有序的顺序表</strong></p><h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><ol><li><p>首先将给定值key与表中中间位置元素的关键字比较,  </p></li><li><p>若相等,则返回该元素的位置;  </p></li><li><p>若不等,则在前半部分或者是后半部分进行查找。 </p></li></ol><blockquote><p>查找序列升序时,  </p><p>若key小于中间元素,则查找前半部分  </p><p>若key大于中间元素,则查找后半部分。  </p></blockquote><ol start="4"><li>重复该过程,直到找到查找的元素为止;或查找失败。</li></ol><h1 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(SeqList L, ElemType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> low=<span class="number">0</span>, high=L.TableLen<span class="number">-1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">    mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.elem[mid] == key)  </span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid] &gt; key)</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">            Low = mid + <span class="number">1</span>;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>折半查找的时间复杂度为 O(log2n)</strong></p></blockquote><h1 id="判定树"><a href="#判定树" class="headerlink" title="判定树"></a>判定树</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQ0Hc8.png" alt=""></p><blockquote><p>若该判定树是 <strong>满二叉树</strong> 时，</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQ0xNn.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQBkB4.png" alt=""></p></blockquote><blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQB3HH.png" alt=""></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;折半查找：&lt;/strong&gt;又称二分查找，仅适用于 &lt;strong&gt;有序的顺序表&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="查找" scheme="https://wuhongbin.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="折半查找" scheme="https://wuhongbin.github.io/tags/%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
</feed>
