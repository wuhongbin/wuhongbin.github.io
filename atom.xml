<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>时光如水の总是无言</title>
  
  <subtitle>wuhongbin&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuhongbin.github.io/"/>
  <updated>2020-05-21T06:22:38.857Z</updated>
  <id>https://wuhongbin.github.io/</id>
  
  <author>
    <name>时光如水の总是无言</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>哈夫曼树 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/20/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/20/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-20T04:46:43.000Z</published>
    <updated>2020-05-21T06:22:38.857Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下 哈夫曼树知识点…</p><a id="more"></a><h2 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h2><p>设二叉树具有n个带权值的叶节点，那么从根节点到各个叶节点的路径长度与相应节点权值的乘积的和，叫做二叉树的 <strong><font color=red>带权路径长度</font></strong>。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHXvHe.png" alt=""></p><p> <strong><font color=red>权：</font></strong> 权代表的是叶子结点的数据信息,是具体的值。也就是结点所储存的值</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHjYE4.png" alt=""></p><p>具有最小带权路径长度的二叉树称为 <strong><font color=red>哈夫曼树 (也称最优数)</font></strong> 。</p><p>相同的叶节点构造出不同的二叉树</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHjX2q.md.png" alt=""></p><h2 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h2><p>构造哈夫曼树的 <strong><font color=red>原则：</font></strong></p><p>① 权值越大的叶节点越靠近根节点</p><p>② 权值越小的叶节点越远离根节点</p><p>构造哈夫曼树的 <strong><font color=red>过程：</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHvMIH.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHxoNQ.md.png" alt=""></p><p><strong><font color=red>哈夫曼树的特点：</font></strong> <strong>n1 = 0</strong></p><p><strong>n = n0 + n1 + n2  =  n0 + n2  =  2n0 - 1</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YttzLR.md.png" alt=""></p><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>规定哈夫曼树中的 <strong><font color=red>左分支为0，右分支为1</font></strong> ，则从根节点到每个节点所经过的分支对应的0和1组成的序列便为该节点对应字符的编码。这样的编码称为 <strong><font color=red>哈夫曼编码</font></strong>。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/Ybp961.md.png" alt=""></p><p>在一组字符的哈夫曼编码中，不可能出现一个字符的哈夫曼编码是另一个字符哈夫曼编码的 <strong><font color=red>前缀</font></strong>。</p><p>例如，有4个字符的编码如下：100,  001,  0，1</p><p>这是哈夫曼编码吗？显然是错误的，因为0是001的前缀，不可能。</p><p>所以哈夫曼编码也称为 <strong><font color=red>前缀编码</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/Ybpc9J.md.png" alt=""></p><p>分析：选 <strong>D</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/Ybpb3d.md.png" alt=""></p><p>分析：选 <strong>A</strong>。哈夫曼树一定是二叉树，但不一定是完全二叉树。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下 哈夫曼树知识点…&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="哈夫曼树" scheme="https://wuhongbin.github.io/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>线索二叉树 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/20/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/20/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-20T02:46:43.000Z</published>
    <updated>2020-05-21T09:08:09.328Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下 线索二叉树知识点…</p><a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>对于具有n个节点的二叉树，采用二叉链存储时，每个节点有两个指针域，总共有 <strong>2n</strong> 个指针域。</p><p>其中只有 n-1 个节点被有效指针指向，即有 <strong>n-1</strong> 个非空指针域。</p><p>所以共有 2n - (n-1) = <strong>n+1</strong> 个空链域。</p><p><strong><font color=green>解释：</font></strong> <strong>除根节点</strong> （根节点没有指针指向）外，每个节点都有且仅有一个指向自己的指针，所以N个节点的二叉树，需要N-1个指针域，则空指针域有N+1个。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>① 采用某种方法遍历二叉树的结果是一个节点的 <strong><font color=red>线性序列</font></strong> 。</p><p>② <strong><font color=red>修改空链域</font></strong> 改为存放指向节点的前趋和后继节点的地址。</p><p>③ 这样的指向该线性序列中的 “ 前趋 ” 和 “ 后继 ” 的指针，称作 <strong><font color=red>线索 (thread)</font></strong> 。</p><p>④ 创建线索的过程称为 <strong><font color=red>线索化</font></strong> 。</p><p>⑤ <strong><font color=red>线索化的</font></strong> 二叉树称为 线索二叉树。</p><p>⑥ 显然线索二叉树与采用的遍历方法相关，有 <strong><font color=red>先序线索二叉树、中序线索二叉树和后序线索二叉树</font></strong>。</p><p>⑦ 线索二叉树的目的是提高 <strong><font color=red>该遍历过程</font></strong> 的效率。</p><h2 id="设计线索二叉树"><a href="#设计线索二叉树" class="headerlink" title="设计线索二叉树"></a>设计线索二叉树</h2><p>在节点的存储结构上增加 <strong><font color=red>两个标志位</font></strong> 来区分这两种情况：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHB8it.png" alt=""></p><p>这样，每个节点的存储结构如下：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHBYz8.png" alt=""></p><p>为了方便算法设计，在线索二叉树中再增加 <strong><font color=red>一个头节点</font></strong> 。</p><p>线索化二叉树中节点的类型定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;           <span class="comment">//节点数据域</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;          <span class="comment">//增加的线索标记</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">lchild</span>;</span>    <span class="comment">//左孩子或者线索指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">rchild</span>;</span>    <span class="comment">//右孩子或者线索指针    </span></span><br><span class="line">&#125;TBTNode;      <span class="comment">//线索树节点类型定义</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHrD2V.md.png" alt=""></p><h2 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h2><p>建立某种次序的线索化二叉树过程：</p><p>(1) 以该遍历方法遍历一棵二叉树。</p><p>(2) 在遍历的过程中，检查当前访问节点的左、右指针域是否为空：</p><p>​        ① 如果左指针域为空，将它改为指向前趋节点的线索；</p><p>​        ② 如果右指针域为空，将它改为指向后继节点的线索。</p><p>下面以 <strong><font color=red>中序线索二叉树</font></strong> 为例，设计建立线索二叉树的算法。</p><h3 id="建立中序线索二叉树的算法"><a href="#建立中序线索二叉树的算法" class="headerlink" title="建立中序线索二叉树的算法"></a>建立中序线索二叉树的算法</h3><p> ① <strong><font color=red>CreaThread(b)算法：</font></strong> 对以二叉链存储的二叉树b进行中序线索化，并返回线索化后头节点的指针root。</p><p>② <strong><font color=red>Thread(p)算法：</font></strong> 对以 *p 为根节点的二叉树子树的中序线索化。</p><p>在中序遍历中：</p><p>① p总是指向当前线索化的节点。</p><p>② pre 作为全局变量，指向刚刚访问过的节点。</p><p>③  ＊pre  是 ＊p 的中序前趋节点， ＊ p 是 ＊pre  的中序后继节点。</p><p>  <img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHcweU.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHgAmT.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">TBTNode * pre;      <span class="comment">//全局变量</span></span><br><span class="line"><span class="function">TBTNode * <span class="title">CreatThread</span><span class="params">(TBTNode * b)</span>      <span class="comment">//中序线索化二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TBTNode * root;</span><br><span class="line">    root = (TBTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TBTNode));  <span class="comment">//创建头节点</span></span><br><span class="line">    root-&gt;ltag = <span class="number">0</span>; </span><br><span class="line">    root-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    root-&gt;rchild = b;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        root-&gt;lchild = root;<span class="comment">//空二叉树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;lchild = b; </span><br><span class="line">        pre = root;<span class="comment">//pre是*p的前趋节点，供加加线索用</span></span><br><span class="line">        Thread(b);<span class="comment">//中序遍历线索化二叉树</span></span><br><span class="line">        pre-&gt;rchild = root;<span class="comment">//最后处理，加入指向头节点的线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        root-&gt;rchild = pre;<span class="comment">//头节点线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread</span><span class="params">(TBTNode *&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//中序遍历递归算法</span></span><br><span class="line">        Thread(p-&gt;lchild);<span class="comment">//左子树线索化</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)<span class="comment">//前趋线索化</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;lchild = pre;<span class="comment">//建立当前节点的前趋线索</span></span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;ltag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)<span class="comment">//后继线索化</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;rchild = p;<span class="comment">//建立前趋节点的前趋线索</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;rtag = <span class="number">0</span>;</span><br><span class="line">        pre = p; </span><br><span class="line">        Thread(p-&gt;rchild);<span class="comment">//递归调用右子树线索化 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历线索化二叉树"><a href="#遍历线索化二叉树" class="headerlink" title="遍历线索化二叉树"></a>遍历线索化二叉树</h2><p>遍历某种次序的线索二叉树，就是从该次序下的 <strong><font color=red>开始节点</font></strong> 出发，反复找到该节点在该次序下的后继节点，直到头节点。</p><p>以中序线索二叉树为例，开始节点时根节点的最左下节点。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YH78Fx.md.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在中序线索二叉树中中序遍历的过程:</span><br><span class="line">p指向根节点;</span><br><span class="line">while p ≠ root 时循环</span><br><span class="line">&#123;</span><br><span class="line">找开始节点 *p;</span><br><span class="line">访问 *p 节点;</span><br><span class="line">while(*p 节点有右线索)</span><br><span class="line">一直访问下去;</span><br><span class="line">    p 转向右孩子节点;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHHN40.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThInOrder</span><span class="params">(TBTNode * tb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TBTNode * p = tb-&gt;lchild;<span class="comment">//p指向根节点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=tb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">            p = p-&gt;lchild;<span class="comment">//找开始节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);<span class="comment">//访问开始节点</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rtag == <span class="number">1</span> &amp;&amp; p-&gt;rchild != tb)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>优点：</font></strong> 中序遍历算法既没有递归也没有用栈，空间效率得到提高。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下 线索二叉树知识点…&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="线索二叉树" scheme="https://wuhongbin.github.io/tags/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的构造 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-19T02:46:43.000Z</published>
    <updated>2020-05-19T15:06:22.208Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下 二叉树的构造知识点…</p><a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>同一棵而二叉树（假设每个节点值唯一）具有  <strong><font color=blue>唯一</font></strong>的先序序列、中序序列、后序序列。</p><p>但 <strong><font color=blue>不同的二叉树</font></strong> 可能具有相同的先序序列，中序序列或后序序列。</p><p><strong>例如：</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4TXsP.md.png" alt=""></p><blockquote><p><strong><font color=blue>结论：</font></strong></p><p>① 给定一棵二叉树（假设每个节点值唯一）的先序、中序和后序序列可以唯一构造（确定）出该二叉树。</p><p>② 仅由先序、中序或后序序列中的 <strong>一种</strong>，无法唯一构造出该二叉树。</p></blockquote><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p><strong>那么问题来了？如果给定先序、中序和后序序列中任意两个，是否可以唯一构造出该二叉树呢？</strong></p><blockquote><p><strong><font color=blue>答案：</font></strong></p><p>① 同时给定一棵二叉树的 <strong><font color=green>先序序列和中序序列 </font></strong> 就能唯一确定这棵二叉树</p><p>② 同时给定一棵二叉树的 <strong><font color=green>中序序列和后序序列 </font></strong> 就能唯一确定这棵二叉树</p></blockquote><h3 id="定理1："><a href="#定理1：" class="headerlink" title="定理1："></a><strong><font color=red>定理1：</font></strong></h3><p>任何n（N&gt;0）个不同节点的二叉树，都可以由它的<strong>中序序列和先序序列</strong>唯一确定。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4HUBV.md.png" alt=""></p><p><strong>例如：</strong> 已知先序序列为 ABDGCEF ，中序序列为 DGBAECF，则构造二叉树的过程如下所示。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4bra8.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YIG9mD.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由上述定理得到以下算法</span></span><br><span class="line"><span class="function">BTNOde * <span class="title">CreateBT1</span><span class="params">(<span class="keyword">char</span> * pre, <span class="keyword">char</span> * in, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * s; <span class="keyword">char</span> * p; <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    s = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));  <span class="comment">//创建根节点</span></span><br><span class="line">    s-&gt;data = *pre;</span><br><span class="line">    <span class="keyword">for</span>(p = in;p &lt; in+n;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*p == *pre)<span class="comment">//在in中找为*pre的位置k</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = p-in;</span><br><span class="line">s-&gt;lchild = CreateBT1(pre+<span class="number">1</span>, in, k);<span class="comment">//构造左子树</span></span><br><span class="line">    s-&gt;rchild = CreateBT1(pre+k+<span class="number">1</span>, p+<span class="number">1</span>, n-k<span class="number">-1</span>);<span class="comment">//构造右子树</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定理2："><a href="#定理2：" class="headerlink" title="定理2："></a><strong><font color=red>定理2：</font></strong></h3><p>任何n（N&gt;0）个不同节点的二叉树，都可以由它的<strong>中序序列和后序序列</strong>唯一确定。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4qrO1.md.png" alt=""></p><p><strong>例如：</strong> 已知中序序列为 DGBAECF，后序序列 GDBEFCA 则构造二叉树的过程如下所示。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4qqk8.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YI0lAf.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由上述定理得到以下算法</span></span><br><span class="line"><span class="function">BTNOde * <span class="title">CreateBT2</span><span class="params">(<span class="keyword">char</span> * post, <span class="keyword">char</span> * in, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * b; <span class="keyword">char</span> r, * p; <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    r = *(post+n<span class="number">-1</span>);                       <span class="comment">//根节点值</span></span><br><span class="line">    b = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));  <span class="comment">//创建二叉树根节点*b</span></span><br><span class="line">    b-&gt;data = r;</span><br><span class="line">    <span class="keyword">for</span>(p = in;p &lt; in+n;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*p == r)<span class="comment">//在in中找为*pre的位置k</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = p-in;<span class="comment">//k为根节点在in中的下标</span></span><br><span class="line">s-&gt;lchild = CreateBT2(post, in, k);<span class="comment">//构造左子树</span></span><br><span class="line">    s-&gt;rchild = CreateBT2(post + k, p+<span class="number">1</span>, n-k<span class="number">-1</span>);<span class="comment">//构造右子树</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题1："><a href="#例题1：" class="headerlink" title="例题1："></a><strong><font color=red>例题1：</font></strong></h3><p>设计一个算法将二叉树的<strong>顺序存储结构</strong>转化成<strong>二叉链存储结构</strong>。</p><p><strong><font color=green>解：</font></strong>设二叉树的顺序存储结构为a，由f(a,1)返回创建的二叉链存储结构的根节点指针b</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YI50VU.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode * <span class="title">trans1</span><span class="params">(SqBTree a, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * b;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[i] == <span class="string">'#'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//当节点不存在时返回NULL</span></span><br><span class="line">    b = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));   <span class="comment">//创建根节点</span></span><br><span class="line">    b -&gt; data = a[i];</span><br><span class="line">    b -&gt; lchild = trans1(a, <span class="number">2</span>*i);     <span class="comment">//递归创建左子树</span></span><br><span class="line">    b -&gt; rchild = trans1(a, <span class="number">2</span>*i+<span class="number">1</span>);     <span class="comment">//递归创建左子树</span></span><br><span class="line">    <span class="keyword">return</span>(b);<span class="comment">//返回根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此算法是先序遍历的思路</span></span><br></pre></td></tr></table></figure><h3 id="例题2："><a href="#例题2：" class="headerlink" title="例题2："></a><strong><font color=red>例题2：</font></strong></h3><p>设计一个算法将二叉树的<strong>二叉链存储结构</strong>转化成<strong>顺序存储结构</strong>。</p><p><strong><font color=green>解：</font></strong>f(b，a，i)：由二叉链b创建a[i]为根节点的顺序存储结构a</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YIoA1A.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">trans2</span><span class="params">(BTNode * b, SqBTree a, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = b -&gt; data;<span class="comment">//创建根节点</span></span><br><span class="line">        trans2(b -&gt; lchild, a, <span class="number">2</span>*i);     <span class="comment">//递归创建左子树</span></span><br><span class="line">        trans2(b -&gt; rchild, a, <span class="number">2</span>*i+<span class="number">1</span>);     <span class="comment">//递归创建左子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此算法是先序遍历的思路</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下 二叉树的构造知识点…&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="构造二叉树" scheme="https://wuhongbin.github.io/tags/%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux(deepin-uos)系统安装后无法使用无线网问题解决</title>
    <link href="https://wuhongbin.github.io/2020/05/16/Linux(deepin-uos)%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E6%97%A0%E7%BA%BF%E7%BD%91%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://wuhongbin.github.io/2020/05/16/Linux(deepin-uos)%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E6%97%A0%E7%BA%BF%E7%BD%91%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</id>
    <published>2020-05-16T03:10:43.000Z</published>
    <updated>2020-05-16T05:21:38.174Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了Linux系统安装后无法使用无线网问题…</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人笔记本电脑型号已测试，联想Y7000，安装deepin/uos后，100%遇到此问题。</p><h2 id="问题检查"><a href="#问题检查" class="headerlink" title="问题检查"></a>问题检查</h2><p><strong>驱动问题</strong></p><p>如果通过命令<code>ifconfig</code>没能发现类似<code>wlp7s0</code>的无线网络，可以判断是这个问题。</p><p><strong>无线网卡被hard blocked的问题</strong></p><p>运行命令<code>rfkill list all</code>，出现如下结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:ideapad_wlan: Wireless LAN </span><br><span class="line">Soft blocked: no </span><br><span class="line">Hard blocked:yes </span><br><span class="line">1:ideapad_bluetooth: Bluetooth </span><br><span class="line">Soft blocked: no </span><br><span class="line">Hard blocked: yes </span><br><span class="line">2:phy0: Wireless LAN </span><br><span class="line">Soft blocked: no </span><br><span class="line">Hard blocked:no </span><br><span class="line">3:hci0: Bluetooth </span><br><span class="line">Soft blocked: yes </span><br><span class="line">Hard blocked: no</span><br></pre></td></tr></table></figure><p>可以看到，优先级前的ideapad_wlan的Hard blocked 默认为yes，即deepin默认关闭了硬件wifi开关，而联想拯救者Y7000的wifi只有软件开关，没有硬件开关的启动，所以引起了wifi无法开启的问题。</p><p><strong>网卡驱动的电源管理问题</strong></p><p>使用命令<code>dmesg</code>查看日志，如果出现</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/16/Y68IZ8.png" alt=""></p><p>那很可能就是这个问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>驱动问题解决方案：</strong></p><p>如果确认是驱动问题，则可以尝试通过重装驱动解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install --reinstall firmware-realtek</span><br></pre></td></tr></table></figure><p><strong>无线网卡被hard blocked解决方案：</strong></p><p>禁用 *<em>ideapad_laptop *</em>驱动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;blacklist ideapad_laptop&quot; | sudo tee &#x2F;etc&#x2F;modprobe.d&#x2F;backlist-ideapad.conf</span><br></pre></td></tr></table></figure><p><strong>网卡驱动的电源管理问题解决方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;options r8822be aspm&#x3D;0&quot; | sudo tee &#x2F;etc&#x2F;modprobe.d&#x2F;r8822be.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了Linux系统安装后无法使用无线网问题…&lt;/p&gt;
    
    </summary>
    
    
      <category term="L i n u x" scheme="https://wuhongbin.github.io/categories/L-i-n-u-x/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统分区方案</title>
    <link href="https://wuhongbin.github.io/2020/05/16/Linux%E7%B3%BB%E7%BB%9F%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88/"/>
    <id>https://wuhongbin.github.io/2020/05/16/Linux%E7%B3%BB%E7%BB%9F%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88/</id>
    <published>2020-05-16T03:10:43.000Z</published>
    <updated>2020-05-16T05:22:00.981Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了Linux系统系统分区方案…</p><a id="more"></a><h2 id="简单分区方案"><a href="#简单分区方案" class="headerlink" title="简单分区方案"></a>简单分区方案</h2><p>实际上，很多时候我们只需要分两个区：<code>/</code>和交换分区，日常使用基本不会有任何影响，甚至于交换分区对于现在的电脑来说都不是必要的，我们完全可以只分配一个根分区。linux只需要一个/根分区就可以正常运行。</p><h2 id="常用分区方案"><a href="#常用分区方案" class="headerlink" title="常用分区方案"></a>常用分区方案</h2><p>以使用 <strong>100G 空间</strong> 安装 linux 为例，各目录含义，请参考文章结尾附录。</p><table><thead><tr><th align="center">目录类型</th><th align="center">挂载点</th><th align="center">分区格式</th><th align="center">大小</th></tr></thead><tbody><tr><td align="center">根目录</td><td align="center">/</td><td align="center">ext4</td><td align="center">20-40G</td></tr><tr><td align="center">家目录</td><td align="center">/home</td><td align="center">ext4</td><td align="center">剩余所有空间</td></tr><tr><td align="center">交换分区</td><td align="center">swap</td><td align="center">无</td><td align="center">2G</td></tr></tbody></table><p><strong><font color=red>注意：</font></strong> 交换分区 无挂载点 分区格式选择交换分区（swap） 最大不建议超过真实内存大小，除非内存小于2G，你的内存大于4G，推荐2G即可，没必要有些人推荐的与内存相当。</p><h2 id="DIY分区方案"><a href="#DIY分区方案" class="headerlink" title="DIY分区方案"></a>DIY分区方案</h2><p>更高级的分区，我们就要了解一下自己电脑的使用场景。</p><p>linux的整体目录就是一个树状结构，根据文章结尾的附录一，我们会知道/分区下的各个目录存放的内容都是不一样的，所以他们的内容变化速度也会不一样。</p><p>了解了这些，试想一个场景，如果我们只分配一个/分区，内容增加速度快的目录，比如个人桌面系统的/home，服务器的/var目录可能会迅速占领大部分的存储容量，以至于当存储容量用尽时出现电脑无法开机的现象。</p><p>为了避免出现这样的情形，我们可以给电脑分区，然后将分区‘挂载’到根分区的指定目录，限制目录的大小，同时保护一些重要目录，比如/boot，这样，即便目录某个目录扩张很快，最终也只会占用我们分配的大小，不会影响到电脑的正常运行。所以第二种方法里，我们把/boot和/home单独分了出来，避免/分区的内容扩张影响到系统启动，同时，分配/home分区可以在电脑系统崩溃，重装系统时避免个人文件丢失，直接将分区挂载上去，个人的数据就不会丢失。</p><p>但是有的时候，我们要安装linux是给服务器安装的，这时，/home就不应该分配这么多空间了，因为对于个人电脑桌面系统，我们可能需要安装很多的软件、文件和视频音乐等，会导致/home目录变得十分臃肿，而其他目录相对来说比较小。不过对于服务器来说，更占用存储的地方可能集中在了/var目录，比如日志文件，比如web服务器的根目录，一般都在/var目录中，这时，我们就应该给/var目录分配更多的空间，保证服务器的正常运行。当然，如果你的服务器目录结构是自己组织的，你就要按照你自己电脑的情况来分析你的电脑该如何来选择分区。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><table><thead><tr><th align="center">目录名</th><th align="center">简介</th></tr></thead><tbody><tr><td align="center">swap</td><td align="center">类似于windows的虚拟内存文件</td></tr><tr><td align="center">/</td><td align="center">根目录，根目录下最好只有目录，文件放在目录下，不要放在根目录中。</td></tr><tr><td align="center">/boot</td><td align="center">包括操作系统的内核和启动过程需要用的文件</td></tr><tr><td align="center">/root</td><td align="center">超级管理员的家目录</td></tr><tr><td align="center">/home</td><td align="center">家目录，用来存放用户文件</td></tr><tr><td align="center">/etc</td><td align="center">大部分的配置文件默认都放在这里</td></tr><tr><td align="center">/dev</td><td align="center">Linux系统中，所有的硬件都以文件的形式放在这个目录中</td></tr><tr><td align="center">/lost+found</td><td align="center">突然停电或者非正常关机，存放临时文件</td></tr><tr><td align="center">/sbin</td><td align="center">管理员才能运行的一些程序</td></tr><tr><td align="center">/opt</td><td align="center">存储第三方软件的目录</td></tr><tr><td align="center">/proc</td><td align="center">存储进程相关的信息，用于方便的访问进程信息，伪文件系统，所有的内容都存储在内存中</td></tr><tr><td align="center">/mnt</td><td align="center">一般我们将手动挂载的分区放在这里（例如新加一款硬盘，可以挂载在这里）</td></tr><tr><td align="center">/media</td><td align="center">系统自动挂载的分区放在这里</td></tr><tr><td align="center">/lib</td><td align="center">用于存放库文件</td></tr><tr><td align="center">/usr</td><td align="center"></td></tr><tr><td align="center">/usr/lib</td><td align="center">同/lib</td></tr><tr><td align="center">/usr/sbin</td><td align="center">同/sbin</td></tr><tr><td align="center">/usr/local/bin</td><td align="center">系统实用程序</td></tr><tr><td align="center">/usr/local/sbin</td><td align="center">同/sbin</td></tr><tr><td align="center">/usr/local/lib</td><td align="center">同/lib</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了Linux系统系统分区方案…&lt;/p&gt;
    
    </summary>
    
    
      <category term="L i n u x" scheme="https://wuhongbin.github.io/categories/L-i-n-u-x/"/>
    
    
      <category term="Linux分区" scheme="https://wuhongbin.github.io/tags/Linux%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>彻底删除烦人的Linux系统引导项文件</title>
    <link href="https://wuhongbin.github.io/2020/05/16/%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E7%83%A6%E4%BA%BA%E7%9A%84Linux%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E9%A1%B9%E6%96%87%E4%BB%B6/"/>
    <id>https://wuhongbin.github.io/2020/05/16/%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E7%83%A6%E4%BA%BA%E7%9A%84Linux%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E9%A1%B9%E6%96%87%E4%BB%B6/</id>
    <published>2020-05-16T02:10:43.000Z</published>
    <updated>2020-05-16T05:22:25.974Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了彻底删除烦人的Linux系统引导项文件…</p><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在使用win10 + deepin的过程中，由于 deepin 系统安装失败/重装时，需要删除掉deepin系统引项。</p><p>常用的做法是在win10安装<strong>EasyUEFI</strong>,使用其中的 <strong>管理EFI启动项</strong> 来对deepin启动项进行删除，可能的原因是之前无意中将 deepin 的启动项文件损坏了，结果删除时总是显示无效的文件。但是明明deepin启动项仍然存在于BIOS启动项选项里面。意思就是它明明存在，但是你就是删不掉。</p><p>如果你在 win10安装<strong>EasyUEFI</strong> 删除引导无效，请看以下教程。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>使用快捷键 <code>win+x</code>，打开 <code>Windows PowerShell(管理员)(A)</code>，依次输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">diskpart         #打开diskpart</span><br><span class="line">list disk        #列出系统中拥有的磁盘，我笔记本上有两块磁盘，记得当时ubuntu启动项文件安装到了SSD所在的磁盘0中</span><br><span class="line">select disk 0    #选择EFI引导分区所在的磁盘，请根据实际情况选择</span><br><span class="line">list partition   #列出所选磁盘拥有的分区</span><br><span class="line">select partition 1    #选择EFI引导分区，类型为系统的分区，就是EFI引导分区</span><br><span class="line">assign letter&#x3D;p:      #为所选分区分配盘符，请分配空闲盘符</span><br><span class="line">exit                 # 退出</span><br><span class="line">taskkill &#x2F;im explorer.exe &#x2F;f   #关闭explorer</span><br><span class="line">explorer.exe     #再以管理员身份打开explorer</span><br></pre></td></tr></table></figure><p>此时，在<strong>我的电脑</strong>中会发现，新增加了一个磁盘分区p，但是直接双击打开仍然打不开，于是直接在刚才的PowerShell命令行中进行操作了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p:  #转到p磁盘</span><br><span class="line">ls  #查看p磁盘下的文件信息，正常的话会看见一个名为EFI的文件夹，回想上面在EasyUEFI中看到的ubuntu启动项的文件路径，ubuntu启动项文件就在这个EFI文件夹下面</span><br><span class="line">cd EFI  #进入EFI文件夹</span><br><span class="line">ls       #此时会看到一个名为ubuntu的文件夹，终于找到它了！同时还会看到一个名为Microsoft的文件夹，它应该就是win10系统的启动项文件</span><br><span class="line">cd ubuntu    #进入ubuntu文件夹</span><br><span class="line">ls       #查看有哪些启动项文件，这里会看见EasyUEFI&#x2F;文件路径中提到的shimx64.efi文件</span><br><span class="line">cd ..  #跳回EFI文件夹</span><br><span class="line">del ubuntu  #再将ubuntu文件夹整个删掉，斩草除根！</span><br><span class="line">ls      #此时会发现已经没有ubuntu文件夹了！</span><br></pre></td></tr></table></figure><p>自此，清理 ubuntu 启动项文件的工作就结束了,不用管刚才分配的 <strong>p盘符</strong>，关掉 PowerShell，关掉笔记本重启，重启后之前分配的p盘符会自动移除。</p><p><strong><font color=red>温馨提示：</font></strong>其他 Linux 系统只需找到对应名字的引导文件删除即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了彻底删除烦人的Linux系统引导项文件…&lt;/p&gt;
    
    </summary>
    
    
      <category term="L i n u x" scheme="https://wuhongbin.github.io/categories/L-i-n-u-x/"/>
    
    
      <category term="Linux引导" scheme="https://wuhongbin.github.io/tags/Linux%E5%BC%95%E5%AF%BC/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的遍历及其应用 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-13T09:46:43.000Z</published>
    <updated>2020-05-19T04:04:21.190Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下 二叉树的遍历及其应用知识点…</p><a id="more"></a><h2 id="二叉树遍历的概念"><a href="#二叉树遍历的概念" class="headerlink" title="二叉树遍历的概念"></a>二叉树遍历的概念</h2><p><strong><font color=red>二叉树的遍历</font></strong> 是指按照一定次序访问树中所有节点，并且 <strong><font color=red>每个节点仅被访问一次</font></strong> 的过程。</p><p>遍历是二叉树最基本的运算，是二叉树其他运算的基础。</p><p><strong>二叉树的组成：</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/Yd2JFf.png" alt=""></p><h3 id="1-先序遍历过程"><a href="#1-先序遍历过程" class="headerlink" title="1. 先序遍历过程"></a><strong><font color=red>1. 先序遍历过程</font></strong></h3><p>先序遍历NLR二叉树的过程是：</p><p>① 访问根节点;</p><p>② 先序遍历左子树;</p><p>③ 先序遍历右子树。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdR9tf.md.png" alt=""></p><h3 id="2-中序遍历过程"><a href="#2-中序遍历过程" class="headerlink" title="2. 中序遍历过程"></a><strong><font color=red>2. 中序遍历过程</font></strong></h3><p>中序遍历LNR二叉树的过程是：</p><p>① 中序遍历左子树；</p><p>② 访问根节点；</p><p>③ 中序遍历右子树。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdRi9S.md.png" alt=""></p><h3 id="3-后序遍历过程"><a href="#3-后序遍历过程" class="headerlink" title="3. 后序遍历过程"></a><strong><font color=red>3. 后序遍历过程</font></strong></h3><p>中序遍历LNR二叉树的过程是：</p><p>① 后序遍历左子树；</p><p>② 后序遍历右子树；</p><p>③ 访问根节点。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdRCh8.md.png" alt=""></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a><strong><font color=green>例题</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdftfK.md.png" alt=""></p><h2 id="二叉树遍历递归算法"><a href="#二叉树遍历递归算法" class="headerlink" title="二叉树遍历递归算法"></a>二叉树遍历递归算法</h2><p>由二叉树的三种遍历过程直接得到3种递归算法</p><h3 id="先序遍历的递归算法"><a href="#先序遍历的递归算法" class="headerlink" title="先序遍历的递归算法"></a><strong><font color=blue>先序遍历的递归算法</font></strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(b-&gt;lchild);</span><br><span class="line">        PreOrder(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 <strong>访问</strong> 是直接输出节点值。实际上，访问节点可以对该节点进行各种操作，如计数，删除节点等。</p><h3 id="中序遍历的递归算法"><a href="#中序遍历的递归算法" class="headerlink" title="中序遍历的递归算法"></a><strong><font color=blue>中序遍历的递归算法</font></strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrder(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">        InOrder(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历的递归算法"><a href="#后序遍历的递归算法" class="headerlink" title="后序遍历的递归算法"></a><strong><font color=blue>后序遍历的递归算法</font></strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrder(b-&gt;lchild);</span><br><span class="line">        PostOrder(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层次遍历算法"><a href="#层次遍历算法" class="headerlink" title="层次遍历算法"></a>层次遍历算法</h2><p>层次遍历过程：</p><p>对于一棵二叉树，从根节点开始，按从上到下，从左到右的顺序访问每一个节点。</p><p>每个节点仅仅访问一次。</p><h3 id="算法设计思路"><a href="#算法设计思路" class="headerlink" title="算法设计思路"></a>算法设计思路</h3><p>使用一个队列。</p><p>Ⅰ 将根节点进队;</p><p>Ⅱ <strong><font color=blue>队不空时循环</font></strong>：从队列中列出一个节点 *p 访问它；</p><p>​    ① 若它有左孩子节点，将左孩子节点进队；</p><p>​    ② 若它有右孩子节点，将右孩子节点进队。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BTNode * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * p;</span><br><span class="line">    BTNode *qu[MaxSize];  <span class="comment">//定义环形队列，存放节点指针</span></span><br><span class="line">    <span class="keyword">int</span> front,rear;       <span class="comment">//定义对头和队尾指针</span></span><br><span class="line">    front = rear = <span class="number">0</span>;     <span class="comment">//置队列为空队列</span></span><br><span class="line">    rear++;</span><br><span class="line">    qu[rear] = b;         <span class="comment">//根节点指针进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(front != rear)  <span class="comment">//队列不为空循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        front = (front + <span class="number">1</span>)%MaxSize;</span><br><span class="line">        p = qu[front];    <span class="comment">//队头出队列</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);  <span class="comment">//访问节点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)   <span class="comment">//有左孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear = (rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">            qu[rear] = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)   <span class="comment">//有右孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear = (rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">            qu[rear] = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法的时间复杂度为O(n)</strong></p><h2 id="二叉树3种递归遍历算法的应用"><a href="#二叉树3种递归遍历算法的应用" class="headerlink" title="二叉树3种递归遍历算法的应用"></a>二叉树3种递归遍历算法的应用</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><strong><font color=green>基本思路</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/Yw1DA0.md.png" alt=""></p><p><strong><font color=green>例1：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法，计算一棵给定二叉树的所有节点个数</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwGAkq.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Nodes</span><span class="params">(BTNode * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Nodes(b-&gt;lchild)+Nodes(b-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//先左子树，再右子树，最后根节点，是后序遍历的思路</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>提示</font></strong>:<strong>本例算法可以基于任何一种遍历算法</strong></p><p><strong><font color=green>例2：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法，计算一棵给定二叉树的所有叶子节点个数</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwGp6g.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafNodes</span><span class="params">(BTNode * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; b-&gt;rchlid == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        num1 = LeafNodes(b-&gt;lchild);</span><br><span class="line">        num2 = LeafNodes(b-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> (num1+num2);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>提示</font></strong>:<strong>本例算法可以基于任何一种遍历算法</strong></p><p><strong><font color=green>例3：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法把二叉树b复制到二叉树t中</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwJUP0.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(BTNode * b, BTNode * t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">        t-&gt;data = b-&gt;data;<span class="comment">//复制一个根节点*t</span></span><br><span class="line">        Copy(b-&gt;lchild, t-&gt;lchild);    <span class="comment">//递归复制左子树</span></span><br><span class="line">        Copy(b-&gt;rchild, t-&gt;rchild);     <span class="comment">//递归复制右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>先根节点，再左子树，最后右子树，是先序遍历的思路</p><p><strong><font color=green>例4：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法把二叉树b的左、右子树进行交换。要求 <font color=red>不破坏原二叉树</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwYGQO.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(BTNode * b, BTNode * t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">        t-&gt;data = b-&gt;data;<span class="comment">//复制一个根节点*t</span></span><br><span class="line">        Swap(b-&gt;lchild, t-&gt;rchild);    <span class="comment">//递归交换左子树</span></span><br><span class="line">        Swap(b-&gt;rchild, t-&gt;lchild);     <span class="comment">//递归交换右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=green>例5：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法level()求二叉树b中值为x的节点的层次（假设所有节点值唯一）。</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwtDE9.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwtrNR.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/Ywt0HJ.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">(BTNode * b, ElemType x, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空树时返回0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;data == x)<span class="comment">//找到节点时</span></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        l = level(b-&gt;lchild, x, h+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> level(b-&gt;rchild, x, h+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> l;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>注意：</font></strong>基于<strong>先序遍历</strong>算法思想</p><h2 id="层次遍历算法的应用"><a href="#层次遍历算法的应用" class="headerlink" title="层次遍历算法的应用"></a>层次遍历算法的应用</h2><p><strong><font color=green>例1：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法输出从根节点到每个叶子节点的逆路径。</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwNJVH.png" alt=""></p><p><strong>解：</strong> 设计的队列为非环形队列qu，将所有已访问过的节点指针进队，并在队列中保存双亲节点的位置。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwNxsO.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AllPath</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snode</span>;</span></span><br><span class="line">    &#123;</span><br><span class="line">        BTNode * node;     <span class="comment">//存放当前节点指针</span></span><br><span class="line">        <span class="keyword">int</span> parent;   <span class="comment">//存放双亲节点在队列中的位置</span></span><br><span class="line">    &#125;qu[MaxSize];   <span class="comment">//定义非环形队列</span></span><br><span class="line">    BTNode *q;</span><br><span class="line">    <span class="keyword">int</span> front, rear, p;    <span class="comment">//定义队头和队尾指针</span></span><br><span class="line">    front = rear = <span class="number">-1</span>;     <span class="comment">//置队列为空队列</span></span><br><span class="line">    rear++;</span><br><span class="line">    qu[rear].node = b;     <span class="comment">//根节点指针进去队列</span></span><br><span class="line">    qu[rear].parent = <span class="number">-1</span>;  <span class="comment">//根节点没有双亲节点</span></span><br><span class="line">    <span class="keyword">while</span>(front != rear)   <span class="comment">//队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        front++;   <span class="comment">//front是当前节点*q在qu中的位置</span></span><br><span class="line">        q = qu[front].node;  <span class="comment">//队列出队列，该节点指针仍在qu中</span></span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; q-&gt;rchild == <span class="literal">NULL</span>)  <span class="comment">//*q为叶子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = front;     <span class="comment">//输出*q到根节点的逆路径序列</span></span><br><span class="line">            <span class="keyword">while</span>(qu[p].parent != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c-&gt;"</span>, qu[p].node-&gt;data);</span><br><span class="line">                p = qu[p].parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c\m"</span>, qu[p].node-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild != <span class="literal">NULL</span>)   <span class="comment">//*q节点有左孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear++;</span><br><span class="line">            qu[rear].node = q-&gt;lchild;</span><br><span class="line">            qu[rear].parent = front;  <span class="comment">//*q的左孩子的双亲位置为front</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild != <span class="literal">NULL</span>)   <span class="comment">//*q节点有右孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear++;</span><br><span class="line">            qu[rear].node = q-&gt;rchild;</span><br><span class="line">            qu[rear].parent = front;  <span class="comment">//*q的右孩子的双亲位置为front</span></span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下 二叉树的遍历及其应用知识点…&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="遍历二叉树" scheme="https://wuhongbin.github.io/tags/%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>C++ 指针的引用和指向引用的指针</title>
    <link href="https://wuhongbin.github.io/2020/05/12/C++%20%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E5%90%91%E5%BC%95%E7%94%A8%E7%9A%84%E6%8C%87%E9%92%88/"/>
    <id>https://wuhongbin.github.io/2020/05/12/C++%20%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E5%90%91%E5%BC%95%E7%94%A8%E7%9A%84%E6%8C%87%E9%92%88/</id>
    <published>2020-05-12T11:37:43.000Z</published>
    <updated>2020-05-12T11:53:25.835Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下C++ 指针的引用和指向引用的指针一些知识点…</p><a id="more"></a><h2 id="指向引用的指针"><a href="#指向引用的指针" class="headerlink" title="指向引用的指针"></a>指向引用的指针</h2><p>简单使用指针的一个例子就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure><p><strong><font color=red>预先强调：</font></strong> <strong>没有指向引用的指针</strong></p><p><strong>原因：</strong> 因为引用 <strong><font color=red>不是对象，没有地址</font></strong>。</p><p>但是指向引用的指针是什么形式呢？是对一个引用进行如下取地址吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ri = v;<span class="comment">// 整型变量v的引用</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;ri;<span class="comment">// 这是指向引用的指针吗？</span></span><br></pre></td></tr></table></figure><p>事实上不是，这是一个普通的整型指针，虽然我们说引用没有地址，但是对引用ri的操作实际上是对v的操作。这是是定义了一个整型指针p，并且让它指向了v。<br>那如何定义一个指向引用的指针呢(虽然是不合理的请求)？当我们定义指针的时候，我们用到了* ，那么当我们定义指向引用的指针时，免不了要用到*和&amp;。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ri = v;</span><br><span class="line"><span class="keyword">int</span> &amp;*p = &amp;ri;  <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>由于引用并<strong>不存在地址</strong>，因此第三行将会报错。我们可以从右往左读，<code>*</code>表明p是一个指针，余下的<code>&amp;</code>说明了<code>p</code>指向类型的类型。</p><h2 id="指针的引用"><a href="#指针的引用" class="headerlink" title="指针的引用"></a>指针的引用</h2><p>引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。</p><p>之前说到指向引用的指针，现在来说指针的引用就容易多了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;v;</span><br><span class="line"><span class="keyword">int</span>* &amp;rp = p;</span><br></pre></td></tr></table></figure><p><code>&amp;</code>说明rp是一个引用。<code>*</code>确定rp引用的类型是一个指针。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>因为引用不是对象，故无引用的数组，无指向引用的指针，无到引用的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; a[<span class="number">3</span>]; <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">int</span>&amp;* p;   <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">int</span>&amp; &amp;r;   <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>参考博文：<a href="https://blog.csdn.net/fatfish_/article/details/86768887" target="_blank" rel="noopener">https://blog.csdn.net/fatfish_/article/details/86768887</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下C++ 指针的引用和指向引用的指针一些知识点…&lt;/p&gt;
    
    </summary>
    
    
      <category term="C / C + +" scheme="https://wuhongbin.github.io/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://wuhongbin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的基本运算及其实现 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-12T09:46:43.000Z</published>
    <updated>2020-05-19T04:04:33.987Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下 二叉树的基本运算及其实现知识点…</p><a id="more"></a><h2 id="二叉树的基本运算概述"><a href="#二叉树的基本运算概述" class="headerlink" title="二叉树的基本运算概述"></a>二叉树的基本运算概述</h2><p>①  <strong><font color=red>创建二叉树 CreateBTNode(*b, *str)：</font></strong> 根据根据二叉树括号表示法字符串str生成对应的二叉链存储结构b</p><p>②  <strong><font color=red>销毁二叉链存储结构 DestoryBT( *b)：</font></strong> 销毁二叉链b并释放空间</p><p>③  <strong><font color=red>查找节点 FindNode(*b, x)：</font></strong> 在二叉树b中寻找data域值为x的节点，并返回指向该节点的指针</p><p>④  <strong><font color=red>找孩子节点 LchildNode(p) 和 RchildNode(p)：</font></strong>分别求二叉树中节点*p的左孩子节点和右孩子节点</p><p>⑤  <strong><font color=red>求高度 BTNodeDepth(*b)：</font></strong>求二叉树b的高度。若二叉树为空，则其高度为0; 否则，其高度等于左子树和右子树中的最大高度加1</p><p>⑥  <strong><font color=red>输出二叉树 DispBTNode(*b)：</font></strong>以括号表示法输出一棵二叉树</p><h2 id="二叉树的基本运算算法实现"><a href="#二叉树的基本运算算法实现" class="headerlink" title="二叉树的基本运算算法实现"></a>二叉树的基本运算算法实现</h2><h3 id="1-创建二叉树-CreateBTNode-b-str-："><a href="#1-创建二叉树-CreateBTNode-b-str-：" class="headerlink" title="1. 创建二叉树 CreateBTNode(*b, *str)："></a><strong><font color=red>1. 创建二叉树 CreateBTNode(*b, *str)：</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YN4QmR.md.png" alt=""></p><h4 id="算法设计："><a href="#算法设计：" class="headerlink" title=" 算法设计："></a><strong><font color=red> 算法设计：</font></strong></h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YN4KX9.md.png" alt=""></p><h4 id="用ch扫描采用括号表示法表示二叉树的字符串："><a href="#用ch扫描采用括号表示法表示二叉树的字符串：" class="headerlink" title=" 用ch扫描采用括号表示法表示二叉树的字符串："></a><strong><font color=red> 用ch扫描采用括号表示法表示二叉树的字符串：</font></strong></h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YN4zAx.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由str → 二叉链b</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBTNode</span><span class="params">(BTNode *b, <span class="keyword">char</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *St[MaxSize], *p;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>, k, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;                   </span><br><span class="line">    b = <span class="literal">NULL</span>;       <span class="comment">//建立的二叉链初始时为空</span></span><br><span class="line">    ch = str[j];</span><br><span class="line">    <span class="keyword">while</span>(ch != <span class="string">'\0'</span>)  <span class="comment">//str未扫描完时循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span> :top++;St[top] = p; k = <span class="number">1</span>; <span class="keyword">break</span>;  <span class="comment">//可能有左孩子节点，进栈</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span> :top--;<span class="keyword">break</span>;<span class="comment">//退栈</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">','</span> :k = <span class="number">2</span>;<span class="keyword">break</span>;      <span class="comment">//后面为右孩子节点</span></span><br><span class="line">            <span class="keyword">default</span> :<span class="comment">//遇到节点值</span></span><br><span class="line">                p = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>)(BTNode);</span><br><span class="line">                p-&gt;data=ch;</span><br><span class="line">                p-&gt;lchild = p-&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span>(b = <span class="literal">NULL</span>)<span class="comment">//p为二叉树的根节点</span></span><br><span class="line">                    b = p;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//已建立二叉树根节点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">switch</span>(k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>: St[top]-&gt;lchild = p;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>: St[top]-&gt;rchild = p;<span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        j++; ch =str[j];      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-销毁二叉链-DestoryBT-b-："><a href="#2-销毁二叉链-DestoryBT-b-：" class="headerlink" title="2. 销毁二叉链 DestoryBT( *b)："></a><strong><font color=red>2. 销毁二叉链 DestoryBT( *b)：</font></strong></h3><p>设f(b)销毁二叉链b：<strong><font color=red>大问题</font></strong></p><p>则f(b-&gt;lchild)销毁左子树，f(b-&gt;rchild)销毁右子树：<strong><font color=red>两个小问题</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YNzUgA.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryBT</span><span class="params">(BTNOde *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        DestoryBT(b-&gt;lchild);</span><br><span class="line">        DestoryBT(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(b);  <span class="comment">//剩下一个节点*b，直接释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-查找节点-FindNode-b-x"><a href="#3-查找节点-FindNode-b-x" class="headerlink" title="3. 查找节点 FindNode(*b, x)"></a><strong><font color=red>3. 查找节点 FindNode(*b, x)</font></strong></h3><p>设f(b, x)在二叉树b中查找值为x的节点（唯一）。找到后返回其指针，否则返回NULL。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YUF5Qg.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function">BTNode * <span class="title">FindNode</span><span class="params">(BTNode * b, ELemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * p;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;data == x)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = FindNode(b-&gt;lchild, x);</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> FindNode(b-&gt;rchild, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-找孩子节点-LchildNode-p-和-RchildNode-p"><a href="#4-找孩子节点-LchildNode-p-和-RchildNode-p" class="headerlink" title="4. 找孩子节点 LchildNode(p) 和 RchildNode(p)"></a><strong><font color=red>4. 找孩子节点 LchildNode(p) 和 RchildNode(p)</font></strong></h3><p>直接返回 *p 节点的左孩子节点或右孩子节点的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode * <span class="title">LchildNode</span><span class="params">(BTNode * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BTNode * <span class="title">RchildNode</span><span class="params">(BTNode * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-求高度-BTNodeDepth-b"><a href="#5-求高度-BTNodeDepth-b" class="headerlink" title="5. 求高度 BTNodeDepth(*b)"></a><strong><font color=red>5. 求高度 BTNodeDepth(*b)</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YUAzZ9.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BTNodeDepth</span><span class="params">(BTNode * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lchildep,rchilddep;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);    <span class="comment">//空树的高度为0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        lchildep = BTNodeDepth(b-&gt;lchild);   <span class="comment">//求左子树的高度lchildep</span></span><br><span class="line">        rchilddep = BTNodeDepth(b-&gt;rchild);  <span class="comment">//求右子树的高度rchildep</span></span><br><span class="line">        <span class="keyword">return</span> ((lchildep&gt;rchilddep)?(lchildep+<span class="number">1</span>):(rchildep+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-输出二叉树-DispBTNode-b"><a href="#6-输出二叉树-DispBTNode-b" class="headerlink" title="6. 输出二叉树 DispBTNode(*b)"></a><strong><font color=red>6. 输出二叉树 DispBTNode(*b)</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YUVOHJ.md.png" alt=""></p><p>根节点 （ 左子树  ，右子树） ←  括号表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">DispBTNode</span><span class="params">(BTNode * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;lchild != <span class="literal">NULL</span> || b-&gt;rchild != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">            DispBTNode(b-&gt;lchild);  <span class="comment">//递归处理左子树</span></span><br><span class="line">            <span class="keyword">if</span>(b-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">","</span>);</span><br><span class="line">            DispBTNode(b-&gt;rchild);  <span class="comment">//递归处理右子树</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下 二叉树的基本运算及其实现知识点…&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的存储结构 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-12T09:01:43.000Z</published>
    <updated>2020-05-19T04:04:03.841Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下 二叉树的存储结构知识点…</p><a id="more"></a><h2 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YNQAcq.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YNQEj0.md.png" alt=""></p><h3 id="二叉树顺序存储结构的特点"><a href="#二叉树顺序存储结构的特点" class="headerlink" title="二叉树顺序存储结构的特点"></a>二叉树顺序存储结构的特点</h3><p>① 对于 <strong><font color=red>完全二叉树</font></strong> 来说，期顺序存储是十分合适的。</p><p>② 对于 <strong><font color=red>一般的二叉树</font></strong> ，特别是对于那些单分支节点较多的二叉树来说是很不合适的，因为可能只有少数的存储单元被利用，特别是对退化的二叉树(即每个节点都是单分支的)，空间浪费更是惊人。</p><p>③ 在顺序存储结构中，<strong><font color=red>找一个节点的双亲和孩子都很容易</font></strong>。</p><h2 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h2><p>借鉴 <strong><font color=blue>树的孩子链存储结构</font></strong> → 二叉树的链式存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉树的链式存储中，节点定义如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>*<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>  <span class="comment">//指向的都是二叉树:递归性</span></span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YNGs76.md.png" alt=""></p><h3 id="二叉链存储结构的特点"><a href="#二叉链存储结构的特点" class="headerlink" title="二叉链存储结构的特点"></a>二叉链存储结构的特点</h3><p>① 除了指针外，二叉链  <strong><font color=red>比较节省存储空间</font></strong>。占用的存储空间与树形没有关系，只与树中节点个数有关。</p><p>② 在二叉链中，<strong><font color=red>找一个节点的孩子很容易</font></strong>，但找其双亲不方便。</p><p>一棵树采用孩子兄弟链存储结构表示  →  二叉链</p><h3 id="二叉链中空指针的个数"><a href="#二叉链中空指针的个数" class="headerlink" title="二叉链中空指针的个数"></a>二叉链中空指针的个数</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YNJTM9.md.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下 二叉树的存储结构知识点…&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的概念 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-12T02:10:43.000Z</published>
    <updated>2020-05-20T00:02:14.987Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下 二叉树的知识点…</p><a id="more"></a><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树是有限的节点集合 （<strong><font color=red>递归定义</font></strong> ）</p><p>① 这个集合或者是空</p><p>② 或者由一个根节点和两颗互不相交的称为  <strong><font color=red>左子树</font></strong> 和 <strong><font color=red>右子树</font></strong> 的二叉树组成。</p><h3 id="二叉树的五种基本形态："><a href="#二叉树的五种基本形态：" class="headerlink" title="二叉树的五种基本形态："></a><strong><font color=blue>二叉树的五种基本形态：</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YtFeq1.md.png" alt=""></p><h3 id="二叉树的逻辑结构表示法："><a href="#二叉树的逻辑结构表示法：" class="headerlink" title="二叉树的逻辑结构表示法："></a><strong><font color=blue>二叉树的逻辑结构表示法：</font></strong></h3><p>① 树形表示法</p><p>② 文氏图表示法</p><p>③ 凹入表示法</p><p>④ 括号表示法</p><h3 id="二叉树和二次树区别："><a href="#二叉树和二次树区别：" class="headerlink" title="二叉树和二次树区别："></a><strong><font color=red>二叉树和二次树区别：</font></strong></h3><p>① <strong>度不同</strong></p><p>度为2的树要求每个节点最多只能有两棵子树，并且至少有一个节点有两棵子树。二叉树的要求是度不超过2，节点最多有两个叉，可以是1或者0。</p><p>② <strong>分支不同</strong></p><p>度为2的树有两个分支，但分支没有左右之版分；一棵二叉树也有两个分支，但有左右之分，左右子树的次序不能随意颠倒。</p><p>③ <strong>次序不同</strong></p><p>度为2的树从形式上看与二叉树很相似，但它的子树是无序的，而二叉树是有序的。即，在一般树中若某结点只有一个孩子，就无需区分其左右次序，而在二叉树中即使是一个孩子也有左右之分。</p><h3 id="两种特殊的二叉树："><a href="#两种特殊的二叉树：" class="headerlink" title="两种特殊的二叉树："></a><strong><font color=blue>两种特殊的二叉树：</font></strong></h3><p><strong><font color=red>满二叉树：</font></strong></p><p>在一棵二叉树中：</p><p>① 如果所有分支节点都有分支节点;</p><p>② 并且叶节点都集中在二叉树的最下一层。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YtZfxS.md.png" alt=""></p><p><strong><font color=red>完全二叉树：</font></strong></p><p>在一棵二叉树中：</p><p>① 最多只有下面两层节点的度数小于2</p><p>② 并且最下面一层的叶节点都依次排列在该层最左边的位置上。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YtYujA.md.png" alt=""></p><p><strong><font color=red>完全二叉树</font></strong> 实际上是对应的 <strong><font color=red>满二叉树</font></strong> 删除叶节点层最右边若干个节点得到的。</p><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YttzLR.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YtNVQH.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YtNESe.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/Ytdrp8.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/Ytds1S.md.png" alt=""></p><h2 id="二叉树与树、森林之间的转换"><a href="#二叉树与树、森林之间的转换" class="headerlink" title="二叉树与树、森林之间的转换"></a>二叉树与树、森林之间的转换</h2><h3 id="1-森林、树转换为二叉树"><a href="#1-森林、树转换为二叉树" class="headerlink" title="1. 森林、树转换为二叉树"></a><strong><font color=red>1. 森林、树转换为二叉树</font></strong></h3><p><strong>一棵树转换为二叉树</strong></p><p>① 把兄弟节点连接起来</p><p>② 所有节点顺时针旋转45度</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/Yt02iq.md.png" alt=""></p><p><strong>多颗树转换为二叉树</strong></p><p><strong>方法一：</strong></p><p>① 把每个树分别转换为二叉树</p><p>② 把后一个二叉树作为前一个二叉树的右子树，依次连接成一棵二叉树</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/Yt0con.md.png" alt=""></p><p><strong>方法二：</strong></p><p>① 给这几个树加上一个根节点</p><p>② 再将这棵新的树转换为二叉树</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/Yt0yZj.md.png" alt=""></p><h3 id="2-二叉树还原为森林、树"><a href="#2-二叉树还原为森林、树" class="headerlink" title="2. 二叉树还原为森林、树"></a><strong><font color=red>2. 二叉树还原为森林、树</font></strong></h3><p>*<em>一棵二叉树还原为一棵 树 *</em></p><p>① 考察每个节点的右分支节点，把每个右分支节点节点与它的双亲节点连接起来</p><p>② 删除掉右分支线</p><p>③ 再将此树逆时针旋转45度。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YtBXAs.md.png" alt=""></p><p>*<em>一棵二叉树还原为 多颗树 *</em></p><p>① 考察这棵树，把从根节点的右分支节点开始，每个节点对应的树圈起来。也就是把这棵二叉树转换为3棵二叉树(以图为例)</p><p>② 再把三棵二叉树分别还原成树</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/Ytr1MT.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YtrQzV.md.png" alt=""></p><p><strong><font color=green>例题：</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/Yt7jUI.md.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下 二叉树的知识点…&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>树的概念运算和存储结构 详细总结</title>
    <link href="https://wuhongbin.github.io/2020/05/09/%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E8%BF%90%E7%AE%97%E5%92%8C%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/05/09/%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E8%BF%90%E7%AE%97%E5%92%8C%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-09T11:10:43.000Z</published>
    <updated>2020-05-19T04:04:41.615Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下 树的知识点…</p><a id="more"></a><h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p><strong><font color=red>树形式化定义：</font></strong>T = {D, R} 。（D表示 数据对象，R 表示数据关系）</p><p>D是包含n个节点的有限集合（n≥0）。当n = 0时为 <strong>空树</strong>，否则关系 R 满足以下条件：</p><p>① 有且仅有一个节点 d0 ∈ D，它对于关系R来说没有前趋节点，节点d0称作 树的 <font color=red><strong>根节点</strong></font>。</p><p>② 除<font color=red> <strong>根节点</strong> </font>外每个节点有且 <font color=red><strong>仅有一个前趋节点</strong></font>。</p><p>③ D中每个节点可以有 <font color=red><strong>零个或多个后继节点</strong></font> 。</p><p><strong><font color=red>树的递归定义：</font></strong>树是由n （n≥0）个节点组成的有限集合（记为T）。其中：</p><p>① 如果n = 0, 它是一棵空树，这是树的特例。</p><p>② 如果n &gt; 0, 其中存在一个唯一节点作为输的根节点（root），其余节点可分为m（m≥0）个互不相交的有限子集T1、T2 、…、Tm，而每个子集本身又是一棵 <font color=red><strong>树</strong></font> ，称为根节点root的子树。</p><p>**<font color=blue>树中所有节点构成一种层次关系</font> **</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/YlI2GR.md.jpg" style="zoom:50%;" /><h3 id="树的实际应用"><a href="#树的实际应用" class="headerlink" title="树的实际应用"></a>树的实际应用</h3><p>① <strong>红黑树:</strong> JAVA8中的hashMap满足一定的阈值，自动扩容时会变为红黑树，treeMap，linux中的epoll模型，nginx中的Timer管理等。</p><p>② <strong>B，B＋树:</strong>广泛用于数据库(mysql，oracle等)的索引。</p><p>③ <strong>字典树:</strong>用于海量文本词频统计，查询效率比哈希表还高。</p><p>④ 生活中的树状结构有公司职级关系，国家省市区级联，族谱等等都有树结构形式.</p><h3 id="树的（逻辑）表示"><a href="#树的（逻辑）表示" class="headerlink" title="树的（逻辑）表示"></a>树的（逻辑）表示</h3><p>(1) <font color=red><strong>树形表示法：</strong></font> 使用一棵倒置的树表示树结构，非常直观和形象。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/YlzPFx.png" style="zoom: 67%;" /><p>(2) <font color=red><strong>文氏图表示法：</strong></font> 使用集合以及集合的包含关系来描述树结构。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/YlziY6.png" style="zoom: 50%;" /><p>(3) <font color=red><strong>凹入表示法：</strong></font>使用线段的伸缩关系描述树结构</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/YlzFfK.png" style="zoom:50%;" /><p>(4) <font color=red><strong>括号表示法：</strong></font>用一个字符串表示树</p><p>基本形式： 根（子树1，子树2，…，子树m）</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Ylz9T1.png" style="zoom:50%;" /><h3 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h3><p><strong><font color=red>1. 节点的度与树的度：</font></strong></p><p>树中一个节点的子树的个数称为该<font color=red><strong>节点的度</strong></font>。树中各节点的度的最大值称为<font color=red><strong>树的度</strong></font>，通常将度为m的树称为 <font color=red><strong>m次树</strong></font> 或者 <font color=red><strong>m叉树</strong></font>。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Y19tne.png" style="zoom:50%;" /><p><strong><font color=red>2. 分支节点与叶节点：</font></strong></p><p>度不为0的节点称为非终端节点，又叫 <font color=red><strong>分支节点</strong></font>。度为0的节点称为终端节点或<font color=red><strong>叶节点</strong></font>（或<font color=red><strong>叶子节点</strong></font>）。</p><p>度为1的节点称为 <font color=red><strong>单分支节点</strong></font>；度为2的节点称为<font color=red><strong>双分支节点</strong></font>，依次类推。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Y1PFMT.png" alt="Y1PFMT.png" style="zoom:50%;" /><p><strong><font color=red>3. 路径与路径长度：</font></strong></p><p>两个节点di和dj的节点序列（di，di1，di2，…，dj）称为<font color=red><strong>路径</strong></font>。其中&lt;dx,dy&gt;是 分支。</p><p><strong><font color=red>路径长度</font></strong> 等于路径所通过的节点数目减1（即路径上分支数目）。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Y1PksU.png" alt="Y1PksU.png" style="zoom:67%;" /><p><strong><font color=red>4. 孩子节点，双亲节点和兄弟节点：</font></strong></p><p>在一棵树中。每个节点的后继称作该节点的 <font color=red><strong>孩子节点</strong></font>（或子女节点）。相应地，该节点被称作孩子节点的 <font color=red><strong>双亲节点</strong></font>（或父母节点）。具有同一双亲的孩子节点互为 <font color=red><strong>兄弟节点</strong></font>。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Y1PVZ4.png" alt="Y1PVZ4.png" style="zoom:67%;" /><p><strong><font color=red>5.子孙节点和祖先节点：</font></strong></p><p>在一棵树中，一个节点的所有子树中的节点称为该节点的 <font color=red><strong>子孙节点</strong></font>。</p><p>从根节点到达一个节点的路径上经过的所有节点被称为该节点的<font color=red><strong>祖先节点</strong></font>。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Y1PALF.png" alt="Y1PALF.png" style="zoom:67%;" /><p><strong><font color=red>6.节点的层次和树的高度：</font></strong></p><p>树中的每个节点都处在一个层次上。节点的层次从树根开始定义，根节点为第一层，它的孩子节点为第二层，以此类推，一个节点所在的层次为其双亲节点所在层次加1。</p><p>树中节点的最大层次称为树的<font color=red><strong>树的高度</strong></font>（或树的 <font color=red><strong>深度</strong></font>）。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Y1kT0S.png" style="zoom:67%;" /><p><strong><font color=red>7.有序树和无需树：</font></strong></p><p>若树中各节点的子树是按照一定的次序从左往右安排的，且相对次序是不能随意变换的，则称为 <font color=red><strong>有序树</strong></font>，否则称为 <font color=red><strong>无序树</strong></font>。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Y1AMAe.png" style="zoom:67%;" /><p><strong><font color=red>8.森林：</font></strong></p><p>n（n&gt;0）个互不相交的树的集合称为 <font color=red><strong>森林</strong></font>。</p><p>只要把树的根节点删去就成了森林。反之，只要给n棵独立的树加上一个根节点，并把这n棵树作为该节点的子树，则森林就变成了一棵树。</p><p><strong><font color=blue>独木也成林！！</font></strong></p><h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><p><strong><font color=red>性质1：</font></strong>树中的节点数等于所有节点的度数+1</p><p>① 树中每个分支为一个节点的度  →  <font color=blue><strong>所有节点的度之和 = 分支数</strong></font></p><p>② 根节点加上一个分支，这分支数与节点数相同 → <font color=blue><strong>实际分支数 = n-1</strong></font></p><p><strong><font color=blue>n = 度之和 +1</font></strong></p><p><strong><font color=green>例题：</font></strong></p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y3fEpq.png" style="zoom:67%;" /><p><strong><font color=red>性质2：</font></strong>度为m的树中第i层上至多有m的(i-1)次个节点（i≥1）</p><p><strong><font color=blue>度为3的树第二层至多有3个节点</font></strong>    3的(2-1)次 = 3</p><p><strong><font color=red>性质3：</font></strong></p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y34AyV.png" style="zoom:67%;" /><p><strong><font color=red>性质4：</font></strong></p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y34kQ0.png" style="zoom:80%;" /><h2 id="树的运算和存储结构"><a href="#树的运算和存储结构" class="headerlink" title="树的运算和存储结构"></a>树的运算和存储结构</h2><h3 id="树的基本运算"><a href="#树的基本运算" class="headerlink" title="树的基本运算"></a>树的基本运算</h3><p>树的运算主要分为三大类：</p><p><font color=red><strong>查找</strong></font>满足某种特点关系的节点，如查找当前节点的双亲节点等;</p><p><font color=red><strong>插入或删除</strong></font>某个节点，如在树的当前节点上插入一个新节点或者删除当前节点的第i个孩子节点等</p><p><font color=red><strong>遍历</strong></font>树中每个节点。</p><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>树的遍历运算是指按照某种访问方式访问树中的 <strong><font color=blue>每一个节点且每一个节点只能被访问一次。</font></strong></p><p><strong><font color=green>主要的遍历方法：</font></strong></p><p>① <font color=red><strong>先根遍历：</strong></font>若树不空，则先访问根节点，然后依次先根遍历各棵子树。</p><p>② <font color=red><strong>后根遍历：</strong></font>若树不空，则依次后根遍历各棵子树，然后访问根节点。</p><p>③ <font color=red><strong>层次遍历：</strong></font>若树不空，则自上而下、自左至右访问树中每个节点。</p><p><strong><font color=red>注意：</font><font color=blue>先根和后根遍历算法都是递归的。</font></strong></p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y3ThUU.md.png" style="zoom:50%;" /><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y3T45F.md.png" style="zoom:50%;" /><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y3TfET.md.png" style="zoom:50%;" /><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p><strong><font color=red>1. 双亲存储结构</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y8FfZ8.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双亲存储结构的类型声明如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;   <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">int</span> parent;      <span class="comment">//指向双亲的位置</span></span><br><span class="line">&#125;PTree[MaxSize];</span><br></pre></td></tr></table></figure><p><strong><font color=red>2. 孩子链存储结构</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y8k7kD.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 孩子链存储结构的类型声明如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;   <span class="comment">//节点的值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">sons</span>[<span class="title">MaxSons</span>];</span>      <span class="comment">//指向孩子节点</span></span><br><span class="line">&#125;PSonNode;</span><br></pre></td></tr></table></figure><p>其中，MaxSons为最多的孩子节点个数。</p><p><strong><font color=red>3. 孩子兄弟链存储结构</font></strong></p><p>孩子兄弟链存储结构是为每个节点设计3个域：</p><p>① 一个数据元素域</p><p>② 第一个孩子节点指针域</p><p>③  一个兄弟节点指针域</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y8A7D0.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 孩子兄弟链存储结构的类型声明如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;   <span class="comment">//节点的值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> * <span class="title">hp</span>;</span>      <span class="comment">//指向兄弟节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> * <span class="title">vp</span>;</span>      <span class="comment">//指向第一个孩子节点</span></span><br><span class="line">&#125;TSBNode;</span><br></pre></td></tr></table></figure><p>每个节点固定只有两个指针域！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下 树的知识点…&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://wuhongbin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树和二叉树" scheme="https://wuhongbin.github.io/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Qt5 实例开发之文本编辑器</title>
    <link href="https://wuhongbin.github.io/2020/04/16/Qt5%20%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91%E4%B9%8B%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>https://wuhongbin.github.io/2020/04/16/Qt5%20%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91%E4%B9%8B%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</id>
    <published>2020-04-16T10:10:43.000Z</published>
    <updated>2020-04-16T12:08:00.970Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了Qt5实例开发之文本编辑器…</p><a id="more"></a><h2 id="文本编辑器例图"><a href="#文本编辑器例图" class="headerlink" title="文本编辑器例图"></a>文本编辑器例图</h2><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/04/16/JAuood.png" style="zoom: 50%;" /><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/04/16/JAuIdH.png" style="zoom: 50%;" /><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p><strong>系统版本：</strong>windows10<br>** QT 版本：** 5.9.9<br><strong>开发语言：</strong>C++</p><h2 id="已实现功能"><a href="#已实现功能" class="headerlink" title="已实现功能"></a>已实现功能</h2><ol><li><strong>文件操作：</strong>新建，打开，保存，另存为，打印，退出</li><li><strong>编辑操作：</strong>复制，粘贴，剪切，查找，替换，撤销，恢复</li><li><strong>文字编辑：</strong>字体，字号，加粗，倾斜，颜色</li><li><strong>个性化功能：</strong>背景色修改，背景图修改</li><li>大部分功能已匹配相关的快捷键操作</li><li>软件默认背景色为 护眼绿</li></ol><h2 id="未解决BUG"><a href="#未解决BUG" class="headerlink" title="未解决BUG"></a>未解决BUG</h2><ol><li><p>打开操作BUG：从 文件 — 右键打开方式 — 选择本软件 — 打开后不显示文件内容</p></li><li><p>个性化功能BUG：背景色，背景图修改后，仅当前状态有效，退出软件重新打开后，恢复为默认颜色 护眼绿</p><p>可能有其它未知BUG，尚未发现..</p></li></ol><h2 id="未完善功能"><a href="#未完善功能" class="headerlink" title="未完善功能"></a>未完善功能</h2><ol><li><p>查找和替换操作，仅支持从当前光标位置向后查找</p></li><li><p>文字居中，对齐等功能尚未实现</p></li><li><p>无法将图片插入文本进行操作</p><p>….</p></li></ol><h2 id="部分源码文档"><a href="#部分源码文档" class="headerlink" title="部分源码文档"></a>部分源码文档</h2><p><strong>mainwindow.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCloseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QImage&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMenu&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QAction&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QComboBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFontComboBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QToolButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextCharFormat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QAction&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QColorDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QColor&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MainWindow(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~MainWindow();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">creatMenus</span><span class="params">()</span></span>;      <span class="comment">//创建菜单栏</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">creatToolbars</span><span class="params">()</span></span>;   <span class="comment">//创建工具栏</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">creatActions</span><span class="params">()</span></span>;    <span class="comment">//创建动作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowNewFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowOpenFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadFile</span><span class="params">(QString &amp; filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">maybeSave</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">saveFile</span><span class="params">(QString &amp; filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">saveAs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPrintText</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeFormat</span><span class="params">(QTextCharFormat format)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowFontComBox</span><span class="params">(QString comboStr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowSizeSpinBox</span><span class="params">(QString spinValue)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowBoldBtn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowItalicBtn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowUnderlineBtn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowColorBtn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowCurrentFormatChanged</span><span class="params">(<span class="keyword">const</span> QTextCharFormat &amp;fmt)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowFind</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowReplace</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetBackgroundColor</span><span class="params">(QColor color)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetBackgroundImage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">closeEvent</span><span class="params">(QCloseEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QMenu * fileMenu;        <span class="comment">//菜单栏各项</span></span><br><span class="line">    QMenu * editMenu;</span><br><span class="line">    QMenu * personaliseMenu;</span><br><span class="line">    QMenu * helpMenu;</span><br><span class="line"></span><br><span class="line">    QToolBar * filetoolbar;  <span class="comment">//文件工具栏</span></span><br><span class="line">    QToolBar * fontToolBar;  <span class="comment">//字体工具栏</span></span><br><span class="line"></span><br><span class="line">    QImage img;</span><br><span class="line">    QString filePath;</span><br><span class="line">    QTextEdit * <span class="built_in">text</span>;</span><br><span class="line">    <span class="keyword">bool</span> isUntitled;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QAction * openFileAction;          <span class="comment">//文件菜单项</span></span><br><span class="line">    QAction * newFileAction;</span><br><span class="line">    QAction * saveFileAction;</span><br><span class="line">    QAction * saveasFileAction;</span><br><span class="line">    QAction * printFileAction;</span><br><span class="line">    QAction * exitAction;</span><br><span class="line"></span><br><span class="line">    QAction * copyAction;              <span class="comment">//编辑菜单项</span></span><br><span class="line">    QAction * pasteAction;</span><br><span class="line">    QAction * cutAction;</span><br><span class="line">    QAction * undoAction;</span><br><span class="line">    QAction * restoreAction;</span><br><span class="line">    QAction * findAction;</span><br><span class="line">    QAction * replaceAction;</span><br><span class="line"></span><br><span class="line">    QAction * setBkColorAction;</span><br><span class="line">    QAction * setBkImageAction;</span><br><span class="line"></span><br><span class="line">    QAction * helpInformationAction;   <span class="comment">//帮助菜单项</span></span><br><span class="line">    QAction * aboutSoftwareAction;</span><br><span class="line">    QAction * AboutAuthorAction;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QLabel * fontLabel1;               <span class="comment">//字体设置项</span></span><br><span class="line">    QFontComboBox * fontComboBox;</span><br><span class="line">    QLabel * fontLabel2;</span><br><span class="line">    QComboBox * sizeComboBox;</span><br><span class="line">    QToolButton * boldBtn;</span><br><span class="line">    QToolButton * italicBtn;</span><br><span class="line">    QToolButton * underlineBtn;</span><br><span class="line">    QToolButton * colorBtn;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong>    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.show();</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包软件下载"><a href="#打包软件下载" class="headerlink" title="打包软件下载"></a>打包软件下载</h2><p>链接: <a href="https://pan.baidu.com/s/1XMgTqUA8W6SK53glwjvlIA" target="_blank" rel="noopener">https://pan.baidu.com/s/1XMgTqUA8W6SK53glwjvlIA</a> 提取码: 5rgu</p><h2 id="程序源码下载"><a href="#程序源码下载" class="headerlink" title="程序源码下载"></a>程序源码下载</h2><p>链接: <a href="https://pan.baidu.com/s/1vexQe1EKGsA0fglpsDeLow" target="_blank" rel="noopener">https://pan.baidu.com/s/1vexQe1EKGsA0fglpsDeLow</a> 提取码: k1kq</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本人 QQ 2694218551，欢迎加我一起讨论编程问题！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了Qt5实例开发之文本编辑器…&lt;/p&gt;
    
    </summary>
    
    
      <category term="QT5学习" scheme="https://wuhongbin.github.io/categories/QT5%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="QT5" scheme="https://wuhongbin.github.io/tags/QT5/"/>
    
  </entry>
  
  <entry>
    <title>Qt5 程序打包发布总结</title>
    <link href="https://wuhongbin.github.io/2020/04/15/Qt5%20%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/04/15/Qt5%20%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-15T12:10:43.000Z</published>
    <updated>2020-04-17T13:05:09.418Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了Qt5程序打包发布总结…</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当我们用QT写好了一个软件，要把你的程序分享出去的时候，不可能把编译的目录拷贝给别人去运行。编译好的程序应该是一个主程序，加一些资源文件，再加一些动态链接库，高大上一些的还可以做一个安装文件。</p><p>QT开发的程序发布的时候经常采用两种方式：</p><ol><li><strong>静态编译</strong>：可生成单一的可执行文件</li><li><strong>动态编译</strong>：需同时附上需要的dll文件。</li></ol><h2 id="发布准备"><a href="#发布准备" class="headerlink" title="发布准备"></a>发布准备</h2><h3 id="设置程序图标"><a href="#设置程序图标" class="headerlink" title="设置程序图标"></a>设置程序图标</h3><ol><li><p><strong>主窗口图标</strong>：主要在程序运行时显示在主窗口左上角，或在任务栏上显示。</p></li><li><p><strong>运行程序图标</strong>：一般在桌面或文件夹中显示的缩略图标，可以点击后运行程序。</p></li></ol><h4 id="设置主窗口图标"><a href="#设置主窗口图标" class="headerlink" title="设置主窗口图标"></a>设置主窗口图标</h4><p>（1）首先在绘图工具（例如Photoshop）中设计好图标，图标的分辨率最好大于32<em>32。图标需要用</em>ico或*png的文件。如果想偷懒一点，直接去<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">这里</a>（<a href="https://www.iconfont.cn/）下载，大量好看免费的图标。" target="_blank" rel="noopener">https://www.iconfont.cn/）下载，大量好看免费的图标。</a></p><p>（2）将刚才的生成的图标文件放到yourProjectFolder/Resources/images目录下,或者任意一个程序可以找到的位置。最好将图标文件添加到qrc中统一管理。</p><p>（3）然后再主窗口中使用，代码如下，代码很简单，不过记住这句代码一定要放到 *<em>Mainwindow *</em>的构造函数里去，不然不会work。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*setwindowicon*/</span></span><br><span class="line"> setWindowIcon(QIcon(QStringLiteral(<span class="string">":/background/mainlogo"</span>)));<span class="comment">//括号写你自己实际路径就好</span></span><br></pre></td></tr></table></figure><p>程序运行后的效果如下：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/04/17/JZrtnf.png" alt=""></p><h4 id="设置运行程序的图标"><a href="#设置运行程序的图标" class="headerlink" title="设置运行程序的图标"></a>设置运行程序的图标</h4><p>使用QTCreator的IDE开发工具</p><p>如果你是使用qmake生成makefile文件或使用QT Creator IDE，那么按下面三步实施：</p><p>（1）创建一个包含图标图像的ICO文件，并将其保存在资源文件目录下，例如命名为：myapp.ico；</p><p>（2）新建一个.rc 文件    新建文件–&gt;C++–&gt;source文件–&gt;命名为  myapp.rc  (不能掉了rc后缀)</p><p>​        <strong>打开rc文件添加如下一行代码。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDI_ICON1 ICON DISCARDABLE <span class="string">"myapp.ico"</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>myapp.ico 是你的exe程序图标名。</p><p>​       <strong>最后在pro文件添加一行代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RC_FILE += myapp.rc</span><br></pre></td></tr></table></figure><p>保存项目重新编译，exe图标和执行时window图标都将发生变化。</p><h3 id="编译release版本程序"><a href="#编译release版本程序" class="headerlink" title="编译release版本程序"></a>编译release版本程序</h3><p>注意将运行程序编译方式设置成Release，因为debug版本的程序中包含了调试信息，可以用来调试。而真正要发布程序时，要使用release版本，这样可以减少发布程序的体积同时增加软件的安全。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/04/17/JZrFh9.png" alt=""></p><p>上图演示在Qt Creator中的设置方式，选中IDE左边的侧边栏的项目，然后再构建设置中将构建配置设置为Release。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/04/17/JZDDOK.png" alt=""></p><p>上图演示在VS2015中的设置方式，选中IDE右边的解决方案管理器中的项目，然后在IDE上边的工具栏中将构建配置设置为Release。</p><h2 id="发布程序"><a href="#发布程序" class="headerlink" title="发布程序"></a>发布程序</h2><p>Qt官方开发环境默认使用动态链接库方式，在发布生成的可执行程序时，我们需要复制一大堆动态库，如果自己去复制动态库，很可能丢三落四，导致程序在别的电脑里无法正常运行。 因此 Qt 官方开发环境里自带了一个部署工具来帮助开发者自动拷贝大部分的依赖库。在不同的平台使用方式也有所不同。</p><h3 id="windows平台"><a href="#windows平台" class="headerlink" title="windows平台"></a>windows平台</h3><p>Windows开发环境下 *<em>windeployqt *</em>工具 (如果你已经将Qt的bin目录加入PATH环境,那么你可以直接在命令行使用windeployqt调用.)。</p><p>（1）将项目中的release文件中的可执行文件拷到一个新建的文件夹中，例如project.exe，</p><p>（2）用Qt自带的生成必备的dll文件的程序windeployqt，来把必要的动态库拷到该文件夹中。</p><p>打开命令行，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windeployqt  project.exe</span><br></pre></td></tr></table></figure><p>这时候大部分的dll文件都自动拷贝过来了，但是如果项目还用了一些其他的SDK，比如OpenCV，Chartdir51等等，就需要手动将所需dll拷贝过来，如果不知道还需要哪些软件，可以用Dependency Walker来查看缺少哪些dll文件。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/04/17/JZDywD.png" alt=""></p><p>拷贝完成后文件夹下的文件清单如下：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/04/17/JZDseO.png" alt=""></p><p><strong>注意：</strong>如果发布的应用是<strong>Qt Quick Application应用</strong>，那么命令行需要加上<strong>QML的安装目录</strong>。命令中的D:\Qt\Qt5.5.1\qml是qml的安装目录,请换成你自己的qml安装目录!!!!!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windeployqt hello.exe--qmldir D:\Qt\Qt5.5.1\qml</span><br></pre></td></tr></table></figure><h3 id="linux平台"><a href="#linux平台" class="headerlink" title="linux平台"></a><strong>linux平台</strong></h3><p>在X11平台下qt程序，首先准备好程序中需要使用的资源，库和插件…，比如你的可运行程序取名叫作panel，那把你的panel,那些libQt<em>.so.4和libQt</em>.so.4.6.0（链接和共享库都要）放在同一目录下(也可以不同,只要小小修改下shell文件).plugins就不多说了。</p><p>在程序的同目录下，新建一個空文档，取名panel.sh (文件名与程序名同名,扩展名为sh,shell文件)。在panel.sh中原封不动的写入以下语句:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">appname&#x3D;&#96;basename $0 | sed s,&#x2F;.sh$,,&#96;</span><br><span class="line"></span><br><span class="line">  dirname&#x3D;&#96;dirname$0&#96;</span><br><span class="line"></span><br><span class="line">  tmp&#x3D;&quot;$&#123;dirname#?&#125;&quot;</span><br><span class="line"></span><br><span class="line">  if [&quot;$&#123;dirname%$tmp&#125;&quot; !&#x3D; &quot;&#x2F;&quot; ]; then</span><br><span class="line"></span><br><span class="line">   dirname&#x3D;$PWD&#x2F;$dirname</span><br><span class="line"></span><br><span class="line"> fi</span><br><span class="line"></span><br><span class="line">   LD_LIBRARY_PATH&#x3D;$dirname</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">   $dirname&#x2F;$appname$*</span><br></pre></td></tr></table></figure><p>保存文件，退出。在终端給文件+x属性: 切换到程序的目录，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x panel.sh</span><br></pre></td></tr></table></figure><p>然后运行shell文件就行了（确保panel程序具备X属性）,它会自动更改环境变量,运行程序。</p><p>如果要调试shell文件,只需要在终端输入:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -x panel.sh</span><br></pre></td></tr></table></figure><p>这样就 ok 了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>现在你就可以把现在的文件夹压缩成一个压缩包，分享给你的朋友使用了！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了Qt5程序打包发布总结…&lt;/p&gt;
    
    </summary>
    
    
      <category term="QT5学习" scheme="https://wuhongbin.github.io/categories/QT5%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="QT5" scheme="https://wuhongbin.github.io/tags/QT5/"/>
    
  </entry>
  
  <entry>
    <title>Qt 项目管理文件（.pro）及其作用详解</title>
    <link href="https://wuhongbin.github.io/2020/04/05/Qt%20%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%EF%BC%88.pro%EF%BC%89%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://wuhongbin.github.io/2020/04/05/Qt%20%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%EF%BC%88.pro%EF%BC%89%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-04-05T11:10:43.000Z</published>
    <updated>2020-04-16T11:57:04.367Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下 Qt项目管理文件（.pro）及其作用详解…</p><a id="more"></a><h1 id="Qt项目管理文件（-pro）及其作用详解"><a href="#Qt项目管理文件（-pro）及其作用详解" class="headerlink" title="Qt项目管理文件（.pro）及其作用详解"></a>Qt项目管理文件（.pro）及其作用详解</h1><h2 id="项目文件目录树"><a href="#项目文件目录树" class="headerlink" title="项目文件目录树"></a>项目文件目录树</h2><p>在 Qt Creator 中新建一个 Widget Application 项目 samp2_1，在选择窗口基类的页面选择 QWidget 作为窗体基类，并选中“Generate form”复选框。创建后的项目文件目录树如图 1 所示。</p><p> <img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/181229/2-1Q22Z95914431.gif" alt="img"><br> 图 1 项目文件的目录树</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p> 这个项目包含以下一些文件：</p><blockquote><p>（1）项目管理文件 samp2_1.pro，存储项目设置的文件。</p><p>（2）主程序入口文件 main.cpp，实现 main()函数的程序文件。</p><p>（3）窗体界面文件 widget.ui，一个 XML 格式存储的窗体上的元件及 其布局的文件。</p><p>（4）widget.h 是所设计的窗体类的头文件，widget.cpp 是 widget.h 里 定义类的实现文件。C++中，任何窗体或界面组件都是用类封装的，一个类一般有一个头文件（.h 文件）和一个源程序文件（.cpp 文件）。</p></blockquote><h2 id="项目管理文件（-pro文件）"><a href="#项目管理文件（-pro文件）" class="headerlink" title="项目管理文件（.pro文件）"></a>项目管理文件（.pro文件）</h2><p> 下面介绍一下项目管理文件（.pro文件）。</p><p>后缀为“ <strong>.pro</strong> ”的文件是项目的管理文件，文件名就是项目的名称，如本项目中的 <strong>samp2_1.pro</strong>。 下面是 *<em>samp2_1.pro *</em>文件的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QT       += core gui</span><br><span class="line">greaterThan(QT_MAJOR_VERSION, <span class="number">4</span>): QT += widgets</span><br><span class="line">TARGET = samp2_1</span><br><span class="line">TEMPLATE = app</span><br><span class="line">SOURCES += \</span><br><span class="line">        main.cpp \</span><br><span class="line">        widget.cpp</span><br><span class="line">HEADERS += \</span><br><span class="line">        widget.h</span><br><span class="line">FORMS += \</span><br><span class="line">        widget.ui</span><br></pre></td></tr></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>项目管理文件用于记录项目的一些设置，以及项目包含文件的组织管理。</p><h3 id="代码介绍"><a href="#代码介绍" class="headerlink" title="代码介绍"></a>代码介绍</h3><p>（1）“Qt += core gui”表示项目中加入 core gui 模块。core gui 是 Qt 用于 GUI 设计的类库模块，如果创建的是控制台（Console）应用程序，就不需要添加 core gui。</p><p>（2） Qt 类库以模块的形式组织各种功能的类，根据项目涉及的功能需求，在项目中添加适当的类库模块支持。例如，如果项目中使用到了涉及数据库操作的类就需要用到 sql 模块，在 pro 文件中需要增加如下一行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Qt +=sql</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/images/qt5.png" alt=""></p><p>（3）samp2_1.pro 中的第 2 行是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">greaterThan(Qt_MAJOR_VERSION, <span class="number">4</span>): Qt += widgets</span><br></pre></td></tr></table></figure><p>这是个条件执行语句，表示当 Qt 主版本大于 <strong>4</strong> 时，才加入 widgets 模块。</p><p> （4）“ TARGET = samp2_1 ”表示生成的目标可执行文件的名称，即编译后生成的可执行文件是 samp2_1.exe。</p><p> （5）“TEMPLATE = app”表示项目使用的模板是 app，即 application，是一般的应用程序。</p><p> （6）后面的 SOURCES、HEADERS、FORMS 记录了项目中包含的源程序文件、头文件和窗体文件（.ui 文件）的名称。这些文件列表是 Qt  Creator  自动添加到项目管理文件里面的，用户不需要手动修改。当添加一个文件到项目，或从项目里删除一个文件时，项目管理文件里的条目会自动修改。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下 Qt项目管理文件（.pro）及其作用详解…&lt;/p&gt;
    
    </summary>
    
    
      <category term="QT5学习" scheme="https://wuhongbin.github.io/categories/QT5%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="QT5" scheme="https://wuhongbin.github.io/tags/QT5/"/>
    
  </entry>
  
  <entry>
    <title>Qt Creator 常用快捷键</title>
    <link href="https://wuhongbin.github.io/2020/04/05/Qt%20Creator%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/04/05/Qt%20Creator%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-05T10:10:43.000Z</published>
    <updated>2020-04-10T14:03:40.779Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下 Qt Creator 常用快捷键…</p><a id="more"></a><h1 id="Qt-Creator-常用快捷键"><a href="#Qt-Creator-常用快捷键" class="headerlink" title="Qt Creator 常用快捷键"></a>Qt Creator 常用快捷键</h1><table><thead><tr><th align="center">快捷键</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">F1</td><td align="center">查看帮助文档</td></tr><tr><td align="center">Shift + F2</td><td align="center">函数的声明和定义之间快速切换</td></tr><tr><td align="center">F4</td><td align="center">对应.h 文件和对应.cpp 文件切换</td></tr><tr><td align="center">Ctrl + /</td><td align="center">代码注释及取消注释（前提是选中代码）</td></tr><tr><td align="center">Ctrl + 鼠标滚轮向上向下</td><td align="center">调整字体变大变小</td></tr><tr><td align="center">ctrl + shift + 键盘方向键</td><td align="center">移动代码（前提是选中所要移动的代码）</td></tr><tr><td align="center">ctrl + f</td><td align="center">查找替换关键字</td></tr><tr><td align="center">Ctrl + B</td><td align="center">只编译（Build）不运行</td></tr><tr><td align="center">Ctrl + R</td><td align="center">编译并运行（run）</td></tr><tr><td align="center">Ctrl + I</td><td align="center">自动缩进当前行</td></tr><tr><td align="center">Ctrl +M</td><td align="center">创建书签</td></tr><tr><td align="center">Ctrl + .</td><td align="center">切换书签</td></tr><tr><td align="center">Alt + M</td><td align="center">打开书签栏</td></tr><tr><td align="center">Ctrl + [</td><td align="center">光标跳到程序段开头</td></tr><tr><td align="center">Ctrl + ]</td><td align="center">光标跳到程序段结尾</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下 Qt Creator 常用快捷键…&lt;/p&gt;
    
    </summary>
    
    
      <category term="QT5学习" scheme="https://wuhongbin.github.io/categories/QT5%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="QT5" scheme="https://wuhongbin.github.io/tags/QT5/"/>
    
  </entry>
  
  <entry>
    <title>C++ 函数模板实现机制原理剖析</title>
    <link href="https://wuhongbin.github.io/2020/04/03/C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <id>https://wuhongbin.github.io/2020/04/03/C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</id>
    <published>2020-04-03T11:10:43.000Z</published>
    <updated>2020-04-10T14:05:22.933Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下 函数模板实现机制原理剖析..</p><a id="more"></a><h1 id="C-函数模板实现机制原理剖析"><a href="#C-函数模板实现机制原理剖析" class="headerlink" title="C++ 函数模板实现机制原理剖析"></a>C++ 函数模板实现机制原理剖析</h1><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ol><li><p>编译器并不是把函数模板处理成能够处理任意类的函数</p></li><li><p>编译器从函数模板通过具体类型来产生不同的函数</p></li><li><p>编译器会对函数模板进行两次编译</p><p>（1）在声明的位置对模板代码进行编译</p><p>（2）在调用的位置对参数替换后的代码进行编译</p></li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>自己的代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//声明位置，第一次编译</span></span><br><span class="line"><span class="function">T  <span class="title">myswap</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用模板函数!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myswap(<span class="number">1</span>,<span class="number">1</span>);         <span class="comment">//调用位置，第二次编译</span></span><br><span class="line">    myswap(<span class="string">'a'</span>,<span class="string">'b'</span>);</span><br><span class="line">    myswap(<span class="number">2.0</span>,<span class="number">3.0</span>);        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实际编译器处理后的代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>     <span class="title">myswap</span><span class="params">(<span class="keyword">int</span>  a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用模板函数!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span>  <span class="title">myswap</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用模板函数!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">myswap</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用模板函数!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myswap(<span class="number">1</span>,<span class="number">1</span>);         </span><br><span class="line">    myswap(<span class="string">'a'</span>,<span class="string">'b'</span>);</span><br><span class="line">    myswap(<span class="number">2.0</span>,<span class="number">3.0</span>);        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ol><li><p>函数模板不是说只 <strong>一个函数</strong> 就可以实现对任意数据类型的操作，而是通过两次编译生成了满足我们调用需求所需要的所有代码。</p></li><li><p>函数模板使用后，编译器并不会一开始就生成所有处理任何类型的函数，而是通过实际的函数调用来生成。比如调用函数时，需要处理int型数据，就生成处理int型数据的函数，而没有用double型数据，就不会生成处理double型数据的函数。</p></li><li><p>编译器内部帮我们实现了大量重复操作，让程序员节省了大量代码</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下 函数模板实现机制原理剖析..&lt;/p&gt;
    
    </summary>
    
    
      <category term="C / C + +" scheme="https://wuhongbin.github.io/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://wuhongbin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 函数模板和函数重载同时出现如何调用</title>
    <link href="https://wuhongbin.github.io/2020/04/03/C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8/"/>
    <id>https://wuhongbin.github.io/2020/04/03/C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8/</id>
    <published>2020-04-03T10:10:43.000Z</published>
    <updated>2020-04-10T14:05:51.711Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下 C++ 函数模板和函数函数重载同时出现如何调用..</p><a id="more"></a><h1 id="C-函数模板和函数重载同时出现如何调用"><a href="#C-函数模板和函数重载同时出现如何调用" class="headerlink" title="C++ 函数模板和函数重载同时出现如何调用"></a>C++ 函数模板和函数重载同时出现如何调用</h1><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ol><li>函数模板<strong>不允许自动转换</strong>，普通函数<strong>可以进行自动类型转换</strong></li><li>函数模板可以像普通函数一样被<strong>重载</strong></li><li>C++编译器<strong>优先考虑调用普通函数</strong></li><li>如果函数模板可以<strong>产生一个更好的匹配</strong>，则选择模板函数</li><li>可以通过<strong>空模板实参列表</strong>的语法限定编译器只调用模板函数</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数和模板函数  函数名相同  形成函数重载</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myswap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用普通函数!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T  <span class="title">myswap</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用2个参数 模板函数!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T  <span class="title">myswap</span><span class="params">(T a, T b, T c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用3个参数 模板函数!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'z'</span>; </span><br><span class="line">    myswap(a,a);       <span class="comment">//优先考虑普通函数，匹配成功</span></span><br><span class="line">    myswap&lt;&gt;(a,a);     <span class="comment">//指定使用函数模板，使用空模板实参列表的语法，即 &lt;&gt;</span></span><br><span class="line">    myswap(c,a);       <span class="comment">//普通函数调用，进行隐式类型转换</span></span><br><span class="line"></span><br><span class="line">    myswap(<span class="number">3.0</span>, <span class="number">4.0</span>);  <span class="comment">//调用函数模板可以产生一个更好的匹配，使用函数模板，而普通函数参数是int型</span></span><br><span class="line">    myswap(<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">4.0</span>);   <span class="comment">//函数重载，3个参数版本</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下 C++ 函数模板和函数函数重载同时出现如何调用..&lt;/p&gt;
    
    </summary>
    
    
      <category term="C / C + +" scheme="https://wuhongbin.github.io/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://wuhongbin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 内存四区 理解总结</title>
    <link href="https://wuhongbin.github.io/2020/04/01/C++%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93/"/>
    <id>https://wuhongbin.github.io/2020/04/01/C++%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93/</id>
    <published>2020-03-31T19:10:43.000Z</published>
    <updated>2020-04-17T13:36:28.142Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下 C++ 内存四区…</p><a id="more"></a><h2 id="内存模型图（4G）"><a href="#内存模型图（4G）" class="headerlink" title="内存模型图（4G）"></a>内存模型图（4G）</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/04/17/JZrp0U.png" alt="img"></p><h3 id="整体简单说明"><a href="#整体简单说明" class="headerlink" title="整体简单说明"></a>整体简单说明</h3><p>32位CPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中 <strong>0~3G是用户空间</strong>，<strong>3~4G是内核空间</strong>即<strong>3G用户空间和1G内核空间</strong>，不同进程相同的逻辑地址会映射到不同的物理地址中。</p><h3 id="各段详细说明"><a href="#各段详细说明" class="headerlink" title="各段详细说明"></a>各段详细说明</h3><p><strong>静态区域：</strong></p><p>text segment(<strong>代码段</strong>):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p><p>data segment(<strong>数据段</strong>)：存储程序中已初始化的全局变量和静态变量</p><p>bss segment(<strong>BSS段</strong>)：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0</p><p><strong>动态区域：</strong></p><p>heap（<strong>堆区</strong>）：  当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。</p><p>memory mapping segment(<strong>映射区</strong>):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）</p><p>stack（<strong>栈区</strong>）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。</p><h2 id="内存四区"><a href="#内存四区" class="headerlink" title="内存四区"></a>内存四区</h2><p>一个由C/C++编译的程序占用的内存分为以下几个部分：</p><ol><li><p><strong>栈区(stack)</strong>：就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是函数的返回地址、参数、局部变量、返回值等，从高地址向低地址增长。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。其操作方式类似于数据结构中的栈。</p></li><li><p><strong>堆区(heap)</strong>： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。</p><p>​    <strong>堆</strong>：是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free()可把内存交还。</p><p>​    <strong>自由存储区</strong>：自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区和堆区就有区别了。</p></li><li><p><strong>数据区</strong>：主要包括静态全局区和静态区，如果要站在汇编角度细分的话还可以分为很多小的区。</p><p>​    <strong>全局区&amp;静态区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的 C 语言中，全局变量和静态变量又分为</p></li></ol><p>　　　　全局初始化区(<strong>DATA段</strong>) ：存储程序中已初始化的全局变量和静态变量</p><p>　　　　未初始化段(<strong>BSS段</strong>) ：存储未初始化的全局变量和静态变量（局部+全局）。BSS段在DATA段的相邻的  另一块区域。BBS段特点：在程序执行前BBS段自动清零，所以未初始化的全局变量和静态变量在程序执行前已经成为0。</p><p>　　<font color=red><strong>在 C++ 里面没有这个区分了，它们共同占用同一块内存区。</strong></font></p><ol start="4"><li><strong>代码区</strong>：包括<strong>只读存储区</strong>和<strong>文本区</strong>，其中<strong>只读存储区</strong>存储<strong>字符串常量</strong>，就是常量区，<strong>文本区</strong>存储<strong>程序的机器代码</strong>。</li></ol><h2 id="明确区分堆与栈"><a href="#明确区分堆与栈" class="headerlink" title="明确区分堆与栈"></a>明确区分堆与栈</h2><p>在 BBS 上，堆与栈的区分问题，似乎是一个永恒的话题，由此可见，初学者对此往往是混淆不清的，所以我决定拿他第一个开刀。</p><p>首先，我们举一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; &#125;</span><br></pre></td></tr></table></figure><p>这条短短的一句话就包含了堆与栈，看到 new，我们首先就应该想到，我们分配了一块堆内存，那么指针 p  呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针 p。在程序会先确定在堆中分配内存的大小，然后调用  operator new 分配内存，然后返回这块内存的首地址，放入栈中，他在 VC6 下的汇编代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00401028</span>push <span class="number">14</span>h</span><br><span class="line"><span class="number">0040102</span><span class="function">Acall <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="number">00401060</span>)</span></span></span><br><span class="line">0040102Fadd esp,4</span><br><span class="line"><span class="number">00401032</span>mov dword ptr [ebp<span class="number">-8</span>],eax</span><br><span class="line"><span class="number">00401035</span>mov eax,dword ptr [ebp<span class="number">-8</span>]</span><br><span class="line"><span class="number">00401038</span>mov dword ptr [ebp<span class="number">-4</span>],eax</span><br></pre></td></tr></table></figure><p>这里，我们为了简单并没有释放内存，那么该怎么去释放呢？</p><p>是 delete p 么？噢，错了，应该是 delete []p，这是为了告诉编译器：我删除的是一个数组，VC6 就会根据相应的 Cookie 信息去进行释放内存的工作。</p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>好了，我们回到我们的主题：堆和栈究竟有什么区别？主要的区别由以下几点：</p><ol><li>管理方式不同；</li><li>空间大小不同；</li><li>能否产生碎片不同；</li><li>生长方向不同；</li><li>分配方式不同；</li><li>分配效率不同；</li></ol><p><strong><font color=red>管理方式：</font></strong>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p><p><strong><font color=red>空间大小：</font></strong>一般来讲在 32  位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：打开工程，依次操作菜单如下：Project-&gt;Setting-&gt;Link，在 Category 中选中 Output，然后在 Reserve 中设定堆栈的最大值和 commit。注意：reserve 最小值为  4Byte；commit 是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。</p><p><strong><font color=red>碎片问题：</font></strong>对于堆来讲，频繁的  new/delete  势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。</p><p><strong><font color=red>生长方向：</font></strong>对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</p><p><strong><font color=red>分配方式：</font></strong>堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p><p><strong><font color=red>分配效率：</font></strong>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是 C/C++  函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><p>​        从这里我们可以看到，堆和栈相比，由于大量 new/delete  的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP 和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。</p><p>　　虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。</p><p>　　无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候 debug 可是相当困难的）</p><p>　　对了，还有一件事，如果有人把堆栈合起来说，那它的意思是栈，可不是堆，呵呵，清楚了？</p><h2 id="static-用来控制变量的存储方式和可见性"><a href="#static-用来控制变量的存储方式和可见性" class="headerlink" title="static 用来控制变量的存储方式和可见性"></a>static 用来控制变量的存储方式和可见性</h2><p>函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？  最容易想到的方法是定义一个全局的变量，但定义为一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅受此函数控制）。需要一个数据对象为整个类而非某个对象服务，同时又力求不破坏类的封装性，即要求此成员隐藏在类的内部，对外不可见。</p><p><strong>static 的内部机制：</strong></p><p>　　静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；三是应用程序的 main(）函数前的全局数据声明和定义处。</p><p>　　静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的“尺寸和规格”，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。</p><p>　　static 被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。</p><p><strong>static 的优势：</strong></p><p>　　可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。引用静态数据成员时，采用如下格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;静态成员名&gt;</span><br></pre></td></tr></table></figure><p>　　如果静态数据成员的访问权限允许的话(即 public 的成员)，可在程序中，按上述格式来引用静态数据成员。</p><p>Ps：</p><p>　　(1) 类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。</p><p>　　(2) 不能将静态成员函数定义为虚函数。</p><p>　　(3) 由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针，函数地址类型是一个“nonmember 函数指针”。</p><p>　　(4) 由于静态成员函数没有 this 指针，所以就差不多等同于 nonmember 函数，结果就产生了一个意想不到的好处：成为一个  callback 函数，使得我们得以将 c++ 和 c-based x window 系统结合，同时也成功的应用于线程函数身上。</p><p>　　(5) static 并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。</p><p>　　(6) 静态数据成员在&lt;定义或说明&gt;时前面加关键字 static。</p><p>　　(7) 静态数据成员是静态存储的，所以必须对它进行初始化。</p><p>　　(8) 静态成员初始化与一般数据成员初始化不同：</p><p>　　初始化在类体外进行，而前面不加 static，以免与一般静态变量或对象相混淆；</p><p>　　初始化时不加该成员的访问权限控制符 private、public；</p><p>　　初始化时使用作用域运算符来标明它所属类；</p><p>　　所以我们得出静态数据成员初始化的格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</span><br></pre></td></tr></table></figure><p>　　(9)  为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。</p><p>​        <strong>注意：</strong>我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</p><h2 id="函数调用模型"><a href="#函数调用模型" class="headerlink" title="函数调用模型"></a>函数调用模型</h2><p>变量三要素是：名称、大小、作用域。那么变量的生命周期是多长呢？</p><p>编译器是如何管理每个函数间变量的生命周期呢？</p><p>要研究变量的生命周期，而变量一般又是在函数中定义分配空间的。</p><p>因此下面研究一下变量作为函数参数和返回值传递分析,下面我们具体总结一下，各个函数的变量的生命周期</p><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190809175733510-648621844.png" alt=""></p><p>main里面的变量分配内存，函数fa(),函数fb()中的变量分配的内存空间它们的生命周期都是多长呢？</p><p>开始已经说明了内存主要分为四区，因此每个函数中变量在堆栈的生命周期是不同的，同时在函数调用的时候，先执行的函数最后才执行完毕</p><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190809175748821-260989720.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">fa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span>*pa = <span class="string">"123456"</span>;<span class="comment">//pa指针在栈区，“123456”在常量区，该函数调用完后指针变量pa就被释放了</span></span><br><span class="line">     <span class="keyword">char</span>*p = <span class="literal">NULL</span>;     <span class="comment">//指针变量p在栈中分配4字节</span></span><br><span class="line">     p=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);<span class="comment">//本函数在这里开辟了一块堆区的内存空间，并把地址赋值给p</span></span><br><span class="line">     <span class="built_in">strcpy</span>(p, <span class="string">"wudunxiong 1234566"</span>);<span class="comment">//把常量区的字符串拷贝到堆区</span></span><br><span class="line">     <span class="keyword">return</span> p;<span class="comment">//返回给主调函数fb()，相对fa来说fb是主调函数，相对main来说，fa(),fb()都是被调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">fb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span>*pstr = <span class="literal">NULL</span>;</span><br><span class="line">     pstr = fa();</span><br><span class="line">     <span class="keyword">return</span> pstr;<span class="comment">//指针变量pstr在这就结束</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     <span class="keyword">char</span>*str = <span class="literal">NULL</span>;</span><br><span class="line">     str = fb();</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"str = %s\n"</span>,str);</span><br><span class="line">     <span class="built_in">free</span>(str);    <span class="comment">//防止内存泄露，被调函数fa()分配的内存存的值通过返回值传给主调函数，然后主调函数释放内存</span></span><br><span class="line">     str = <span class="literal">NULL</span>;<span class="comment">//防止产生野指针</span></span><br><span class="line">     system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用总结：</p><ol><li><p>主调函数分配的内存空间（堆，栈，全局区）可以在被调用函数中使用，可以以指针作函数参数的形式来使用</p></li><li><p>被调用函数分配的内存空间只有堆区和全局区可以在主调函数中使用（返回值和函数参数），而栈区却不行，因为栈区函数体运行完之后这个函数占用的内存编译器自动帮你释放了。</p></li><li><p>一定要明白函数的主被调关系以及主被调函数内存分配回收，也就是后面接下几篇总结的函数的输入输出内存模型</p></li></ol><p>[参考: <a href="https://www.cnblogs.com/WindSun/p/11328820.html]" target="_blank" rel="noopener">https://www.cnblogs.com/WindSun/p/11328820.html]</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下 C++ 内存四区…&lt;/p&gt;
    
    </summary>
    
    
      <category term="C / C + +" scheme="https://wuhongbin.github.io/categories/C-C/"/>
    
    
      <category term="内存四区" scheme="https://wuhongbin.github.io/tags/%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>C++ 重载、重写、重定义的区别</title>
    <link href="https://wuhongbin.github.io/2020/03/21/C++%20%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%87%8D%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://wuhongbin.github.io/2020/03/21/C++%20%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%87%8D%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-03-21T10:10:43.000Z</published>
    <updated>2020-04-10T14:00:11.069Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文我总结了一下C++ 重载、重写、重定义的区别…</p><a id="more"></a><h1 id="C-中-重载、重写、重定义的区别"><a href="#C-中-重载、重写、重定义的区别" class="headerlink" title="C++ 中 重载、重写、重定义的区别"></a>C++ 中 重载、重写、重定义的区别</h1><h2 id="重载（overload）"><a href="#重载（overload）" class="headerlink" title="重载（overload）"></a>重载（overload）</h2><p><strong>定义：</strong></p><p>在同一个作用域内，两函数的<strong>函数名相同</strong>, <strong>参数不相同</strong>（可以是参数类型不同或者是参数个数不同）, 那么就说这两个 <strong>函数重载</strong>。</p><p><strong>分类：</strong>函数重载 和 运算符重载 （本质都一样）</p><p><strong>注意：</strong> 返回值类型 <strong>不是</strong> 函数重载判断依据。</p><p><strong>成员函数重载特征：</strong></p><blockquote><p><strong>a : 相同的范围（在同一个类中）</strong></p><p><strong>b : 函数名字相同</strong></p><p><strong>c : 参数不同</strong></p></blockquote><p><strong>实现重载原理：</strong></p><p>C++代码在编译时会根据参数列表对函数进行重命名，例如void Test(int a, int b)会被重命名为_Test_int_int，void Test(int x, double y)会被重命名为_Test_int_double。所以说<strong>函数重载从底层上看它们还是不同的函数。</strong></p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"int a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"double a"</span> &lt;&lt; <span class="built_in">endl</span>;; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"int a , int b"</span> &lt;&lt; <span class="built_in">endl</span>;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//函数名相同，参数不同</span></span><br><span class="line">    fun(<span class="number">1</span>);</span><br><span class="line">    fun(<span class="number">1.1</span>);</span><br><span class="line">    fun(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>int a</p><p>double a</p><p>int a , int b</p></blockquote><h2 id="重写（override）"><a href="#重写（override）" class="headerlink" title="重写（override）"></a>重写（override）</h2><p><strong>定义：</strong></p><p>重写也叫做<strong>覆盖</strong>。子类 <strong>重新定义</strong> 父类中 <strong>有相同名称和参数</strong>  的 <strong>虚函数</strong>。函数<strong>特征相同</strong>，但是具体实现不同，主要是在<strong>继承关系</strong>中出现的 。简单说，<strong>重写(覆盖)</strong> 是指 <strong>派生类函数覆盖基类函数</strong> 。</p><p><strong>注意：</strong></p><ol><li><p>被重写的函数不能是 <strong>static</strong> 的。必须是 *<em>virtual *</em>的。</p></li><li><p>重写函数必须有 <strong>相同的类型，名称和参数列表</strong></p></li><li><p><strong>重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public,protected也是可以的</strong></p></li></ol><p><strong>特征：</strong></p><blockquote><p><strong>a : 不同的范围，分别位于基类和派生类中</strong></p><p><strong>b : 函数的名字相同</strong></p><p><strong>c : 参数相同</strong></p><p><strong>d : 基类函数必须有virtual关键字</strong></p></blockquote><p><strong>作用：</strong></p><blockquote><p>通过重写，可以实现动态多态，何为动态多态，就是当父类的指针或引用指向被重写的虚函数时，父类的指针或引用指向谁就调用谁的虚函数，而不是说根据类型。<br>在这里，如果去掉父类的虚函数的virtual，则构不成多态，如果去掉子类虚函数的virtual可以构成多态，可以理解为编译器优化。</p></blockquote><h2 id="重定义（redefining）"><a href="#重定义（redefining）" class="headerlink" title="重定义（redefining）"></a>重定义（redefining）</h2><p><strong>定义：</strong>重定义也叫做<strong>隐藏</strong>。子类 <strong>重新定义</strong> 父类中有 <strong>相同名称</strong> 的 <strong>非虚函数</strong> ( 参数列表可以不同 ) 。也就是说，<strong>重定义(隐藏)</strong> 是指 <strong>派生类的函数屏蔽了与其同名的基类函数</strong>。</p><p><strong>规则：</strong></p><blockquote><p><strong>a : 如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual，基类的函数被隐藏。</strong></p><p><strong>b : 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 vitual 关键字，此时，基类的函数被隐藏。</strong></p></blockquote><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>分析：</strong></p><p>很明显，<strong>子类隐藏了父类的f函数</strong>，这个题目比较迷惑人的是<strong>子类的f函数有参数</strong>，所以<strong>会以为调的是父类的f函数</strong>； 但是<strong>隐藏只与函数名有关</strong>，与<strong>参数</strong>是没关系的，所以<strong>调用的还是子类的f函数</strong>，这个程序会<strong>提示出错</strong>（可能是没有匹配的重载函数之类的错误）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文我总结了一下C++ 重载、重写、重定义的区别…&lt;/p&gt;
    
    </summary>
    
    
      <category term="C / C + +" scheme="https://wuhongbin.github.io/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://wuhongbin.github.io/tags/C-C/"/>
    
  </entry>
  
</feed>
