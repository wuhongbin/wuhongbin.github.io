<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Qt 信号与槽的自动关联机制</title>
      <link href="/2020/07/03/Qt%20%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E8%87%AA%E5%8A%A8%E5%85%B3%E8%81%94%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/07/03/Qt%20%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E8%87%AA%E5%8A%A8%E5%85%B3%E8%81%94%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于一些简单的事件判别，如点击按钮。无需写代码关联信号和槽函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;Btnshowhello,SIGNAL(clicked(<span class="keyword">bool</span>)),<span class="keyword">this</span>,SLOT(BtnshowhelloSlot()));</span><br></pre></td></tr></table></figure><h1 id="信号与槽的自动关联机制"><a href="#信号与槽的自动关联机制" class="headerlink" title="信号与槽的自动关联机制"></a>信号与槽的自动关联机制</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> on_&lt;object name&gt;_&lt;signal name&gt;(&lt;signal parameters&gt;);</span><br></pre></td></tr></table></figure><h1 id="例"><a href="#例" class="headerlink" title="例"></a>例</h1><p>按钮已在对应的.ui文件中放置，命名为 <strong>CloseBtn</strong></p><p>头文件中声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FORGETPWDWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FORGETPWDWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForgetPwdWindow</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ForgetPwdWindow</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~ForgetPwdWindow();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_CloseBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ForgetPwdWindow *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// FORGETPWDWINDOW_H</span></span></span><br></pre></td></tr></table></figure><p>CPP文件实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"forgetpwdwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_forgetpwdwindow.h"</span></span></span><br><span class="line"></span><br><span class="line">ForgetPwdWindow::ForgetPwdWindow(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::ForgetPwdWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ForgetPwdWindow::~ForgetPwdWindow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ForgetPwdWindow::on_CloseBtn_clicked</span><span class="params">()</span>        <span class="comment">//按下关闭按钮</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    emit <span class="keyword">this</span>-&gt;ForgetPwdWindowBack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Qt 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt 实时显示系统时间</title>
      <link href="/2020/07/03/Qt%20%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
      <url>/2020/07/03/Qt%20%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们用一个label控件来实时显示系统时间，用到 QTimer 和 QDateTime 这个两个类。</p><h1 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h1><blockquote><p><strong>头文件：</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDateTime&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~MainWindow();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">timerUpdate</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><blockquote><p><strong>实现函数：</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mainwindow.h"</span></span></span><br><span class="line"> </span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    QTimer *timer = <span class="keyword">new</span> QTimer(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(timer,SIGNAL(timeout()),<span class="keyword">this</span>,SLOT(timerUpdate()));</span><br><span class="line">    timer-&gt;start(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::timerUpdate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QDateTime time = QDateTime::currentDateTime();</span><br><span class="line">    QString str = time.toString(<span class="string">"yyyy-MM-dd hh:mm:ss dddd"</span>);</span><br><span class="line">    ui-&gt;label-&gt;setText(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>运行效果如下：</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20180202135649452?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDAzODg5MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Qt 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt 窗口阴影效果的实现</title>
      <link href="/2020/07/02/Qt%20%E7%AA%97%E5%8F%A3%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/07/02/Qt%20%E7%AA%97%E5%8F%A3%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天正好搞一下窗口的阴影，发现一篇文章写的真是不错。毫不犹豫滴转过来了，感谢作者分享。</p><p>转自：<a href="http://blog.sina.com.cn/s/blog_a6fb6cc90101eoop.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_a6fb6cc90101eoop.html</a></p><h1 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h1><p>前面就窗口阴影已经写过一篇博客，使用九宫格的思路实现的，在我看来，凡是用程序能实现的尽量不要使用图片代替（在保证效率的前提下），今天再次分享关于我的一些小见解！</p><p>  先看效果：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20140507161202265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcm9iZXJ0a3Vu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20140507161214687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcm9iZXJ0a3Vu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>窗口阴影任意调节，包括阴影像素、是否圆角等。直接上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DropShadowWidget::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPainterPath path;</span><br><span class="line">    path.setFillRule(Qt::WindingFill);</span><br><span class="line">    path.addRect(<span class="number">10</span>, <span class="number">10</span>, <span class="keyword">this</span>-&gt;<span class="built_in">width</span>()<span class="number">-20</span>, <span class="keyword">this</span>-&gt;<span class="built_in">height</span>()<span class="number">-20</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.setRenderHint(QPainter::Antialiasing, <span class="literal">true</span>);</span><br><span class="line">    painter.fillPath(path, QBrush(Qt::white));</span><br><span class="line"> </span><br><span class="line">    <span class="function">QColor <span class="title">color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        QPainterPath path;</span><br><span class="line">        path.setFillRule(Qt::WindingFill);</span><br><span class="line">        path.addRect(<span class="number">10</span>-i, <span class="number">10</span>-i, <span class="keyword">this</span>-&gt;<span class="built_in">width</span>()-(<span class="number">10</span>-i)*<span class="number">2</span>, <span class="keyword">this</span>-&gt;<span class="built_in">height</span>()-(<span class="number">10</span>-i)*<span class="number">2</span>);</span><br><span class="line">        color.setAlpha(<span class="number">150</span> - qSqrt(i)*<span class="number">50</span>);</span><br><span class="line">        painter.setPen(color);</span><br><span class="line">        painter.drawPath(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得加上这行代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAttribute(Qt::WA_TranslucentBackground);</span><br></pre></td></tr></table></figure><p>保证不被绘制上的部分透明，关于这行代码在一些Qt版本中会有副作用。</p><p>比如：最小化后窗体子组件失去焦点等问题。具体可以看Qt的这个Bug</p><p>（Widget  with Qt::FramelessWindowHint and Qt::WA_TranslucentBackground stops painting after minimize/restore）</p><p>一直使用的是VS集成Qt5插件（非OpenGL版本），一直存在这个问题，寻找各方面资料无果（真的很久，搞不夸张的说大半年应该是有的）。最后改换OpenGL版本的居然好了。。。问题的解决方式太过于诡异，真让人哭笑不得。在此记过，希望对后来人有帮助。</p><h2 id="为子部件添加阴影"><a href="#为子部件添加阴影" class="headerlink" title="为子部件添加阴影"></a>为子部件添加阴影</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QGraphicsDropShadowEffect *shadow_effect = <span class="keyword">new</span> QGraphicsDropShadowEffect(<span class="keyword">this</span>);</span><br><span class="line">shadow_effect-&gt;setOffset(<span class="number">-5</span>, <span class="number">5</span>);</span><br><span class="line">shadow_effect-&gt;setColor(Qt::gray);</span><br><span class="line">shadow_effect-&gt;setBlurRadius(<span class="number">8</span>);</span><br><span class="line">network_group_box-&gt;setGraphicsEffect(shadow_effect);</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20140507161403171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcm9iZXJ0a3Vu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Qt 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt 隐藏标题栏后实现窗口拖动、设置窗口透明</title>
      <link href="/2020/07/02/Qt%20%E9%9A%90%E8%97%8F%E6%A0%87%E9%A2%98%E6%A0%8F%E5%90%8E%E5%AE%9E%E7%8E%B0%E7%AA%97%E5%8F%A3%E6%8B%96%E5%8A%A8%E3%80%81%E8%AE%BE%E7%BD%AE%E7%AA%97%E5%8F%A3%E9%80%8F%E6%98%8E/"/>
      <url>/2020/07/02/Qt%20%E9%9A%90%E8%97%8F%E6%A0%87%E9%A2%98%E6%A0%8F%E5%90%8E%E5%AE%9E%E7%8E%B0%E7%AA%97%E5%8F%A3%E6%8B%96%E5%8A%A8%E3%80%81%E8%AE%BE%E7%BD%AE%E7%AA%97%E5%8F%A3%E9%80%8F%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="隐藏标题栏"><a href="#隐藏标题栏" class="headerlink" title="隐藏标题栏"></a>隐藏标题栏</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setWindowFlags(Qt::CustomizeWindowHint);</span><br><span class="line">setWindowFlags(Qt::FramelessWindowHint);</span><br></pre></td></tr></table></figure><blockquote><p><strong>两个函数都可以去掉标题栏，区别是第一个可以鼠标缩放窗口, 第二个不可以</strong>         </p></blockquote><h1 id="隐藏标题栏、任务栏显示、窗口置顶"><a href="#隐藏标题栏、任务栏显示、窗口置顶" class="headerlink" title="隐藏标题栏、任务栏显示、窗口置顶"></a>隐藏标题栏、任务栏显示、窗口置顶</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setWindowFlags(Qt::FramelessWindowHint | Qt::Tool | Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure><blockquote><p><strong>温馨提示：以上代码均在窗口构造函数中使用</strong></p></blockquote><h1 id="隐藏标题栏后实现拖动"><a href="#隐藏标题栏后实现拖动" class="headerlink" title="隐藏标题栏后实现拖动"></a>隐藏标题栏后实现拖动</h1><p>隐藏标题栏后窗体是无法拖动的，这个时候就需要重写mousePressEvent、mouseMoveEvent和mouseReleaseEvent。</p><h2 id="添加成员变量"><a href="#添加成员变量" class="headerlink" title="添加成员变量"></a>添加成员变量</h2><p>添加一个成员变量QPoint</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPoint m_lastPos;</span><br></pre></td></tr></table></figure><h2 id="重写鼠标点击事件"><a href="#重写鼠标点击事件" class="headerlink" title="重写鼠标点击事件"></a>重写鼠标点击事件</h2><p>重写mousePressEvent、mouseMoveEvent和mouseReleaseEvent函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_lastPos = event-&gt;globalPos();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;x() + (event-&gt;globalX() - m_lastPos.x()),</span><br><span class="line">               <span class="keyword">this</span>-&gt;y() + (event-&gt;globalY() - m_lastPos.y()));</span><br><span class="line">    m_lastPos = event-&gt;globalPos();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 其实这里的mouseReleaseEvent函数可以不用重写</span></span><br><span class="line">    m_lastPos = event-&gt;globalPos();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><blockquote><p><strong>解决鼠标按下其他控件后移动鼠标到QWidget区域时界面移动的问题</strong></p></blockquote><p>按照上面的写法，会出现一个问题，就是在按住当前界面上的控件时，当按住这个动作一直存在并将鼠标从控件移动到QWidget的区域时，界面也会跟着移动，并且这样的移动时直接跳了过去，这样就很不完美，而且在界面很小，控件很多的情况下，拖动显得非常卡顿，所以我们就需要在mouse事件中添加一个判断，判断当前鼠标按下是否是处于QWidget所在的区域。</p><p>修改很简单，在自定义QWidget界面类中添加一个bool型变量isPressedWidget。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isPressedWidget;</span><br></pre></td></tr></table></figure><p>然后在mousePressEvent、mouseMoveEvent和mouseReleaseEvent三个函数中各添上一行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_lastPos = event-&gt;globalPos();</span><br><span class="line">    isPressedWidget = <span class="literal">true</span>; <span class="comment">// 当前鼠标按下的即是QWidget而非界面上布局的其它控件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isPressedWidget) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;x() + (event-&gt;globalX() - m_lastPos.x()),</span><br><span class="line">                   <span class="keyword">this</span>-&gt;y() + (event-&gt;globalY() - m_lastPos.y()));</span><br><span class="line">        m_lastPos = event-&gt;globalPos();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 其实这里的mouseReleaseEvent函数可以不用重写</span></span><br><span class="line">    m_lastPos = event-&gt;globalPos();</span><br><span class="line">    isPressedWidget = <span class="literal">false</span>; <span class="comment">// 鼠标松开时，置为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设置窗口透明"><a href="#设置窗口透明" class="headerlink" title="设置窗口透明"></a>设置窗口透明</h1><p>在对窗体设置了背景图片，如果背景图片是不规则矩形，则在背景图片后，窗体会露出一部分很丑，这个时候可以将窗体的属性设为透明属性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAttribute(Qt::WA_TranslucentBackground);</span><br></pre></td></tr></table></figure><h1 id="设置窗体透明度"><a href="#设置窗体透明度" class="headerlink" title="设置窗体透明度"></a>设置窗体透明度</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setWindowOpacity(<span class="number">0.7</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Qt 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序之外部排序 详细总结</title>
      <link href="/2020/06/20/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/20/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p><strong>外部排序</strong> 通常采用归并排序方法。<br>首先，根据缓冲区的大小将外存上含有n个记录的文件分成若干长度为h的子文件，依次读入内存并利用有限的内部排序算法对它们进行排序，并将排序后得到的有序子文件重新写回外村，通常称这些有序子文件为 <strong>归并段或顺串</strong><br>然后，对这些归并段进行逐趟归并，使归并段逐渐由小到大直至得到整个有序文件</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCB076.png" alt=""></p><h2 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h2><p><strong>外部排序的总时间 = 内部排序所需时间 + 外存信息读写时间 + 内部归并所需时间</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCBgcd.png" alt=""></p><h2 id="失败树"><a href="#失败树" class="headerlink" title="失败树"></a>失败树</h2><p><strong>S趟归并总共需要比较的次数:</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCrXkV.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCyK8U.png" alt=""></p><p><strong>失败树：</strong> 树形选择排序的一种变体,可视为一棵完全二叉树  </p><p>每个叶结点存放各归并段在归并过程中当前参加比较的记录,  </p><p>内部结点用来记忆左右子树中的“失败者胜利者向上继续  进行比较,直到根结点</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCyPgg.png" alt=""></p><h2 id="置换-选择排序"><a href="#置换-选择排序" class="headerlink" title="置换-选择排序"></a>置换-选择排序</h2><p>设初始待排序文件为F, 初始归并段文件为FO, 内存工作区为WA, 内存工作区可容纳w个记录。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ol><li>从待排序文件F输入w个记录到工作区WA;  </li><li>从内存工作区WA中选出其中关键字取最小值的记录,记为 MINIMAX;  </li><li>将MINIMAX记录输出到FO中; </li><li>若F未读完,则从F输入下一个记录到WA中; </li><li>从WA中所有MINIMAX关键字比记录的关键字大的记录中选出最小的关键字记录,作为新的 MINIMAX;  </li><li>重复3~5, 直到WA中选不出新的MINIMA记录位置, 由此得到一 个初始归并段,输出一个归并段的结束标志到FO中;  </li><li>重复2~6, 直到WA为空。由此得到全部初始归并段。</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dC2rSf.png" alt=""></p><h1 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCRe9P.png" alt=""></p><p><strong>归并树：</strong> 用来描述m归并,并只有度为0和度为m的结点的严格m叉树</p><p>设由置换选择排序得到9个初始归并段  其记录的长度依次为9, 30, 12, 18, 3, 17, 2, 6, 24</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCo1Mt.png" alt=""></p><blockquote><p><strong>总IO次数为2*WPL=484</strong><br><strong>大带权路径长度之和为归并过程中的总读记录数</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCoLJH.png" alt=""></p><blockquote><p><strong>当叶子节点数不够时,增加权值为0的结点用来构造哈夫曼树</strong></p></blockquote><h3 id="补充虚段个数"><a href="#补充虚段个数" class="headerlink" title="补充虚段个数"></a>补充虚段个数</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dCTs1A.png" alt=""></p><p><strong>例子：</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/14/dC7rUU.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 外排序 </tag>
            
            <tag> 败者树 </tag>
            
            <tag> 最佳归并树 </tag>
            
            <tag> 置换-选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序之内部排序算法的比较与应用 详细总结</title>
      <link href="/2020/06/19/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%8E%E5%BA%94%E7%94%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/19/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%8E%E5%BA%94%E7%94%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><blockquote><p><strong>时空复杂度</strong>    <strong>稳定性</strong>    <strong>一趟排序的特点</strong> </p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/13/dpmV0K.png" alt=""></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p><strong>考虑因素:</strong>  数目、元素大小、关键字结构及分布、稳定性、存储  结构、辅助空间等 </p><ol><li>若n较小时(n≤50),可采用直接插入排序 或 简单选择排序 ；若n较大时, 则采用快排、堆排或归并排序</li><li>若n很大, 记录关键字位数较少且可分解, 采用基数排序    </li><li>当文件的n个关键字随机分布是,任何借助于“比较”的排序,  至少需要O(nlog2n)的时间  </li><li>若初始基本有序,则采用直接插入或冒泡排序  </li><li>当记录元素比较大, 应避免大量移动的排序算法,尽量采用 链式存储</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序之基数排序 详细总结</title>
      <link href="/2020/06/19/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/19/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><blockquote><p><strong>不基于比较</strong></p></blockquote><p>借助 “分配” 和 “收集” 两种操作对单逻辑关键字进行排序  分为最高位优先(MSD)和最低位优先(LSD)。<br>以r为基数的最低位优先基数排序的过程:</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/13/dpivP1.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/13/dpiX5R.png" alt=""></p><h1 id="分配和收集"><a href="#分配和收集" class="headerlink" title="分配和收集"></a>分配和收集</h1><p>在排序时使用r个队列Q0，Q1，…，Qr-1  </p><p><strong>分配:</strong> 开始时,把Q0，Q1，Qr-1各个队列置空, 然后依次考察每一个结点的关键字  </p><p>若a的关键字中k1=k,就把a放入队列Q当中  </p><p><strong>收集:</strong> 把Q0, Q1，…，Qr-1 各个队列中的结点依次收尾相接, 得到一个新的结点序列组成线性表  </p><blockquote><p><strong>d次分配收集后, 序列会排成有序的序列</strong></p></blockquote><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/13/dpkmk9.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p><strong>基数排序：</strong></p><p>时间复杂度(平均)：O (d(n+r))    </p><p>空间复杂度：O (r)</p><p>是一个  <strong>稳定</strong>  算法</p><p><strong>不基于比较</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基数排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序之归并排序 详细总结</title>
      <link href="/2020/06/19/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/19/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><p>​        归并排序( MergeSort)就是利用归并的思想实现的排序方法。它的原 理是假设初始序列有n个记录,则可以看成是n个有序的子序列, 每个子 序列的长度为1,然后两两归并, 得到 n/2 个长度为2或1的有序子序 列; 再两两归并，…，如此重复, 直至得到一个长度为n的有序序列为 止, 这种排序方法称为 <strong>2路归并排序</strong>。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/13/az2ld0.png" alt="">         </p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/13/az21oV.png" alt=""></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="合并两个有序线性表"><a href="#合并两个有序线性表" class="headerlink" title="合并两个有序线性表"></a>合并两个有序线性表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个辅助数组，下标0的位置不使用，所以n+1</span></span><br><span class="line">ElemType *B = (ElemType *)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"><span class="comment">//low 第一个表起始位置， mid 第一个表终止位置，high第二个表终止位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span>(k = low; k &lt;= high; k++)</span><br><span class="line">        B[k] = A[k];</span><br><span class="line">    <span class="keyword">for</span>(i = low, j = mid +<span class="number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i] &lt;= B[j])</span><br><span class="line">            A[k] = B[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        A[k++] = B[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high)</span><br><span class="line">        A[k++] = B[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序代码"><a href="#归并排序代码" class="headerlink" title="归并排序代码"></a>归并排序代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">        MergeSort(A, low, mid);</span><br><span class="line">        MergeSort(A, mid+<span class="number">1</span>, high);</span><br><span class="line">        Merge(A, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p><strong>归并排序：</strong></p><p>时间复杂度(平均)：O (nlog2n)    </p><p>空间复杂度：O (n)</p><p>是一个  <strong>稳定</strong>  算法</p><p>适用于<strong>顺序存储</strong> 和 <strong>链式存储</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序之选择排序 详细总结</title>
      <link href="/2020/06/18/%E6%8E%92%E5%BA%8F%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/18/%E6%8E%92%E5%BA%8F%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>每一趟在后面n-i+1(i=1,2，…，n-1)个待排序元素中选取关键字最小的元素, 作为有序子序列的第i个元素, 直到n-1做完, 待排序元素只剩下1个。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/aveFKO.png" alt=""></p><blockquote><p><strong>一趟排序会将一个元素放置在最终的位置上</strong></p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++)</span><br><span class="line"><span class="keyword">if</span>(A[j] &lt; A[<span class="built_in">min</span>])</span><br><span class="line"><span class="built_in">min</span> = j;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">min</span> != i)</span><br><span class="line">&#123;</span><br><span class="line">temp = A[i];</span><br><span class="line">A[i] = A[<span class="built_in">min</span>];</span><br><span class="line">A[<span class="built_in">min</span>] = temp;                         </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/avniHe.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>直接选择排序：</strong></p><p>时间复杂度(平均)：O (n2)    时间复杂度与初始序列无关</p><p>空间复杂度：O (1)</p><p>是一个  <strong>不稳定</strong>  算法</p><p>适用于<strong>顺序存储</strong> 和 <strong>链式存储</strong></p></blockquote><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>n个关键字序列L[1…n] 称为 <strong>堆</strong>, 当且仅当该序列满足:  </p><ol><li><p>若 L(i) ≤ L(2i) 且 L(i) ≤ L(2i+1), 则称该堆为 <strong>小根堆</strong></p></li><li><p>若L(i) ≥ L(2i)且L(i) ≥ L(2i+1), 则称该堆为 <strong>大根堆</strong> (1 ≤ i ≤ [n/2]取下界)</p></li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/av1Cut.png" alt=""></p><p>在排序过程中将L[1…n]视为一棵完全二叉树的顺序存储结构</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/av1Kuq.png" alt=""></p><h2 id="用二叉树表示小根堆-大根堆"><a href="#用二叉树表示小根堆-大根堆" class="headerlink" title="用二叉树表示小根堆 || 大根堆"></a>用二叉树表示小根堆 || 大根堆</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/av3Pz9.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/av3CRJ.png" alt=""></p><h2 id="堆的初始化-大根堆"><a href="#堆的初始化-大根堆" class="headerlink" title="堆的初始化 (大根堆)"></a>堆的初始化 (大根堆)</h2><p>对所有具有双亲结点含义编号从大到小 ( [n/2]取下界 ~ 1)做出如下调整:  </p><ol><li>若孩子结点皆小于双亲结点,则该结点的调整结束  </li><li>若存在孩子结点大于双亲结点,则将最大的孩子结点与双亲结点交换,并对该孩子结点进行1)、2),直到出现1)或到叶  节点为止</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/avGxdP.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/avGzIf.png" alt=""></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        AdjustDown(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(ElemType A[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];<span class="comment">//暂存，下标0处之前没有值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*k; i &lt;= len; i*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; len &amp;&amp; A[i] &lt; A[i+<span class="number">1</span>])<span class="comment">//判断左孩子和右孩子哪个大</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i])</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//不需要调整</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[k] = A[i];<span class="comment">//将调整节点值赋值给双亲节点</span></span><br><span class="line">            k = i;<span class="comment">//将调整节点下标赋给k</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];<span class="comment">//将双亲节点值赋值给调整节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>初始建堆 O (n)</strong></p></blockquote><blockquote><p><strong>堆排序 不断地输出堆顶元素, 并向下调整</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BuildMaxHeap(A, len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(A[i], A[<span class="number">1</span>]);</span><br><span class="line">        AdjustDown(A, <span class="number">1</span>, i<span class="number">-1</span>)</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>堆排序：</strong></p><p>时间复杂度(平均)：O (nlog2n)    </p><p>空间复杂度：O (1)</p><p>是一个  <strong>不稳定</strong>  算法</p><p>适用于<strong>顺序存储</strong> （<strong>链式存储</strong>）</p></blockquote><h2 id="堆的插入"><a href="#堆的插入" class="headerlink" title="堆的插入"></a>堆的插入</h2><p>将新结点放置在末端然后进行向上调整</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/avdj1K.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/avdXp6.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustUp</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];</span><br><span class="line">    <span class="keyword">int</span> i = k/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; A[i] &lt; A[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        A[k] = A[i];</span><br><span class="line">        k = i;</span><br><span class="line">        i = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 直接选择排序 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序之交换排序 详细总结</title>
      <link href="/2020/06/17/%E6%8E%92%E5%BA%8F%E4%B9%8B%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/17/%E6%8E%92%E5%BA%8F%E4%B9%8B%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>​        假设待排序表长为n，从后往前（从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]&gt;A[i])，则交换他们直到序列比较结束。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajdEuQ.png" alt=""></p><blockquote><p><strong>一次冒泡会将一个元素放置到它最终的位置上</strong></p><p><strong>表长为n，排序完成需要进行n-1次冒泡</strong></p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">//可以减少无用冒泡次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt; i; j--)</span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>].key &gt; A[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = A[j<span class="number">-1</span>];</span><br><span class="line">                A[j<span class="number">-1</span>] = A[j];</span><br><span class="line">                A[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>加入bool变量作用：</strong></p><p>当序列中有逆序存在时，flag = true；说明本次冒泡交换完成；</p><p>如果 flag = false，即序列中没有逆序，说明序列已排序完成，结束循环，停止之后的无效冒泡；</p><p><strong>如果没有加入bool变量：</strong></p><p>无论序列是否排序完成，都会执行完指定次数的冒泡，其中很可能有许多次无效的冒泡。浪费大量时间。</p></blockquote><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajB1v8.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajBlgf.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>冒泡排序：</strong></p><p>时间复杂度(平均)：O (n2)</p><p>空间复杂度：O (1)</p><p>是一个  <strong>稳定</strong>  算法</p><p>适用于<strong>顺序存储</strong> 和 <strong>链式存储</strong></p></blockquote><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h2><p>​        在待排序表L[1 … n]中任取一个元素pivot作为基准, 通过一趟排序将待排序表划分为具有如下特点的两部分:</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajDySP.png" alt=""></p><blockquote><p><strong>一次划分会将一个元素 pivot 放置到它最终的位置上</strong></p></blockquote><h2 id="划分-Partition-思路"><a href="#划分-Partition-思路" class="headerlink" title="划分(Partition)思路"></a>划分(Partition)思路</h2><p>​        初始化标记low为划分部分第一个元素的位置，high为最后一个元素的位置，然后不断地移动两标记并交换元素：</p><ol><li>high向前移动找到第一个比pivot小的元素</li><li>low向后移动找到第一个比pivot大的元素</li><li>交换当前两个位置的元素</li><li>继续移动标记，执行1，2，3的过程，直到 low大于等于high为止。</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElemType pivot = A[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot)<span class="comment">//找一个比基准值小的数</span></span><br><span class="line">            high--;</span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt;= pivot)<span class="comment">//找一个比基准值大的数</span></span><br><span class="line">            low++;</span><br><span class="line">        A[high] = A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotpos = Partition(A, low, high);</span><br><span class="line">        QuickSort(A, low, pivotpos<span class="number">-1</span>);</span><br><span class="line">        QuickSort(A, pivotpos+<span class="number">1</span>, high); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajR2IU.png" alt=""></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajfu1H.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajfKcd.png" alt=""></p><blockquote><p><strong>冒泡排序：</strong></p><p>时间复杂度(平均)：O (nlog2n)</p><p>空间复杂度：O (log2n)</p><p>是一个  <strong>不稳定</strong>  算法</p><p>适用于<strong>顺序存储</strong> （<strong>链式存储</strong>）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冒泡排序 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序之插入排序 详细总结</title>
      <link href="/2020/06/16/%E6%8E%92%E5%BA%8F%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/16/%E6%8E%92%E5%BA%8F%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong>插入排序：</strong>每次将一个待排序的序列插入到一个前面已排好序的子序列当中</p><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aOwJRU.png" alt=""></p><p>初始L[1]是一个已经排好序的子序列  </p><p>对于元素L(i)(L(2)~L(n))插入到前面已经排好序的子序列当中  </p><ol><li>查找出L(i)在L[1…i-1]中的插入位置k</li><li>将L[k…i-1]中的所有元素全部后移一个位置</li><li>将L(i)复制到L(k)</li></ol><blockquote><p><strong>此算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，所以空间复杂度为O(1)</strong></p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void InsertSort(ElemType A[], int n)</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line">for(i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">A[0] &#x3D; A[i];  &#x2F;&#x2F;A[0]是哨兵，保存每次待插入的元素</span><br><span class="line">for(j &#x3D; i-1; A[0].key &lt; A[j]; j--)&#x2F;&#x2F;从后往前比较</span><br><span class="line">A[j + 1] &#x3D; A[j];</span><br><span class="line">A[j + 1] &#x3D; A[0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aOrbhq.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aOrHNn.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p><strong>直接插入排序：</strong></p><p>时间复杂度(平均)：O (n2)</p><p>空间复杂度：O (1)</p><p>是一个  <strong>稳定</strong>  算法</p><p>适用于<strong>顺序存储</strong> 和 <strong>链式存储</strong></p></blockquote><h1 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h1><h2 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h2><p>在 <strong>直接插入排序</strong> 中 ，利用的是 <strong>顺序查找</strong> 的思想。</p><p>在 <strong>直接插入排序</strong> 中加入了 <strong>折半查找</strong> 的思想 就是 <strong>折半插入排序</strong></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++)<span class="comment">//O(n)</span></span><br><span class="line">&#123;</span><br><span class="line">A[<span class="number">0</span>] = A[i];  <span class="comment">//A[0]是哨兵，保存每次待插入的元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//折半查找部分</span></span><br><span class="line">        low = <span class="number">1</span>; high = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)<span class="comment">//O(log2n)</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid].key &gt; A[<span class="number">0</span>].key)</span><br><span class="line">                high = mid <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//移动O(n)</span></span><br><span class="line"><span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= high+<span class="number">1</span>; j--)<span class="comment">//从后往前比较 high+1是找到的插入元素的位置</span></span><br><span class="line">A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">        </span><br><span class="line">A[high + <span class="number">1</span>] = A[<span class="number">0</span>];<span class="comment">// high+1 也可以表示成low</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入位置分析"><a href="#插入位置分析" class="headerlink" title="插入位置分析"></a>插入位置分析</h2><ol><li>A[mid].key &gt; A[0].key <strong>条件成立：</strong>一开始high，low，mid均指向同一位置；若条件成立，则 high = mid -1，也就是原来的元素大于插入的元素，所以原来元素应该后移，插入的元素放在原来元素mid的位置，也就是 high+1的位置 （或者说是low的位置）</li><li>A[mid].key &gt; A[0].key <strong>条件不成立：</strong> 一开始high，low，mid均指向同一位置；若条件不成立，则 low = mid + 1，也就是原来的元素小于插入的元素，原来元素位置不变，插入的元素放在原来元素后一位置，也是 high+1的位置 （或者说是low的位置）</li><li>综上，可确定插入位置均是 high+1 或者 low 的位置</li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>折半插入排序：</strong></p><p>时间复杂度(平均)：O (n2)</p><p>空间复杂度：O (1)</p><p>是一个  <strong>稳定</strong>  算法</p><p>仅仅适用于<strong>顺序存储</strong></p></blockquote><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>先将排序表分割成d个形如l[i, i+d, i+2, … ，i+kd的“特殊”子表, 分别进行直接插入排序, 当整个表中的元素已呈“基本有序时”, 再对全体记录进行一次直接插入排序<br><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aO4nQs.png" alt="">    </p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aO4GYF.png" alt=""></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> dk = n/<span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk = dk/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = dk +<span class="number">1</span>; i &lt;= n; ++i)   <span class="comment">//各个组同时进行直接插入排序</span></span><br><span class="line">            <span class="keyword">if</span>(A[i].key &lt; A[i-dk].key)</span><br><span class="line">            &#123;</span><br><span class="line">                A[<span class="number">0</span>] = A[i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i-dk; j &gt; <span class="number">0</span> &amp;&amp; A[<span class="number">0</span>].key &lt; A[j].key; j-=dk)</span><br><span class="line">                    A[j+dk] = A[j];</span><br><span class="line">                A[j+dk] = A[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aOzN11.png" alt=""></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>希尔排序:</strong></p><p>时间复杂度(平均)：O (n2)</p><p>空间复杂度：O (1)</p><p>是一个  <strong>不稳定</strong>  算法</p><p>仅仅适用于<strong>顺序存储</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 直接插入排序 </tag>
            
            <tag> 折半插入排序 </tag>
            
            <tag> 希尔排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序的基本概念 详细总结</title>
      <link href="/2020/06/16/%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/16/%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><p><strong>排序：</strong>重新排列表中的元素,使表中的元素满足按关键字递增或递减   </p><p><strong>输入：</strong>n个记录R1, R2,R 3, …, Rn, 对应关键字k1, k2, k3, …, kn  </p><p><strong>输出：</strong>输入序列的重新排列R1’, R2’, R3’, …, Rn’, k1’ &lt;= k2’ &lt;= … &lt;= kn’ (其中 &lt;= 可以换成其他有比较含义的符号)</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aON48e.png" alt=""></p><h1 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h1><p>若待排序表中有两个元素R和R,其对应的关键字k=k,且在排序前Ri  在Rj前面,若使用某排序算法后,R仍然在Rj前面。则称这个排序算法是稳定的,否则称排序算法不稳定。</p><blockquote><p><strong>算法的稳定性是算法的性质,并 不能衡量一个算法的优劣</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aOUurR.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aOUnM9.png" alt=""></p><h1 id="内部排序和外部排序"><a href="#内部排序和外部排序" class="headerlink" title="内部排序和外部排序"></a>内部排序和外部排序</h1><p><strong>内部排序：</strong> 指在排序期间元素全部存放在内存中的排序    </p><p><strong>外部排序：</strong> 指在排序期间元素无法全部同时存放在内存中,必须在排序  的过程中根据要求不断地在内、外存之间进行移动</p><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/11/aOaKSg.png" alt=""></p><blockquote><p><strong>时空复杂度决定内部排序算法的性能</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>查找之哈希表 详细总结</title>
      <link href="/2020/06/15/%E6%9F%A5%E6%89%BE%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/15/%E6%9F%A5%E6%89%BE%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>散列函数：</strong> 一个把查找表中的关键字映射成该关键字对应的地址的函数。</p><p><strong>散列表：</strong>   也称哈希表，根据关键字而直接进行访问的数据结构。他建立了关键字与存储地址之间的一种直接映射关系。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/abRRmD.png" alt=""></p><h1 id="构造散列函数"><a href="#构造散列函数" class="headerlink" title="构造散列函数"></a>构造散列函数</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ol><li>散列函数的定义域必须包含全部需要存储的关键字,而值域的范围则依赖于  散列表的大小或地址范围。</li><li>散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中,从而  减少冲突的发生。  </li><li>散列函数应尽量简单,能够在较短时间内计算出任一关键字对应的散列地址。</li></ol><h2 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h2><p><strong>定义：</strong> 直接取关键字的某个线性函数值为散列地址。<br>            Hash(key)=a*key + b,  其中a,b为常数</p><p><strong>优点：</strong>方法简单，不会产生冲突</p><p><strong>缺点：</strong> 若关键字分部不连续，则会造成空间浪费</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/abIpOP.png" alt=""></p><h2 id="除留取余法-重要"><a href="#除留取余法-重要" class="headerlink" title="除留取余法 (重要)"></a>除留取余法 (重要)</h2><p>Hash(key)=key%p<br>假定散列表表长为m，取一个不大于m但最接近或等于m的质数p</p><blockquote><p><strong>选好p是关键，可以减少冲突的可能</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aboOxA.png" alt=""></p><h2 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h2><blockquote><p><strong>适用于关键字已知的集合,若更换关键字则需要重新构造散列函数。</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/abTiGQ.png" alt=""></p><p>利用图中红色圈住区域计算散列地址</p><h2 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h2><p>这种方法取关键字的平方值的中间几位作为散列地址 </p><blockquote><p><strong>适用于关键字的每位取值不均匀或均小于散列地址所需要的位数</strong>  </p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/ab7AYD.png" alt=""></p><h2 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h2><p>将关键字分割成位数相同的几部分,然后取这几部分的叠加和作为散列地址</p><blockquote><p><strong>适用于关键字的位数多,而且关键字中的每位上数字分布大致均匀</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/ab7Efe.png" alt=""></p><h1 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h1><blockquote><p><strong>问题：冲突不可能绝对避免, 那如何处理冲突？？</strong><br><strong>答案：为产生冲突的关键字寻找下一个“空”的Hash地址</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/ab7BkT.png" alt=""></p><h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><p><strong>开放定址法：</strong>是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。<br>H=（H(key)+di)%m, i = 0,1,2..…k(k &lt;= m-1); m为散列表表长，di为增量序列</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aq9e5d.png" alt=""></p><h3 id="计算增量序列"><a href="#计算增量序列" class="headerlink" title="计算增量序列"></a>计算增量序列</h3><h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><blockquote><p> <strong>例:</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aq9qJA.png" alt=""></p><blockquote><p><strong>缺点：</strong> 造成堆积现象，大大降低查找效率</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aq9LRI.png" alt=""></p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aqChfs.png" alt=""></p><h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>由于在开放定址法中，如果删除某个元素后，就会破坏查找某个元素的查找序列。所以有了拉链法</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aqiaRA.png" alt=""></p><h3 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h3><p><strong>拉链法：</strong>是指把所有同义词存放在一个线性链表中，这个线性链表由地址唯一标识，即散列表中每个单元存放该链表头指针。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aqaALq.png" alt=""></p><blockquote><p><strong>拉链法适用于经常进行插入和删除的情况</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aqaDOI.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先，初始化: Addr = hash(key)</p><ol><li>检测查找表中地址为Addr的位置上是否有记录, 若无记录, 则返回查找失败; 若有记录,则比较它与key值, 若相等则返回成功, 否则执行步骤 2</li><li>用给定的处理冲突方法计算“下一散列地址,把Addr置为此地址, 转入步骤 1</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aqdUH0.png" alt=""></p><h1 id="查找效率"><a href="#查找效率" class="headerlink" title="查找效率"></a>查找效率</h1><p>查找效率取决于 散列函数、处理冲突的方法和填裝因子      </p><p><strong>填装因子：</strong> 一般记为a,表示表的装满程度</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/10/aqdOVP.png" alt=""></p><blockquote><p><strong>散列表的平均查找长度依赖于散列表的填装因子</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 散列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找之B+树 详细总结</title>
      <link href="/2020/06/14/%E6%9F%A5%E6%89%BE%E4%B9%8BB+%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/14/%E6%9F%A5%E6%89%BE%E4%B9%8BB+%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><p>一棵m阶B+树满足如下特性:  </p><ol><li>每个分支结点最多有m棵子树子结点)</li><li>若根结点不是终端结点,则至少有两棵子树</li><li>除根结点外的所有非叶结点至少有 (m/2)取上界 棵子树, <strong>子树和关键字个数相等</strong></li><li>所有叶结点包含全部关键字及指向相应记录的指针,叶结点中将关键字按大小顺序排列, 并且相邻结点按大小顺序连接起来</li><li>所有分支结点(可视为索引的索引)中仅包含他的各个子结点(下一级索引块)中关键字的最大值及指向其子结点的指针</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aT7t8s.png" alt=""></p><h1 id="B-树-VS-B树"><a href="#B-树-VS-B树" class="headerlink" title="B+树 VS B树"></a>B+树 VS B树</h1><ol><li><p>在B+树中, 具有η个关键字的结点值含有n棵子树,即每个关键字对应一棵子树</p><p>在B树中, 具有n个关键字的结点含有n+1棵子树</p></li><li><p>在B+树中,叶结点包含信息, 所有非叶结点仅起索引作用, 非叶结点中的毎个索引项只含有对应子树的最大关键字和指向该子树关键字的指针, 不 含有该关键字对应记录的存储地址</p></li><li><p>在B+树中, 叶结点包含全部关键字,即在非叶结点中出现的关键字也会 出现在叶结点中棵子树</p><p>在B树中,叶结点包含的关键字和其他结点包含的关键字是不重复的</p></li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aTHLY4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多路平衡查找树 </tag>
            
            <tag> B+树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找之B树 详细总结</title>
      <link href="/2020/06/14/%E6%9F%A5%E6%89%BE%E4%B9%8BB%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/14/%E6%9F%A5%E6%89%BE%E4%B9%8BB%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><p><strong>B树</strong> 又称多路平衡查找树，B树中所有结点的 <strong>孩子结点数</strong> 的最大值称为B树的阶。</p><blockquote><p>一棵m阶B树或为空树，或为满足如下特性的m叉树：</p><ol><li><p>树中每个结点至多有m棵子树（即至多含有m-1个关键字）</p></li><li><p>若根结点不是终端结点，则至少有两棵子树</p></li><li><p>除根结点外的所有非叶结点至少有 <strong>m/2 (取上界)</strong>  棵子树（即 *<em>m/2 (取上界) *</em>- 1 个关键字）</p></li><li><p>非叶结点的结构：</p><p>   <img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/ao7tfA.png" alt="">                     </p></li><li><p>所有的叶结点都出现在同一层次上，并不带任何信息</p></li></ol></blockquote><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aoHuNQ.png" alt=""></p><p>首先，这棵B树中 <strong>孩子结点数的最大值是3</strong>，所以这棵树的 <strong>阶为3</strong>，即为 <strong>3阶B树</strong></p><ol><li><p>由图中可看出，树中每个结点至多有3棵子树（即至多含有2个关键字）</p></li><li><p>例如 10，15，20 结点，不是终端结点，至少有两棵子树</p></li><li><p>m/2 (取上界)  = 3/2(取上界) = <strong>2</strong>，m/2 (取上界) - 1  =  3/2(取上界) - 1 = <strong>1</strong>，满足要求</p></li><li><p>Ki :  18 &lt; 33,   Pi 和 Pi-1 ：12 &lt; 18 , 48 &gt; 33 ,  满足要求</p></li><li><p>如图，最下面的叶结点均在一层，且不带任何信息</p></li></ol><h1 id="问题探究"><a href="#问题探究" class="headerlink" title="问题探究"></a>问题探究</h1><blockquote><p><strong>n个关键字,阶数为m,高度为h的B ? ? ?</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aoxTA0.png" alt=""></p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aTFEJ1.png" alt=""></p><blockquote><ol><li>在B树中找结点             <strong>磁盘</strong></li><li>在结点中找关键字        <strong>内存</strong></li></ol></blockquote><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ol><li><p><strong>定位</strong></p><p>查找插入该关键字的位置，即最底层中的某个非叶子结点（规定一定是插入在最底层的某个非叶子结点内）</p></li><li><p><strong>插入</strong><br>若插入后，不破会m阶B树的定义，即插入后结点关键字个数在属于区间[m/2 -1, m-1]，则直接插入；<br>若插入后，关键字数量大于m-1，则对插入后的结点进行分裂操作；<br>分裂：<br>插入后的结点中间位置（[m/2]）关键字并入父结点中，<br>中间结点左侧结点留在原先的结点中，右侧结点放入新的节点中，<br>若并入父节点后，父结点关键字数量超出范围，继续想上分裂，直到符合要求为止。</p></li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aT27X4.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aT2bnJ.png" alt=""></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aTRm38.png" alt=""></p><h3 id="终端节点删除"><a href="#终端节点删除" class="headerlink" title="终端节点删除"></a>终端节点删除</h3><ol><li><strong>直接删除</strong></li></ol><p>若被删除关键字所在结点关键字总数 &gt;「m/2 ] - 1 , 表明删除后仍满足B树定义, 直接删除 </p><ol start="2"><li><strong>兄弟够借</strong></li></ol><p>若被删除关键字所在结点关键字总数 =「m/2 ] - 1 ,且与此结点邻近的兄弟结点的关键字个数&gt;「m/2] , 则需要从兄弟结点借一个关键字,此过程需要调整该结点、双亲结点和兄弟结点的关键字</p><ol start="3"><li><strong>兄弟不够借</strong></li></ol><p>若被删除关键字所在结点关键字总数=「m/2] - 1, 且与此结点邻近的兄弟结点的关键字个数=「m/2] -1, 则删除关键字, 并与一个不够借的兄弟结点和双亲结点中两兄弟子树中间的关键字合并。合并后若双亲结点因减少一个结点导致不符合定义, 则继续执行2、3步骤 。</p><blockquote><p><strong>下面请仔细观察图（想着上方步骤）</strong></p></blockquote><blockquote><p><strong>直接删除</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aThfrF.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aThhb4.png" alt=""></p><blockquote><p><strong>兄弟够借</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aThWKU.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aTh5VJ.png" alt=""></p><blockquote><p><strong>兄弟不够借</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aT4Eqg.png" alt=""></p><h3 id="非终端节点删除"><a href="#非终端节点删除" class="headerlink" title="非终端节点删除"></a>非终端节点删除</h3><ol><li>若小于k的子树中关键字个数 &gt; [m/2] -1, 则找出k的前驱值k,并用k来取代k,再递归地删除k即可。  </li><li>若大于k的子树中关键字个数 &gt; [m/2] -1, 则找出k的后继值k,并用k来取代k,再递归地删除k即可。    </li><li>若前后两子树关键字个数均为「m/2] -1, 则直接两个子结点合并,  然后删除k即可。</li></ol><blockquote><p><strong>前驱值：</strong>结点左边子树的最右边的结点的关键字</p><p><strong>后驱值：</strong>结点右边子树的最左边的结点的关键字</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aTTkfs.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aTTZ60.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/aTTEpn.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> B树 </tag>
            
            <tag> 多路平衡查找树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找之平衡二叉树 详细总结</title>
      <link href="/2020/06/13/%E6%9F%A5%E6%89%BE%E4%B9%8B%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/13/%E6%9F%A5%E6%89%BE%E4%B9%8B%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>AVL</strong>, 任意结点的平衡因子的 <strong>绝对值不超过一</strong>。<strong>平衡二叉树是一种二叉排序树</strong><br><strong>平衡因子：</strong>    左子树高度 - 右子树高度</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a50559.png" alt=""></p><blockquote><p><strong>根节点平衡因子是2，不是平衡二叉树</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a504UJ.png" alt=""></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><blockquote><p><strong>高度为h的最小平衡二叉树的结点数Nh</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5BzeU.png" alt=""></p><h1 id="平衡二叉树的判断"><a href="#平衡二叉树的判断" class="headerlink" title="平衡二叉树的判断"></a>平衡二叉树的判断</h1><blockquote><p><strong>利用递归的后序遍历过程:</strong></p><ol><li><p>判断左子树是一棵平衡二叉树  </p></li><li><p>判断右子树是一棵平衡二叉树 </p></li><li><p>判断以该结点为根的二叉树为平衡二叉树</p></li></ol></blockquote><blockquote><p><strong>判断条件</strong></p><p>若左子树和右子树均为平衡二叉树且左子树与右子树高度差的绝对值小于等于1,  则平衡。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5rJ3R.png" alt=""></p><blockquote><p>b 代表平衡性，1表示平衡，0表示不平衡</p><p>h 代表树的高度</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Judge_AVL</span><span class="params">(BiTree bt, <span class="keyword">int</span> &amp;balance, <span class="keyword">int</span> &amp;h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bl = <span class="number">0</span>, br = <span class="number">0</span>, hl = <span class="number">0</span>, hr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        h = <span class="number">0</span>;</span><br><span class="line">        balance = <span class="number">1</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        h = <span class="number">1</span>;</span><br><span class="line">        balance = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Judge_AVL(bt-&gt;lchild, bl, hl);</span><br><span class="line">        Judge_AVL(bt-&gt;rchild, br, hr);</span><br><span class="line">        <span class="keyword">if</span>(hl &gt; hr)</span><br><span class="line">            h = hl + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            h = hr + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(h1 - hr) &lt; <span class="number">2</span> &amp;&amp; bl == <span class="number">1</span> &amp;&amp; br == <span class="number">1</span>)</span><br><span class="line">            balance = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            balance = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><blockquote><p><strong>先插入后调整</strong></p><p>每次调整 <strong>最小不平衡子树</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aI3dX9.png" alt=""></p><h2 id="LL平衡旋转-右单旋转"><a href="#LL平衡旋转-右单旋转" class="headerlink" title="LL平衡旋转(右单旋转)"></a>LL平衡旋转(右单旋转)</h2><p>*<em>原因: *</em> 在结点A的左孩子的左子树上插入了新结点 </p><p>*<em>调整方法: *</em> 右旋操作: 将A的左孩子B代替A,将A结点称为B的右子树根结点,而B的原右子树则作为A的左子树</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aIGHyQ.png" alt=""></p><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aIJq1O.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aIJLcD.png" alt=""></p><h2 id="RR平衡旋转-左单旋转"><a href="#RR平衡旋转-左单旋转" class="headerlink" title="RR平衡旋转(左单旋转)"></a>RR平衡旋转(左单旋转)</h2><p><strong>原因：</strong>在结点A的右孩子的右子树上插入了新结点  </p><p><strong>调整方法：</strong> 左旋操作: 将A的右孩子B代替A, 将A结点称为B的左子树 根结点, 而B的原左子树则作为A的右子树。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aItiI1.png" alt=""></p><h3 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aItCZ9.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aItPaR.png" alt=""></p><h2 id="LR平衡旋转-先左后右双旋转"><a href="#LR平衡旋转-先左后右双旋转" class="headerlink" title="LR平衡旋转(先左后右双旋转)"></a>LR平衡旋转(先左后右双旋转)</h2><p><strong>原因：</strong>在结点A的左孩子的右子树上插入了新结点<br><strong>调整方法：</strong>先左旋后右旋操作：将A的左孩子B的右孩子结点C代替B，然后再将C结点向上代替A的位置。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aINC6S.png" alt=""></p><h3 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aIN9l8.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aINpSf.png" alt=""></p><h2 id="RL平衡旋转-先右后左旋转"><a href="#RL平衡旋转-先右后左旋转" class="headerlink" title="RL平衡旋转(先右后左旋转)"></a>RL平衡旋转(先右后左旋转)</h2><p><strong>原因：</strong>在结点A的右孩子的左子树上插入了新结点  </p><p><strong>调整方法：</strong> 先右旋后左旋操作:将A的右孩子B的左孩子结点C代替B,  然后再将C结点向上代替A的位置。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aINTNn.png" alt=""></p><h3 id="例-3"><a href="#例-3" class="headerlink" title="例"></a>例</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aINoAs.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/aIN57j.png" alt=""></p><blockquote><p><strong>再次提醒：以上4种方式的前提是 最小不平衡子树</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平衡二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找之二叉排序树 详细总结</title>
      <link href="/2020/06/13/%E6%9F%A5%E6%89%BE%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/13/%E6%9F%A5%E6%89%BE%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>二叉排序树 <strong>BST</strong>，也称 <strong>二又查找树</strong> 。<br>二叉排序树或者为空树，或者为非空树，当为非空树时有如下特点：</p><ol><li><p>若左子树非空，则左子树上所有结点关键字值 <strong>均小于</strong> 根结点的关键字。</p></li><li><p>若右子树排空，则右子树上所有结点关键字值 <strong>均大于</strong> 根结点的关键字。</p></li><li><p>左、右子树本身也分别是一棵二叉排序树。</p></li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a4zcO1.png" alt=""></p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉树非空时，查找根结点，若相等则查找成功；</p><p>若不等，则当小于根结点值时，查找左子树；当大于根结点的值时，查找右子树。</p><p>当查找到叶节点仍没查找到相应的值，则查找失败。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5pIsA.png" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BST_search</span><span class="params">(BiTree T, Elemrype key, BSTNode * &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//传入三个参数  二叉排序树， 查找值， 记录当前结点的双亲系结点指针</span></span><br><span class="line">    p = <span class="literal">NULL</span>；</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span> &amp;&amp; key != T-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        p = T;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; T-&gt;data)</span><br><span class="line">           T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> T;<span class="comment">//返回查找结点的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度为 O (h) ，h为二叉排序树的高度</p></blockquote><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>若二叉排序树为空, 则直接插入结点;</p><p>若二叉排序树非空, 当值小于根结点时,插入左子树; 当值大于根结点时, 插入右子树;</p><p>当值等于根结点时不进行插入。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BiTree &amp;T, KeyType k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)   <span class="comment">//为空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        T-&gt;key = k;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchlid = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k = T-&gt;key)    <span class="comment">//等于时</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-&gt;key)   <span class="comment">//非空小于</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;lchild, k);</span><br><span class="line">    <span class="keyword">else</span>   <span class="comment">//非空大于</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;rchild, k);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造二排序树"><a href="#构造二排序树" class="headerlink" title="构造二排序树"></a>构造二排序树</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>读入一个元素并建立结点, 若二叉树为空将其作为根结点；</p><p>若二叉排序树非空, 当值小于根结点时,插入左子树; 当值大于根结点时,插入右子树;</p><p>当值等于根结点时不进行插入。</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_BST</span><span class="params">(BiTree &amp;T, KeyType str[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     T = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">     &#123;</span><br><span class="line">         BST_Insert(T, str[i]);</span><br><span class="line">         i++;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5e1Hg.png" alt=""></p><blockquote><p><strong>如果元素的值相同，但是顺序不同，构造出的二叉排序树也是不同的</strong></p></blockquote><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><blockquote><p><strong>若被删除结点z是叶结点, 则直接删除;</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5mVqU.png" alt=""></p><blockquote><p><strong>若被删除结点z只有一棵子树,则让z的子树成为z父结点的子树, 代替z结点。</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5mQR1.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5mlxx.png" alt=""></p><blockquote><p><strong>若被删除结点z有两棵子树,则让z的中序序列直接后继代替z,并删去直接后继结点。</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5mrsf.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5mDQP.png" alt=""></p><h1 id="问题探究"><a href="#问题探究" class="headerlink" title="问题探究"></a>问题探究</h1><blockquote><p><strong>思考：在二叉排序树中删除并插入某节点, 得到的二叉排序树是否与原来相同？？？</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5n4tH.png" alt=""></p><p><strong>结论：可能相同也可能不同</strong></p><h1 id="查找效率"><a href="#查找效率" class="headerlink" title="查找效率"></a>查找效率</h1><p><strong>平均查找长度（ASL）取决于树的高度</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/08/a5un3R.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉排序树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找之分块查找 详细总结</title>
      <link href="/2020/06/12/%E6%9F%A5%E6%89%BE%E4%B9%8B%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/12/%E6%9F%A5%E6%89%BE%E4%B9%8B%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>分块查找：</strong>又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/al8Cfe.png" alt=""></p><h1 id="如何分块"><a href="#如何分块" class="headerlink" title="如何分块"></a>如何分块</h1><ol><li>将查找表分为若干子块。块内的元素可以无序，但块间是有序的，即对于所有块有第i块的最大关键字小于第i+1块的所有记录的关键字。</li><li>建立索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。</li></ol><blockquote><p><strong>块内无序块间有序</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/alGHM9.png" alt=""></p><h1 id="如何查找"><a href="#如何查找" class="headerlink" title="如何查找"></a>如何查找</h1><ol><li>在索引表中确定待查记录所在的块,可以 <strong>顺序查找或折半查找</strong> 索引表。  </li><li>在块内进行 <strong>顺序查找</strong></li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/alGHM9.png" alt=""></p><p>分块查找的平均查找长度为 <strong>索引查找(LI)和块内查找(LS)之和</strong>。  </p><p>设长度为n的查找表均匀分为b块,每块有s个记录</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/alYxjH.png" alt=""></p><blockquote><p>若块内和块间均采用 <strong>顺序查找</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/altpDA.png" alt=""></p><blockquote><p>若块内采用顺序查找，块间均采用 <strong>折半查找</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/altSud.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找之折半查找 详细总结</title>
      <link href="/2020/06/11/%E6%9F%A5%E6%89%BE%E4%B9%8B%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/11/%E6%9F%A5%E6%89%BE%E4%B9%8B%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>折半查找：</strong>又称二分查找，仅适用于 <strong>有序的顺序表</strong></p><h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><ol><li><p>首先将给定值key与表中中间位置元素的关键字比较,  </p></li><li><p>若相等,则返回该元素的位置;  </p></li><li><p>若不等,则在前半部分或者是后半部分进行查找。 </p></li></ol><blockquote><p>查找序列升序时,  </p><p>若key小于中间元素,则查找前半部分  </p><p>若key大于中间元素,则查找后半部分。  </p></blockquote><ol start="4"><li>重复该过程,直到找到查找的元素为止;或查找失败。</li></ol><h1 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(SeqList L, ElemType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> low=<span class="number">0</span>, high=L.TableLen<span class="number">-1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">    mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.elem[mid] == key)  </span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid] &gt; key)</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">            Low = mid + <span class="number">1</span>;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>折半查找的时间复杂度为 O(log2n)</strong></p></blockquote><h1 id="判定树"><a href="#判定树" class="headerlink" title="判定树"></a>判定树</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQ0Hc8.png" alt=""></p><blockquote><p>若该判定树是 <strong>满二叉树</strong> 时，</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQ0xNn.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQBkB4.png" alt=""></p></blockquote><blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQB3HH.png" alt=""></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折半查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找之顺序查找 详细总结</title>
      <link href="/2020/06/11/%E6%9F%A5%E6%89%BE%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/11/%E6%9F%A5%E6%89%BE%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>顺序查找：</strong>又称线性查找，主要用于在<strong>线性表</strong>中进行查找。</p><h1 id="无序线性表的顺序查找"><a href="#无序线性表的顺序查找" class="headerlink" title="无序线性表的顺序查找"></a>无序线性表的顺序查找</h1><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQMvkQ.png" alt=""></p><blockquote><p>对无序线性表进行顺序查找，查找失败时要 <strong>遍历整个线性表</strong></p></blockquote><h2 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        ElemType *elem;</span><br><span class="line">        <span class="keyword">int</span> TableLen;</span><br><span class="line">&#125;SSTable;<span class="comment">//查找表</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_Seg</span><span class="params">(SStable ST,ElemType key)</span></span>&#123;</span><br><span class="line">        ST.elem[<span class="number">0</span>] = key; <span class="comment">//哨兵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ST.Tablelen; ST.elem[i] != key; i--);</span><br><span class="line">        <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>哨兵作用：</strong> 查找失败返回哨兵下标即0，查找成功返回查找到的元素下标。如果没有哨兵，则需要加一个if判断，是否查找到指定元素。<strong>使用哨兵可以精简代码量。</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQ1msx.png" alt=""></p><h1 id="有序线性表的顺序查找"><a href="#有序线性表的顺序查找" class="headerlink" title="有序线性表的顺序查找"></a>有序线性表的顺序查找</h1><h2 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQ1aef.png" alt=""></p><blockquote><p>对关键字有序线性表进行顺序查找，查找失败时 <strong>不一定要遍历整个线性表</strong></p></blockquote><h2 id="判定树"><a href="#判定树" class="headerlink" title="判定树"></a>判定树</h2><p><strong>判定树：</strong> 描述查找过程的二叉排序树</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQG5tS.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQGbXn.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 顺序查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找的基本概念 详细总结</title>
      <link href="/2020/06/11/%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/11/%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQVP9f.png" alt=""></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><blockquote><p><strong>查找：</strong>在数据集合中寻找满足某种条件的数据元素的过程。 </p><p>查找结果分为 <strong>查找成功</strong> 和 <strong>查找失败</strong>。</p></blockquote><blockquote><p>*<em>查找表:  *</em>用于查找的数据集合, 由同一种数据类型(或记录)的组成, 可以是一个数组或链表等数据类型  </p><p>操作:    </p><ol><li>检索满足条件的某个特定的数据元素的各种属性</li><li>查询某个特定的数据元素是否在查找表中    </li><li>在查找表中插入一个数据元素  </li><li>从查找表中删除一个数据元素</li></ol><p>操作1和2合起来称作 <strong>静态查找表</strong> , 全部操作合起来称作 <strong>动态查找表</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQAdd1.png" alt=""></p><blockquote><p>*<em>关键字:  *</em> 数据元素中唯一标识该元素的某个数据项的值, 使用基于关键字的查找, 查找结果应该是唯一的。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQAwIx.png" alt=""></p><blockquote><p><strong>平均查找长度：</strong>  查找时,关键字比较次数的平均值:</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/31/aQkcEq.png" alt=""></p><p>一般用于衡量一个查找算法的<strong>查找效率</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 查找 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图的应用之关键路径 详细总结</title>
      <link href="/2020/06/10/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/10/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><p><strong>AOE网：</strong>在有向带权图中, 以顶点表示事件, 以有向边表示活动, 以边上权值表示完成该活动的开销(如完成活动所需要的时间), 则称这种有向图为用边 表示活动的网络, 简称 <strong>AOE网</strong> 。</p><p><strong>源点：</strong>没有入边的顶点（有且只有一个）</p><p><strong>汇点：</strong>没有出边的顶点（有且只有一个）</p><p><strong>关键路径：</strong>从原点到汇点最大路径长度的路径称为 <strong>关键路径</strong>, 键路径上的活动为 <strong>关键活动</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/anvC1f.png" alt=""></p><h1 id="基本计算"><a href="#基本计算" class="headerlink" title="基本计算"></a>基本计算</h1><blockquote><p><strong>事件Vk的最早发生时间 Ve(k)</strong></p><p>利用事件的入边，取最大值</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/anxsMT.png" alt=""></p><blockquote><p><strong>事件Vk的最迟发生时间 Vl(k)</strong></p><p>利用事件的出边，取最小值</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/aupgeS.png" alt=""></p><blockquote><p><strong>活动ai的最早开始时间e(i)</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/auEvMd.png" alt=""></p><blockquote><p><strong>活动ai的最迟开始时间l(i)</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/auV3z4.png" alt=""></p><blockquote><p><strong>活动ai的差额d(i) = l(i) - e(i)</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/auVbmn.png" alt=""></p><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/30/auea8O.png" alt=""></p><blockquote><p>当网中关键路径 <strong>不唯一</strong> 时，只有加快的关键活动或关键活动组合包括在 <strong>所有的关键路径</strong> 上才能缩短工期。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关键路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的应用之拓扑排序 详细总结</title>
      <link href="/2020/06/09/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/09/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><blockquote><p><strong>有向无环图：</strong>不存在环的有向图, 简称<strong>DAG图</strong>。    </p><p><strong>AOV网：</strong>若用一个DAG图表示一个工程,其顶点表示活动, 用 有向边&lt;vi, vj&gt;表示活动vi先于活动vj进行的传递关系,则将这种DAG称为<strong>顶点表示活动网络</strong>, 记为<strong>AOV网</strong>。 </p></blockquote><p><strong>拓扑排序：</strong>对DAG所有顶点的一种排序, 使若存在一条从顶点A 到顶点B的路径,在排序中B排在A的后面。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeHxTf.png" alt=""></p><h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><ol><li>从DAG图中选择一个没有前驱的顶点并输出</li><li>从图中删除该顶点和所有以它为起点的有向边</li><li>重复1、2 ，直到当前的DAG图为空或当前图中不存在无前驱的顶点为止。后一种情况说明图中 <strong>有环</strong>。</li></ol><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><h2 id="例1-（无环）"><a href="#例1-（无环）" class="headerlink" title="例1 （无环）"></a>例1 （无环）</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeL9Mj.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeLSzQ.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeLCss.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeqzRg.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeLPLn.png" alt=""></p><h2 id="例2（有环）"><a href="#例2（有环）" class="headerlink" title="例2（有环）"></a>例2（有环）</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeOptK.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeO9fO.png" alt=""></p><blockquote><p><strong>算法结束时没有访问所有顶点,则存在以剩下顶点组成的环。</strong></p></blockquote><h2 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeXi5V.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeXPU0.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeXkCT.png" alt=""></p><blockquote><p><strong>拓扑排序的结果不一定唯一。</strong></p></blockquote><h1 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//温馨提示：以下代码只看思路，不必深究细节</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TopologicalSort</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Initstack(S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) <span class="comment">//入度为0</span></span><br><span class="line">            Push(S,i);<span class="comment">//入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录统计输出顶点的个数</span></span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(S))<span class="comment">//空：图中不存在入度为0的节点   非空：进入循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pop(S, i); <span class="comment">//弹出栈顶元素，弹出一入度为0的顶点</span></span><br><span class="line">        <span class="built_in">print</span>[count++] = i;<span class="comment">//保存当前出栈的入度为0的节点下标  </span></span><br><span class="line">        <span class="keyword">for</span>(p=G.Vertices[i].firstarc; p; p=p-&gt;nextarc)<span class="comment">//遍历边表</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[v]))<span class="comment">//若-1后，入度为0，则入栈</span></span><br><span class="line">                Push(S, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; G.vexnum) <span class="comment">//为真说明图中有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//排序失败</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//排序成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度为 <strong>O（|V| + |E|）</strong></p></blockquote><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><blockquote><p>若邻接矩阵为三角矩阵，则存在拓扑排序；反之不一定成立。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/am9Yf1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的应用之最短路径 详细总结</title>
      <link href="/2020/06/08/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/08/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>在网图和非网图中,最短路径的含义是不同的。          ·</p><p><strong>非网图：</strong> 两个顶点之间经过的边数最少的路径为 <strong>最短路径</strong>。</p><p>​    <strong>网图：</strong> 两个顶点之间带权路径长度最短的路径为 <strong>最短路径</strong>。   </p><p>在带权图当中,把从一个顶点v到另个顶点u所经历的边的权值之和称为,路径的 <strong>带权路径长度</strong>。</p><p>我们把路径起始的第一个顶点称为源点, 最后一个顶点称为终点。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aZDH9e.png" alt=""></p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="迪杰斯特拉（Dijkatra）算法"><a href="#迪杰斯特拉（Dijkatra）算法" class="headerlink" title="迪杰斯特拉（Dijkatra）算法"></a>迪杰斯特拉（Dijkatra）算法</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><blockquote><p>Dijkstra <strong>带权图单源最短路径</strong></p></blockquote><h4 id="辅助数组"><a href="#辅助数组" class="headerlink" title="辅助数组"></a>辅助数组</h4><blockquote><p> <strong>s[]:</strong> 标记已经计算完成的顶点。          </p><p>数组中的值全部初始化为0。源点下标的值初始化为1。</p></blockquote><blockquote><p><strong>dist[]:</strong> 记录从源点vo到其他各顶点当前的最短路径长度。</p><p>数组中的值初始化为源点到格个顶点边的权值，即 dist [i] = arcs [0] [i]</p></blockquote><blockquote><p> <strong>path[]:</strong> 记录从最短路径中顶点的前驱顶点,即path[i] 为v到vi最短路径上ⅵ 的前驱顶点。</p><p>数组中的值初始化：</p><p>若源点v0到该顶点vi有一条有向边(无向边), 则令path[i] = 0  否则 path [i] = -1;</p></blockquote><h4 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h4><ol><li>初始化数组，并集合S初始为 {0}；</li><li>从顶点集合V-S中选出Vj，满足dist[j] = Min(dist [i] l Vi ∈ V-S}，Vj就是当前求得的最短路径的终点，并另S U { j }；</li><li>修改此时从V0出发到集合V-S上任一顶点Vk最短路径的长度：若dist[j]+arcs [j] [k] 则令 dist[k]=dist [j] + arcs [j] [k] ;  path[k]=j;</li><li>重复2、3步，操作n-1次，直到S中包含全部顶点；</li></ol><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aZ2sbj.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aZ2rrQ.png" alt=""></p><h3 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化部分</span></span><br><span class="line">    <span class="keyword">int</span> s[G. vexnum];</span><br><span class="line">    <span class="keyword">int</span> path[G.vexnum];</span><br><span class="line">    <span class="keyword">int</span> dist[G.vexnum];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dist[i] = G.edge[v][i];<span class="comment">//将dist[]数组初始化为源点到格个顶点边的权值</span></span><br><span class="line">        s[i] = <span class="number">0</span>;<span class="comment">//将s[]数组全部初始化为0</span></span><br><span class="line">        <span class="keyword">if</span>(G.edge[v][i] &lt; MAX)<span class="comment">//MAX表示∞，如果权值是∞说明不存在边，无前驱节点记为-1 </span></span><br><span class="line">            path[i] = v;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            path[i]=<span class="number">-1</span>;                         </span><br><span class="line">    &#125;</span><br><span class="line">    s[v] = <span class="number">0</span>;    <span class="comment">//顶点v没有记录过, 赋值为0。 例如: s[u] = 1, 表示顶点u已经记录过</span></span><br><span class="line">    path[v] = <span class="number">-1</span>;  <span class="comment">//v是源点，无前驱节点，记作-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//真正实现部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = MAX;<span class="comment">//临时变脸，记录最小权值  </span></span><br><span class="line">        <span class="keyword">int</span> u;<span class="comment">//临时变脸，记录最小权值边另一头的顶点下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; <span class="built_in">min</span>)<span class="comment">//没被记录过过 &amp;&amp; 权值小</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">min</span> = dist[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        s[u] = <span class="number">1</span>;<span class="comment">//表示顶点u已经记录过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//没被记录过过 &amp;&amp; (v-&gt;u + u-&gt;j) &lt; u-&gt;j</span></span><br><span class="line">            <span class="keyword">if</span>(s[j] == <span class="number">0</span> &amp;&amp; dist[u] + G.Edge[u][j]] &lt; dist[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[u] + G.Edge[u][j]];</span><br><span class="line">                path[j] = u;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度为 O(|V2|)</p></blockquote><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><blockquote><p><strong>不适用于含有负权边的图</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aZzkHs.png" alt=""></p><h2 id="弗洛伊德（Floyd）算法"><a href="#弗洛伊德（Floyd）算法" class="headerlink" title="弗洛伊德（Floyd）算法"></a>弗洛伊德（Floyd）算法</h2><h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><blockquote><p>Floyd <strong>各顶点之间的最短路径</strong></p></blockquote><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p>递推产生一个n阶方阵序列A(-1), A(0, A(k, .…, A(n-1)<br>A(k) [i] [j] 顶点vi到Vj的最短路径长度，且该路径经过的顶点编号不大于k</p><h4 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h4><p>初始化：A(-1) [i] [j] = arcs [i] [j]</p><p>地推方法：A(k) [i] [j] = MIn{A(k-1) [i] [j], A(k-1) [i] [k] + A(k-1) [k] [j]}, k = 0, 1, … , n-1</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeuH0I.png" alt=""></p><h3 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/29/aeu7nA.png" alt=""></p><h3 id="参考代码实现-1"><a href="#参考代码实现-1" class="headerlink" title="参考代码实现"></a>参考代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span> <span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化部分</span></span><br><span class="line">    <span class="keyword">int</span> A[G.vexnum][G.vexnum];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)    </span><br><span class="line">            A[i][j] = G.Edge[i][j];  </span><br><span class="line">    <span class="comment">//真正实现部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; j &lt; G.vexnum; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum: j++)</span><br><span class="line"><span class="keyword">if</span>(a[i][j] &gt; a[i][k] + A[k][j])</span><br><span class="line">                   a[i][j] = a[i][k] + A[k][j];            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路径 </tag>
            
            <tag> 迪杰斯特拉(Dijkatra)算法 </tag>
            
            <tag> 弗洛伊德(Floyd)算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的应用之最小生成树 详细总结</title>
      <link href="/2020/06/07/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/07/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h1><p><strong>定义：</strong> 连通图包含全部顶点的一个极小连通子图</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/apOGU1.png" alt=""></p><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p><strong>定义：</strong> 对于 <strong>带权无向连通图</strong> G = ( V, E ), G的所有生成树当中边的 <strong>权值之和最小</strong> 的生成树为G的 <strong>最小生成树(MST)</strong> 。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/apXPG6.png" alt=""></p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ol><li><p>最小生成树不一定唯一,即最小生成树的树形不一定唯一。当带权无向连通图G的各边权值不等时或G只有结点数减1条边时,MST唯一    </p></li><li><p>最小生成树的权值是唯一的, 且是最小    </p></li><li><p>最小生成树的边数为顶点数减1</p></li></ol><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="Prim-（普里姆）算法"><a href="#Prim-（普里姆）算法" class="headerlink" title="Prim （普里姆）算法"></a>Prim （普里姆）算法</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li><strong>初始化：</strong>向空的结果树 T =（Vt，Et) 中添加图 G =（V, E) 的任一顶点u0，使 Vt = {u0}，Et为空集；</li><li><strong>循环（直到Vt = V)：</strong>从图G中选择满足 { (u, v) | u∈Vt ，v∈ V-Vt }且具有最小权值的边（u，v），并置Vt = Vt U {v} , Et =Et U (u, v) }。</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9ClrV.png" alt=""></p><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9AdH0.png" alt=""></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote><p><strong>辅助数组理解：</strong></p><p>min_weight [n] ：存放相关顶点间边的权值 </p><p><strong>表示最小生成树中已存放的顶点到未存放顶点的最小权值</strong></p><p>例：假设有 v0，v1，v2，v3，v4 这5个顶点</p><p>min_weight [5] = {0, 2, 0, 0, 0} <strong>表示最小生成树中已存放的顶点到顶点v1的最小权值是2</strong></p><p>adjvex [n] ：存放相关顶点的下标    </p><p>例：假设有 v0，v1，v2，v3，v4 这5个顶点</p><p>adjvex [5] = {0, 0, 1, 0, 1} <strong>表示顶点v2和顶点v4 这两个点和顶点v1间都有边</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MST_Prim</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> min_weight[G.vexnum];<span class="comment">//存放相关顶点间边的权值</span></span><br><span class="line">    <span class="keyword">int</span> adjvex[G.vexnum];<span class="comment">//存放相关顶点的下标 </span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//初始化操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min_weight[i] = G.Edge[<span class="number">0</span>][i];<span class="comment">//将邻接矩阵第0行所有权值加入数组</span></span><br><span class="line">        adjvex[i] = <span class="number">0</span>;<span class="comment">//全部初始化为v0下标</span></span><br><span class="line">    &#125;</span><br><span class="line">                   </span><br><span class="line">    <span class="comment">//正式构造最小生成树的过程               </span></span><br><span class="line">    <span class="keyword">int</span> min_arc;<span class="comment">//临时变量，表示当前最小权值</span></span><br><span class="line">    <span class="keyword">int</span> min_vex;<span class="comment">//临时变量，表示当前最小权值边的顶点数组下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; G.vexnum; i++)   <span class="comment">//由于有一个顶点已在最小生成树中，所以只遍历n-1次</span></span><br><span class="line">    &#123;</span><br><span class="line">        min_arc = INT_MAX;<span class="comment">//初始化最小权值为65535等不可能数值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找出min_weight[]数组中已存的最小权值</span></span><br><span class="line">             <span class="keyword">if</span>(min_weight[j] != <span class="number">0</span> &amp;&amp; min_weight[j] &lt; min_arc)</span><br><span class="line">             &#123;</span><br><span class="line">                 min_arc = min_weight[j];</span><br><span class="line">                 min_vex = j;<span class="comment">//将发现最小权值的下标存入min_vex, 待使用</span></span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        min_weight[min_vex] = <span class="number">0</span>;<span class="comment">//将当前顶点的权值设为0，表示此顶点已完成任务</span></span><br><span class="line">        <span class="comment">//遍历全部顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">        &#123; </span><br><span class="line">             <span class="keyword">if</span>(min_weight[j] != <span class="number">0</span> &amp;&amp; G.Edge[min_vex][j] &lt; min_weight[j])</span><br><span class="line">             &#123;</span><br><span class="line">                 min_weight[j] = G.Edge[min_vex][j];</span><br><span class="line">                 adjvex[j] = min_arc;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>结论：</strong></p><p>此算法时间复杂度为 O(V2)，适用于<strong>稠密图</strong></p></blockquote><h2 id="Kruskal（克鲁斯卡尔）算法"><a href="#Kruskal（克鲁斯卡尔）算法" class="headerlink" title="Kruskal（克鲁斯卡尔）算法"></a>Kruskal（克鲁斯卡尔）算法</h2><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li><strong>初始化：</strong>Vt = V，Et = 空集。即是每个顶点构成一棵独立的树，T是一个仅含V个顶点的森林；</li><li><strong>循环（直到T为树）：</strong>按图G的边的权值递增的顺序依次从 E-Et 中选择一条边，若这条边加入后不构成回路，则将其加入E，否则舍弃。</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9WD8s.png" alt=""></p><h3 id="并查集（必看）"><a href="#并查集（必看）" class="headerlink" title="并查集（必看）"></a>并查集（必看）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9jQIA.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9jMad.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9j1PI.png" alt=""></p><h3 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/26/a9OeW6.png" alt=""></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;<span class="comment">//两个端点下标</span></span><br><span class="line">    <span class="keyword">int</span> weight;     <span class="comment">//权值</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MST_Kruskal</span><span class="params">(Graph G, Edge* edges, <span class="keyword">int</span>* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heap_sort(edges);<span class="comment">//堆排序</span></span><br><span class="line">    Initial(parent);<span class="comment">//全部初始化为 -1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.arcnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a_root = Find(parent, edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b_root = Find(parent, edges[il.b);</span><br><span class="line">        <span class="keyword">if</span>(a_root != b_root)</span><br><span class="line">        Union(parent, a_root, b_root);<span class="comment">//合并</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>结论：</strong></p><p>此算法时间复杂度为 O(|E|log|E|)，适用于<strong>稀疏图</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> Prim(普里姆)算法 </tag>
            
            <tag> Kruskal(克鲁斯卡尔)算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的遍历之深度优先搜索(DFS) 详细总结</title>
      <link href="/2020/06/06/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/06/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="深度度优先搜索"><a href="#深度度优先搜索" class="headerlink" title="深度度优先搜索"></a>深度度优先搜索</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>深度优先搜索(DepthFirstSearch)</strong>,也有称为深度优先遍历,简称为 <strong>DFS</strong>。  </p><blockquote><p>​        还是拿找钥匙例子来说,  无论从哪一间房间开始都可以,将间内的墙角  、床头柜、床上、床下、衣柜、电视柜等挨个寻  找,做到不放过任何一个死角,当所有的抽屉、  储藏柜中全部都找遍,接着再寻找下一个房间。</p></blockquote><h3 id="具体实现思路"><a href="#具体实现思路" class="headerlink" title="具体实现思路"></a>具体实现思路</h3><ol><li><p>首先访问起始顶点v;  </p></li><li><p>接着由v出发访问v的任意一个 <strong>邻接且未被访问</strong> 的邻接顶点Wi  </p></li><li><p>然后再访问与Wi <strong>邻接且未被访问</strong> 的任意顶点 yi;  </p></li><li><p>若w没有邻接且未被访问的顶点时, 退回到它的上一层顶点v;  </p></li><li><p>重复上述过程,直到所有顶点被访问为止。</p></li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/Uz7eqP.png" alt=""></p><blockquote><p><strong>由此看出，深度优先搜索与树的先序遍历类似</strong></p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/Uz7sMR.png" alt=""></p><blockquote><p>小提示：遵循右手原则遍历，蓝色线为走的线</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/Uz7ys1.png" alt=""></p><h3 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/UzbBuR.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_TREE_SIZE]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        visited[i] = FALSE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            DFS(G, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(Graph G, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    <span class="keyword">for</span>(w = FirstNeighbor(G, v); w &gt;= <span class="number">0</span>; w = NextNeighbor(G, v, w))</span><br><span class="line">    <span class="keyword">if</span>(!visited[i])        i</span><br><span class="line">            DFS(G, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>此篇博客仅为本人根据个人理解复习总结所写，如有错误之处，请在下方评论或者联系我，我会第一时间改正。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的遍历之广度优先搜索(BFS) 详细总结</title>
      <link href="/2020/06/05/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/05/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>从图中某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。</p><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>广度优先搜索（BreadthFirstSearch)</strong>，又称为广度优先遍历，简称 <strong>BFS</strong>。</p><blockquote><p>​        如果以之前我们找钥匙的例子来讲，运用深度优先遍历意味着要先彻底查找完一个房间再开始另一个房间但我们知道，钥匙放在沙发地下等特角奇兄的可能性极低，因此我们运用新的方亲：先看看钥匙是否放在各个房间的显服位置，如果没有，再看看各个房间的抽屉有没有。这样逐步扩大查找的范围的方式我们称为 <strong>广度优先搜索</strong> 。</p></blockquote><h3 id="具体实现思路"><a href="#具体实现思路" class="headerlink" title="具体实现思路"></a>具体实现思路</h3><ol><li>首先访问起始顶点v；</li><li>接着由出发依次访问v的各个 <strong>未被访问过</strong> 的邻接顶点W1, W2….Wi；</li><li>然后依次访问W1, W2…,Wi 的所有 <strong>未被访问过</strong> 的邻接顶点；</li><li>在从这些访问过的顶点出发，访问它们所有 <strong>未被访问过的</strong> 邻接顶点.</li><li>….以此类推；</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvUKr8.png" alt=""></p><blockquote><p><strong>由此看出，广度优先搜索与树的层次遍历类似</strong></p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/UzeahF.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/25/UzeUtU.png" alt=""></p><h3 id="参考代码实现-邻接矩阵"><a href="#参考代码实现-邻接矩阵" class="headerlink" title="参考代码实现 (邻接矩阵)"></a>参考代码实现 (邻接矩阵)</h3><blockquote><p><strong>温馨提示：请结合本博客另一博文《图的存储结构之邻接矩阵 详细总结》参考学习</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵的广度优先搜索</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_TRUE_SIZE];<span class="comment">//辅助标记数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Mgraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; G.vexnum; i++)<span class="comment">//将辅助标记数组全部初始化为FALSE, G.vexnum表示顶点数</span></span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    initQueue( &amp;Q);<span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c  "</span>, G.vex[i]);<span class="comment">//访问顶点</span></span><br><span class="line">            visited[i] = TRUE;</span><br><span class="line">            EnQueue(&amp;Q, i);</span><br><span class="line">            <span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                DeQueue(&amp;Q, i);</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(G.art[i][j]) == <span class="number">1</span> &amp;&amp; !visited[j])<span class="comment">//等于1 且 未被访问</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%c  "</span>, G.vex[i]);<span class="comment">//访问顶点</span></span><br><span class="line">                        visited[j] = TRUE;</span><br><span class="line">            EnQueue(&amp;Q, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考代码实现-邻接表"><a href="#参考代码实现-邻接表" class="headerlink" title="参考代码实现 (邻接表)"></a>参考代码实现 (邻接表)</h3><blockquote><p><strong>温馨提示：请结合本博客另一博文《图的存储结构之邻接表 详细总结》参考学习</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表的广度优先搜索</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_TRUE_SIZE];<span class="comment">//辅助标记数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Mgraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; G.vexnum; i++)<span class="comment">//将辅助标记数组全部初始化为FALSE, G.vexnum表示顶点数</span></span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    initQueue( &amp;Q);<span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c  "</span>, G.vetices[i].data);<span class="comment">//访问顶点</span></span><br><span class="line">            visited[i] = TRUE;</span><br><span class="line">            EnQueue(&amp;Q, i);</span><br><span class="line">            <span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                DeQueue(&amp;Q, i);</span><br><span class="line">                ArcNode P = G.AdjList[i].first;</span><br><span class="line">                <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; !visited[i])<span class="comment">// 单链表指针为非NULL 且 未被访问</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c  "</span>, G.vetices[p.adjvex].data);<span class="comment">//访问顶点</span></span><br><span class="line">                    visited[j] = TRUE;</span><br><span class="line">                    EnQueue(&amp;Q, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>此篇博客仅为本人根据个人理解复习总结所写，如有错误之处，请在下方评论或者联系我，我会第一时间改正。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的基本操作 详细总结</title>
      <link href="/2020/06/04/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/04/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="操作一-判断边存在"><a href="#操作一-判断边存在" class="headerlink" title="操作一 判断边存在"></a>操作一 判断边存在</h2><blockquote><p><strong>Adjacent(G, x, y) 判断图G是否存在边 &lt;x, y&gt; 或 (x, y)</strong></p></blockquote><h3 id="实例（无向图）"><a href="#实例（无向图）" class="headerlink" title="实例（无向图）"></a>实例（无向图）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UveNTO.png" alt=""></p><h3 id="实例（有向图）"><a href="#实例（有向图）" class="headerlink" title="实例（有向图）"></a>实例（有向图）</h3><p><strong><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvmT8H.png" alt=""></strong></p><h2 id="操作二-找邻边"><a href="#操作二-找邻边" class="headerlink" title="操作二 找邻边"></a>操作二 找邻边</h2><blockquote><p><strong>Neighbors(G, x) 列出图G中与结点x邻接的边</strong></p></blockquote><h3 id="实例（无向图）-1"><a href="#实例（无向图）-1" class="headerlink" title="实例（无向图）"></a>实例（无向图）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uvnhyn.png" alt=""></p><h3 id="实例（有向图）-1"><a href="#实例（有向图）-1" class="headerlink" title="实例（有向图）"></a>实例（有向图）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uvn4Lq.png" alt=""></p><h2 id="操作三-插入顶点"><a href="#操作三-插入顶点" class="headerlink" title="操作三 插入顶点"></a>操作三 插入顶点</h2><blockquote><p><strong>InsertVertex(G,x) 在图G中插入顶点x</strong></p></blockquote><h3 id="插入顶点F前"><a href="#插入顶点F前" class="headerlink" title="插入顶点F前"></a>插入顶点F前</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvKlE6.png" alt=""></p><h3 id="插入顶点F后"><a href="#插入顶点F后" class="headerlink" title="插入顶点F后"></a>插入顶点F后</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvK1UK.png" alt=""></p><h2 id="操作四-删除顶点"><a href="#操作四-删除顶点" class="headerlink" title="操作四 删除顶点"></a>操作四 删除顶点</h2><blockquote><p><strong>DeleteVertex(G, x) 从图G中删除顶点x</strong></p></blockquote><h3 id="删除顶点A前"><a href="#删除顶点A前" class="headerlink" title="删除顶点A前"></a>删除顶点A前</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvQE6J.png" alt=""></p><h3 id="删除顶点A后"><a href="#删除顶点A后" class="headerlink" title="删除顶点A后"></a>删除顶点A后</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvQAl4.png" alt=""></p><h2 id="操作五-添加边"><a href="#操作五-添加边" class="headerlink" title="操作五 添加边"></a>操作五 添加边</h2><blockquote><p><strong>AddEdge(G, x, y) 若无向边(x,y) 或者 有向边&lt;x, y&gt;不存在,则向图中添加该边</strong></p></blockquote><h3 id="添加边AD前"><a href="#添加边AD前" class="headerlink" title="添加边AD前"></a>添加边AD前</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvlGCT.png" alt=""></p><h3 id="添加边AD后"><a href="#添加边AD后" class="headerlink" title="添加边AD后"></a>添加边AD后</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uvl35V.png" alt=""></p><h2 id="操作六-删除边"><a href="#操作六-删除边" class="headerlink" title="操作六 删除边"></a>操作六 删除边</h2><blockquote><p><strong>RemoveEdge(G, x, y)若 无向边(x, y) 或者 有向边&lt;x, y&gt;存在,则在图G中删除该边</strong></p></blockquote><h3 id="删除边BC前"><a href="#删除边BC前" class="headerlink" title="删除边BC前"></a>删除边BC前</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uv3gHA.png" alt=""></p><h3 id="删除边BC后"><a href="#删除边BC后" class="headerlink" title="删除边BC后"></a>删除边BC后</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uv3cBd.png" alt=""></p><h2 id="操作七-找顶点的邻接点"><a href="#操作七-找顶点的邻接点" class="headerlink" title="操作七 找顶点的邻接点"></a>操作七 找顶点的邻接点</h2><blockquote><p><strong>FirstNeighbor(G, x) 求图G中顶点X的第一个邻接点，若有则返回顶点号。若没有邻接点或图不存在x，则返回 -1。<br>NextNeighbor(G, x) 假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是的最后一个邻接点，则返回 -1。</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/Uv862T.png" alt=""></p><h2 id="操作八-网获取或设置权值"><a href="#操作八-网获取或设置权值" class="headerlink" title="操作八 网获取或设置权值"></a>操作八 网获取或设置权值</h2><blockquote><p><strong>Get edge value(G, x, y) 获取图G中边(x, y) 或 &lt;x, y&gt; 对应的权值v。</strong>  </p><p><strong>Set edge value(G, x, y) 设置图G中边(x, y) 或 &lt;x, y&gt; 对应的权值为v。</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UvG1L4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图的存储结构之邻接多重表 详细总结</title>
      <link href="/2020/06/03/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/03/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        如果我们在无向图的应用中,关注的重点是顶点的话,那么邻接表是不错的选择,但如果我们更关注的是边的操作,比如对已经访问过的边做标记, 或者删除某一条边等操作,邻接表就显得不那么方便了。</p><h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><p><strong>邻接多重表：</strong> 无向图的一种存储结构</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/UOkyiq.png" alt=""></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/UOk6J0.png" alt=""></p><h2 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边表结点</span></span><br><span class="line">    <span class="keyword">int</span> ivex,jvex; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">ilink</span>, *<span class="title">jlink</span>;</span></span><br><span class="line">    <span class="comment">//Inforype info;</span></span><br><span class="line">    <span class="comment">//bool mark;</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span><span class="comment">//顶点结点</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode *firstedge;</span><br><span class="line">&#125;VNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//邻接多重表</span></span><br><span class="line">    VNode adjmulist[MaxVertexNum];</span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;AMLGraph；</span><br></pre></td></tr></table></figure><h2 id="十字链表-VS-邻接多重表"><a href="#十字链表-VS-邻接多重表" class="headerlink" title="十字链表 VS 邻接多重表"></a>十字链表 VS 邻接多重表</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/UOVeGq.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 邻接多重表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的存储结构之十字链表 详细总结</title>
      <link href="/2020/06/03/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/03/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​       邻接表 固然优秀，但也有不足。例如，对有向图的处理上，有时候需要再建立一个逆邻接表，这就不是很方便了。那我们思考了：有没有可能把邻接表和逆邻接表 结合起呢？答亲是肯定的，这就是我们现在要谈的十字链表 (Orthogonal List)。</p><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p><strong>十字链表</strong> 是有向图的一种链式存储结构</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/ULznFU.png" alt=""></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/UO99JO.png" alt=""></p><h2 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边表结点</span></span><br><span class="line">    <span class="keyword">int</span> tailvex,headvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">hlink</span>, <span class="title">tlink</span>;</span></span><br><span class="line">    <span class="comment">//Inforype info;</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vNodet</span>&#123;</span><span class="comment">//顶点表结点</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode *firstin, *firstout;</span><br><span class="line">]VNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//十字链表</span></span><br><span class="line">    VNode xlist[MaxVertexNum];</span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;GLGraph;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        十字链表的好处就是因为 <strong>把邻接表和逆邻接表整合在了一起</strong> , 这样既容易找到以Vi为尾的弧,也  容易找到以Vj为头的弧,因而容易求得顶点的出度和入度。</p><p>​        十字链表除了结构复杂一点外,其实创建图算法的肘间复杂度是和邻接表相同的,因此,在有向图的应用中,十字链表也是非常好的数据结构模型。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 十字链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的存储结构之邻接表 详细总结</title>
      <link href="/2020/06/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%82%BB%E6%8E%A5%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%82%BB%E6%8E%A5%E8%A1%A8%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    由于邻接矩阵适用于存储稠密图，如果用邻接矩阵存储 <strong>稀疏图</strong> 会造成极大的 <strong>空间浪费</strong> ，因此我们来学习 <strong>邻接表</strong> 来存储稀疏图。</p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p><strong>总体思路：</strong>为每个顶点建立一个单链表存放与它相邻的边</p><table><thead><tr><th>顶点表</th><th>采用顺序存储,每个数组元素存放顶点的数据和边表的头指针</th></tr></thead><tbody><tr><td><strong>边表(出边表)</strong></td><td><strong>采用链式存储,单链表中存放与一个顶点相邻的所有边,一个链表结点表示一条从该顶点到链表结点顶点的边</strong></td></tr></tbody></table><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/ULM2oF.png" alt=""></p><h2 id="实例（无向图）"><a href="#实例（无向图）" class="headerlink" title="实例（无向图）"></a>实例（无向图）</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/ULQOBV.png" alt=""></p><h2 id="实例（有向图）"><a href="#实例（有向图）" class="headerlink" title="实例（有向图）"></a>实例（有向图）</h2><blockquote><p><strong>提示：</strong> 下图把顶点当作弧尾建立的 <strong>邻接表</strong> ，如果把顶点当作弧头建立，则称为 <strong>逆邻接表</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/ULQLn0.png" alt=""></p><h2 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边表结点</span></span><br><span class="line">        <span class="keyword">int</span> adjvex;<span class="comment">//顶点下标</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>；  //指向下一个边表结点的指针</span></span><br><span class="line"><span class="class">        //<span class="title">Inforype</span> <span class="title">info</span>;</span><span class="comment">//权值</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span><span class="comment">//顶点表结点</span></span><br><span class="line">        VertexType data;<span class="comment">//顶点数据</span></span><br><span class="line">        ArcNode *first;<span class="comment">//指向它的单链表的头指针</span></span><br><span class="line">&#125;VNode, AdjList[MaxVertexNum];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        AdjList vetices;<span class="comment">//定义邻接表</span></span><br><span class="line">        <span class="keyword">int</span> vexnum,arcnum;<span class="comment">//顶点数，边数</span></span><br><span class="line">&#125;ALGraph</span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/ULJ5NV.png" alt=""></p><h2 id="邻接矩阵-VS-邻接表"><a href="#邻接矩阵-VS-邻接表" class="headerlink" title="邻接矩阵 VS 邻接表"></a>邻接矩阵 VS 邻接表</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/ULYKgg.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 邻接表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的存储结构之邻接矩阵 详细总结</title>
      <link href="/2020/06/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/02/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="邻接矩阵的定义"><a href="#邻接矩阵的定义" class="headerlink" title="邻接矩阵的定义"></a>邻接矩阵的定义</h2><p><strong>图的邻接矩阵（Adjacency Matrix）</strong>存储方式是用两个数组来表示图。一个 <strong>一维数组 *<em>存储图中顶点信息，一个 *</em>二维数组</strong>(称为邻接矩阵) 存储图中的边或弧的信息。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/Ub3rkD.png" alt=""></p><h2 id="图的领接矩阵实现思路"><a href="#图的领接矩阵实现思路" class="headerlink" title="图的领接矩阵实现思路"></a>图的领接矩阵实现思路</h2><p>结点数为n的图G=(V)的邻接矩阵A是nxn的。 </p><p>将G的顶点编号为V1,V2…Vn(数组下标) </p><p>若&lt;Vi,Vj&gt; ∈E，则 A [i] [j] = 1，否则 A [i] [j] = 0</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/Ub8n4e.png" alt=""></p><h3 id="实例（有向图）"><a href="#实例（有向图）" class="headerlink" title="实例（有向图）"></a>实例（有向图）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UbNmpF.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UbNnl4.png" alt=""></p><h3 id="实例（无向图）"><a href="#实例（无向图）" class="headerlink" title="实例（无向图）"></a>实例（无向图）</h3><p><strong><font color=red>注意：</font></strong> 下图中修改部分的值均为 <strong>1</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UbdSSO.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UbdplD.png" alt=""></p><h2 id="网的邻接矩阵实现思路"><a href="#网的邻接矩阵实现思路" class="headerlink" title="网的邻接矩阵实现思路"></a>网的邻接矩阵实现思路</h2><blockquote><p><strong>小提示：</strong>网也就是带权值的图</p></blockquote><p>结点数为n的图G=(V)的邻接矩阵A是nxn的。 </p><p>将G的顶点编号为V1,V2…Vn(数组下标) </p><p>若&lt;Vi,Vj&gt; ∈E，则 A [i] [j] = Wi,j，否则 A [i] [j] = ∞</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/Ub5cXd.png" alt=""></p><h3 id="实例（无向图）-1"><a href="#实例（无向图）-1" class="headerlink" title="实例（无向图）"></a>实例（无向图）</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/Uqy1XV.png" alt=""></p><h3 id="参考代码实现"><a href="#参考代码实现" class="headerlink" title="参考代码实现"></a>参考代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType Vex[MaxVertexNum];<span class="comment">//点集</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];<span class="comment">//边集</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;<span class="comment">//结点数量，边的数量</span></span><br><span class="line">&#125;MGraph</span><br></pre></td></tr></table></figure><h2 id="邻接矩阵的性质"><a href="#邻接矩阵的性质" class="headerlink" title="邻接矩阵的性质"></a>邻接矩阵的性质</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/Uqy1XV.png" alt=""></p><ol><li><p>邻接矩阵法的空间复杂为O(n2), 适用于 <strong>稠密图</strong></p></li><li><p>无向图的邻接矩阵为 <strong>对称矩阵</strong> </p></li><li><p>无向图中第 i 行 (第 i 列) 非0元素 (非正无穷) 的个数为第 i 个顶点的度 </p></li><li><p>有向图中第 i 行 (第 i 列) 非0元素 (非正无穷) 的个数为第 i 个顶点的出度(入度）</p></li></ol><h2 id="问题探索"><a href="#问题探索" class="headerlink" title="问题探索"></a>问题探索</h2><blockquote><p><strong>问题：</strong>设图G的邻接矩阵为A,矩阵运算 <strong>A的n次</strong> 的含义？？？</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/23/Uq5RZn.png" alt=""></p><p><strong><font color=red>小提示：</font></strong> 以下 An 代表 A的n次，例如 A2 代表 A的2次</p><p><strong><font color=red>分析：</font></strong></p><p>A2 [2] [5]=1 * 1 + 0 * 0 + 1 * 1 + 0 * 0 + 0 * 0 = 2 </p><p>A2 [2] [5] = 2 表示从顶点v2到顶点v5长度为2的路径有 2 条</p><p>A3 [2] [5] = 0 * 1 + 0 * 0 + 1 * 1 + 1 * 0 + 2 * 0 = 1 </p><p>A2 [2] [3] = 1 表示从顶点v2到顶点v3长度为2的路径有 1 条 </p><p>A3 [2] [5] = 1 表示从顶点v2到顶点v5长度为3的路径有 1 条 </p><p><strong><font color=red>结论：</font></strong></p><p>An [i] [j] = x 表示从顶点Vi到顶点Vj长度为n的路径有 x 条</p><p>即：An [i] [j] 表示从顶点Vi到顶点Vj长度为n的路径条数</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 邻接矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的基本概念 详细总结</title>
      <link href="/2020/06/01/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/01/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h1><p>图（Graph）是由顶点 (Vertex) 的 <strong>有穷非空</strong> 集合 和 顶点之间 <strong>边</strong> 的集合组成，通常表示为：G(V, E)  , 其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p><p>|V|表示图G中顶点的个数，也称为图G的阶；|E| 表示图G中边的条数</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/U7UjGF.png" alt=""></p><blockquote><p>V = {A，B，C，D，E}         |V| = 5</p><p>E = {(A, B), (A, C), (A, E), (B, C), (C, D), (C, E)}      |E| = 6</p></blockquote><p><strong><font color=red>注意：</font></strong>线性表，树都可以为空，但图 <strong>不能为空</strong> (顶点集合V要有穷非空，边集可以是空的)</p><h1 id="图的其它基本概念"><a href="#图的其它基本概念" class="headerlink" title="图的其它基本概念"></a>图的其它基本概念</h1><h2 id="无向图-amp-有向图"><a href="#无向图-amp-有向图" class="headerlink" title="无向图 &amp; 有向图"></a>无向图 &amp; 有向图</h2><p><strong>无向边：</strong>若顶点Vi到Vj之间的边没有方向，则称 这条边为<strong>无向边(Edge)</strong>，用无序偶(Vi，Vj）来表 示。</p><p><strong>有向边：</strong>若从顶点Vi到Vj的边有方向，则称这条边为 <strong>有向边</strong>，也称为 <strong>弧（Arc）</strong>，用有序偶&lt;Vi，Vj&gt;来表示 ，Vi称为<strong>弧尾</strong>，Vj称为<strong>弧头</strong>。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/U7s4uF.png" alt=""></p><h2 id="简单图-amp-多重图"><a href="#简单图-amp-多重图" class="headerlink" title="简单图 &amp; 多重图"></a>简单图 &amp; 多重图</h2><p><strong>简单图：</strong>在图结构中，若不存在顶点到其自身的 边，且同一条边不重复出现，则称这样的图为简单图。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/U7sfjU.png" alt=""></p><h2 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h2><p><strong>无向完全图：</strong>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶 点的无向完全图有n*(n-1)/2条边。</p><p><strong>有向完全图：</strong>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n*(n-1) 条边。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/U7R4u6.png" alt=""></p><h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h2><p>设有两个图G =（V，E) 和 G’ =（V’，E‘），若V’是V的子集，且E‘是E的子集， 则称G’为G的 <strong>子图</strong>，且若V（G）= V（G’）则称 G’ 为 G的 <strong>生成子图</strong></p><blockquote><p><strong>子图</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UH99dU.png" alt=""></p><blockquote><p><strong>生成子图</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UH9CoF.png" alt=""></p><blockquote><p><strong>子图</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UH9ii4.png" alt=""></p><blockquote><p><strong>子图</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHpzLV.png" alt=""></p><blockquote><p><strong>不是子图</strong>，因为它就不是图</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UH9pZT.png" alt=""></p><h2 id="连通图-amp-强连通图"><a href="#连通图-amp-强连通图" class="headerlink" title="连通图 &amp; 强连通图"></a>连通图 &amp; 强连通图</h2><p><strong>连通图：</strong>在无向图G中，如果从顶点V1到顶点V2有路径， 则称V1和V2是连通的，如果对于图中任意两个顶 点Vi和Vj都是连通的，则称G是连通图 (ConnectedGraph)</p><p><strong>连通分量：</strong>无向图中的极大连通子图称为连通分量。 </p><blockquote><p><strong>注意以下概念：</strong> </p><p>首先要是子图，并且子图是要连通的； </p><p>连通子图含有极大顶点数； </p><p>是有极大顶点数的速通子图包含依附于这些顶点的所 有边。</p></blockquote><p><strong>强连通图：</strong>在有向图G中,如果对于每一对Vi到Vj都存在路径,则 称G是强连通图。 </p><p><strong>强连通分量：</strong>有向图中的极大强连通子图称为有向图的强连通分量。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHElH1.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHE3Ax.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHVTeA.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHeENt.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHeV4P.png" alt=""></p><blockquote><p><strong><font color=red>结论：</font></strong></p><p>如果原图是一个连通图 (强连通图)，那么它的连通分量 (强连通分量) 与 原图  <strong>一模一样</strong></p><p>如果原图不是一个连通图 (强连通图)，那么它的连通分量 (强连通分量) 会有 <strong>许多个</strong></p></blockquote><h2 id="生成树-amp-生成森林"><a href="#生成树-amp-生成森林" class="headerlink" title="生成树 &amp; 生成森林"></a>生成树 &amp; 生成森林</h2><p><strong>生成树：</strong>连通图包含全部顶点的一个极小连通子图</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHK1MT.png" alt=""></p><p><strong>生成森林：</strong>非连通图所有连通分量的生成树组成森林</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHKqFs.png" alt=""></p><h2 id="稀疏图-amp-稠密图"><a href="#稀疏图-amp-稠密图" class="headerlink" title="稀疏图 &amp; 稠密图"></a>稀疏图 &amp; 稠密图</h2><p><strong>稀疏图和稠密图：</strong>这里的稀疏和稠密是模糊的概念，都 是相对而言的，通常认为边或弧数小于n*logn(n是顶 点的个数）的图称为稀疏图，反之称为稠密图。 </p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHQXrT.png" alt=""></p><h2 id="顶点的度"><a href="#顶点的度" class="headerlink" title="顶点的度"></a>顶点的度</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHM6XT.png" alt=""><br><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHMgnU.png" alt=""></p><h2 id="权-amp-网"><a href="#权-amp-网" class="headerlink" title="权 &amp; 网"></a>权 &amp; 网</h2><p><strong>权和网：</strong>有些图的边或弧带有与宅相关的数字，这种与图的边或 弧相关的数叫做权(Weight)，带权的图通常称为网 (Network)。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHQeCn.png" alt=""></p><h2 id="有向树"><a href="#有向树" class="headerlink" title="有向树"></a>有向树</h2><p><strong>有向树：</strong> 一个顶点的入度为0，其余顶点的入度均为1的有向图</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UHlRY9.png" alt=""></p><h2 id="路径-amp-路径长度-amp-回路"><a href="#路径-amp-路径长度-amp-回路" class="headerlink" title="路径 &amp; 路径长度 &amp; 回路"></a>路径 &amp; 路径长度 &amp; 回路</h2><p><strong>路径：</strong>图中顶点v到顶点w的顶点序列，序列中顶点不重复的路径称为简单路径。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UH1Tcq.png" alt=""></p><p><strong>路径长度：</strong>路径上边的数目，若该路径最短则称其为距离。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UH3N2n.png" alt=""></p><p><strong>回路：</strong>第一个顶点和最后一个顶点相同的路径</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/22/UH3jqf.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树 详细总结</title>
      <link href="/2020/05/31/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/31/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h2><p>设二叉树具有n个带权值的叶节点，那么从根节点到各个叶节点的路径长度与相应节点权值的乘积的和，叫做二叉树的 <strong><font color=red>带权路径长度</font></strong>。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHXvHe.png" alt=""></p><p> <strong><font color=red>权：</font></strong> 权代表的是叶子结点的数据信息,是具体的值。也就是结点所储存的值</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHjYE4.png" alt=""></p><p>具有最小带权路径长度的二叉树称为 <strong><font color=red>哈夫曼树 (也称最优数)</font></strong> 。</p><p>相同的叶节点构造出不同的二叉树</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHjX2q.md.png" alt=""></p><h2 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h2><p>构造哈夫曼树的 <strong><font color=red>原则：</font></strong></p><p>① 权值越大的叶节点越靠近根节点</p><p>② 权值越小的叶节点越远离根节点</p><p>构造哈夫曼树的 <strong><font color=red>过程：</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHvMIH.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHxoNQ.md.png" alt=""></p><p><strong><font color=red>哈夫曼树的特点：</font></strong> <strong>n1 = 0</strong></p><p><strong>n = n0 + n1 + n2  =  n0 + n2  =  2n0 - 1</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YttzLR.md.png" alt=""></p><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>规定哈夫曼树中的 <strong><font color=red>左分支为0，右分支为1</font></strong> ，则从根节点到每个节点所经过的分支对应的0和1组成的序列便为该节点对应字符的编码。这样的编码称为 <strong><font color=red>哈夫曼编码</font></strong>。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/Ybp961.md.png" alt=""></p><p>在一组字符的哈夫曼编码中，不可能出现一个字符的哈夫曼编码是另一个字符哈夫曼编码的 <strong><font color=red>前缀</font></strong>。</p><p>例如，有4个字符的编码如下：100,  001,  0，1</p><p>这是哈夫曼编码吗？显然是错误的，因为0是001的前缀，不可能。</p><p>所以哈夫曼编码也称为 <strong><font color=red>前缀编码</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/Ybpc9J.md.png" alt=""></p><p>分析：选 <strong>D</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/Ybpb3d.md.png" alt=""></p><p>分析：选 <strong>A</strong>。哈夫曼树一定是二叉树，但不一定是完全二叉树。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树和二叉树 </tag>
            
            <tag> 哈夫曼树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线索二叉树 详细总结</title>
      <link href="/2020/05/30/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/30/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>这篇博文我总结了一下 线索二叉树知识点…</p><a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>对于具有n个节点的二叉树，采用二叉链存储时，每个节点有两个指针域，总共有 <strong>2n</strong> 个指针域。</p><p>其中只有 n-1 个节点被有效指针指向，即有 <strong>n-1</strong> 个非空指针域。</p><p>所以共有 2n - (n-1) = <strong>n+1</strong> 个空链域。</p><p><strong><font color=green>解释：</font></strong> <strong>除根节点</strong> （根节点没有指针指向）外，每个节点都有且仅有一个指向自己的指针，所以N个节点的二叉树，需要N-1个指针域，则空指针域有N+1个。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>① 采用某种方法遍历二叉树的结果是一个节点的 <strong><font color=red>线性序列</font></strong> 。</p><p>② <strong><font color=red>修改空链域</font></strong> 改为存放指向节点的前趋和后继节点的地址。</p><p>③ 这样的指向该线性序列中的 “ 前趋 ” 和 “ 后继 ” 的指针，称作 <strong><font color=red>线索 (thread)</font></strong> 。</p><p>④ 创建线索的过程称为 <strong><font color=red>线索化</font></strong> 。</p><p>⑤ <strong><font color=red>线索化的</font></strong> 二叉树称为 线索二叉树。</p><p>⑥ 显然线索二叉树与采用的遍历方法相关，有 <strong><font color=red>先序线索二叉树、中序线索二叉树和后序线索二叉树</font></strong>。</p><p>⑦ 线索二叉树的目的是提高 <strong><font color=red>该遍历过程</font></strong> 的效率。</p><h2 id="设计线索二叉树"><a href="#设计线索二叉树" class="headerlink" title="设计线索二叉树"></a>设计线索二叉树</h2><p>在节点的存储结构上增加 <strong><font color=red>两个标志位</font></strong> 来区分这两种情况：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHB8it.png" alt=""></p><p>这样，每个节点的存储结构如下：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHBYz8.png" alt=""></p><p>为了方便算法设计，在线索二叉树中再增加 <strong><font color=red>一个头节点</font></strong> 。</p><p>线索化二叉树中节点的类型定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;           <span class="comment">//节点数据域</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;          <span class="comment">//增加的线索标记</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">lchild</span>;</span>    <span class="comment">//左孩子或者线索指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">rchild</span>;</span>    <span class="comment">//右孩子或者线索指针    </span></span><br><span class="line">&#125;TBTNode;      <span class="comment">//线索树节点类型定义</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHrD2V.md.png" alt=""></p><h2 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h2><p>建立某种次序的线索化二叉树过程：</p><p>(1) 以该遍历方法遍历一棵二叉树。</p><p>(2) 在遍历的过程中，检查当前访问节点的左、右指针域是否为空：</p><p>​        ① 如果左指针域为空，将它改为指向前趋节点的线索；</p><p>​        ② 如果右指针域为空，将它改为指向后继节点的线索。</p><p>下面以 <strong><font color=red>中序线索二叉树</font></strong> 为例，设计建立线索二叉树的算法。</p><h3 id="建立中序线索二叉树的算法"><a href="#建立中序线索二叉树的算法" class="headerlink" title="建立中序线索二叉树的算法"></a>建立中序线索二叉树的算法</h3><p> ① <strong><font color=red>CreaThread(b)算法：</font></strong> 对以二叉链存储的二叉树b进行中序线索化，并返回线索化后头节点的指针root。</p><p>② <strong><font color=red>Thread(p)算法：</font></strong> 对以 *p 为根节点的二叉树子树的中序线索化。</p><p>在中序遍历中：</p><p>① p总是指向当前线索化的节点。</p><p>② pre 作为全局变量，指向刚刚访问过的节点。</p><p>③  ＊pre  是 ＊p 的中序前趋节点， ＊ p 是 ＊pre  的中序后继节点。</p><p>  <img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHcweU.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHgAmT.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">TBTNode * pre;      <span class="comment">//全局变量</span></span><br><span class="line"><span class="function">TBTNode * <span class="title">CreatThread</span><span class="params">(TBTNode * b)</span>      <span class="comment">//中序线索化二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TBTNode * root;</span><br><span class="line">    root = (TBTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TBTNode));  <span class="comment">//创建头节点</span></span><br><span class="line">    root-&gt;ltag = <span class="number">0</span>; </span><br><span class="line">    root-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    root-&gt;rchild = b;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        root-&gt;lchild = root;<span class="comment">//空二叉树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;lchild = b; </span><br><span class="line">        pre = root;<span class="comment">//pre是*p的前趋节点，供加加线索用</span></span><br><span class="line">        Thread(b);<span class="comment">//中序遍历线索化二叉树</span></span><br><span class="line">        pre-&gt;rchild = root;<span class="comment">//最后处理，加入指向头节点的线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        root-&gt;rchild = pre;<span class="comment">//头节点线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread</span><span class="params">(TBTNode *&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//中序遍历递归算法</span></span><br><span class="line">        Thread(p-&gt;lchild);<span class="comment">//左子树线索化</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)<span class="comment">//前趋线索化</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;lchild = pre;<span class="comment">//建立当前节点的前趋线索</span></span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;ltag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)<span class="comment">//后继线索化</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;rchild = p;<span class="comment">//建立前趋节点的前趋线索</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;rtag = <span class="number">0</span>;</span><br><span class="line">        pre = p; </span><br><span class="line">        Thread(p-&gt;rchild);<span class="comment">//递归调用右子树线索化 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历线索化二叉树"><a href="#遍历线索化二叉树" class="headerlink" title="遍历线索化二叉树"></a>遍历线索化二叉树</h2><p>遍历某种次序的线索二叉树，就是从该次序下的 <strong><font color=red>开始节点</font></strong> 出发，反复找到该节点在该次序下的后继节点，直到头节点。</p><p>以中序线索二叉树为例，开始节点时根节点的最左下节点。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YH78Fx.md.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在中序线索二叉树中中序遍历的过程:</span><br><span class="line">p指向根节点;</span><br><span class="line">while p ≠ root 时循环</span><br><span class="line">&#123;</span><br><span class="line">找开始节点 *p;</span><br><span class="line">访问 *p 节点;</span><br><span class="line">while(*p 节点有右线索)</span><br><span class="line">一直访问下去;</span><br><span class="line">    p 转向右孩子节点;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/21/YHHN40.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThInOrder</span><span class="params">(TBTNode * tb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TBTNode * p = tb-&gt;lchild;<span class="comment">//p指向根节点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=tb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">            p = p-&gt;lchild;<span class="comment">//找开始节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);<span class="comment">//访问开始节点</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rtag == <span class="number">1</span> &amp;&amp; p-&gt;rchild != tb)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>优点：</font></strong> 中序遍历算法既没有递归也没有用栈，空间效率得到提高。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树和二叉树 </tag>
            
            <tag> 线索二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的构造 详细总结</title>
      <link href="/2020/05/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>同一棵而二叉树（假设每个节点值唯一）具有  <strong><font color=blue>唯一</font></strong>的先序序列、中序序列、后序序列。</p><p>但 <strong><font color=blue>不同的二叉树</font></strong> 可能具有相同的先序序列，中序序列或后序序列。</p><p><strong>例如：</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4TXsP.md.png" alt=""></p><blockquote><p><strong><font color=blue>结论：</font></strong></p><p>① 给定一棵二叉树（假设每个节点值唯一）的先序、中序和后序序列可以唯一构造（确定）出该二叉树。</p><p>② 仅由先序、中序或后序序列中的 <strong>一种</strong>，无法唯一构造出该二叉树。</p></blockquote><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p><strong>那么问题来了？如果给定先序、中序和后序序列中任意两个，是否可以唯一构造出该二叉树呢？</strong></p><blockquote><p><strong><font color=blue>答案：</font></strong></p><p>① 同时给定一棵二叉树的 <strong><font color=green>先序序列和中序序列 </font></strong> 就能唯一确定这棵二叉树</p><p>② 同时给定一棵二叉树的 <strong><font color=green>中序序列和后序序列 </font></strong> 就能唯一确定这棵二叉树</p></blockquote><h3 id="定理1："><a href="#定理1：" class="headerlink" title="定理1："></a><strong><font color=red>定理1：</font></strong></h3><p>任何n（N&gt;0）个不同节点的二叉树，都可以由它的<strong>中序序列和先序序列</strong>唯一确定。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4HUBV.md.png" alt=""></p><p><strong>例如：</strong> 已知先序序列为 ABDGCEF ，中序序列为 DGBAECF，则构造二叉树的过程如下所示。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4bra8.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YIG9mD.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由上述定理得到以下算法</span></span><br><span class="line"><span class="function">BTNOde * <span class="title">CreateBT1</span><span class="params">(<span class="keyword">char</span> * pre, <span class="keyword">char</span> * in, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * s; <span class="keyword">char</span> * p; <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    s = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));  <span class="comment">//创建根节点</span></span><br><span class="line">    s-&gt;data = *pre;</span><br><span class="line">    <span class="keyword">for</span>(p = in;p &lt; in+n;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*p == *pre)<span class="comment">//在in中找为*pre的位置k</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = p-in;</span><br><span class="line">s-&gt;lchild = CreateBT1(pre+<span class="number">1</span>, in, k);<span class="comment">//构造左子树</span></span><br><span class="line">    s-&gt;rchild = CreateBT1(pre+k+<span class="number">1</span>, p+<span class="number">1</span>, n-k<span class="number">-1</span>);<span class="comment">//构造右子树</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定理2："><a href="#定理2：" class="headerlink" title="定理2："></a><strong><font color=red>定理2：</font></strong></h3><p>任何n（N&gt;0）个不同节点的二叉树，都可以由它的<strong>中序序列和后序序列</strong>唯一确定。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4qrO1.md.png" alt=""></p><p><strong>例如：</strong> 已知中序序列为 DGBAECF，后序序列 GDBEFCA 则构造二叉树的过程如下所示。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/Y4qqk8.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YI0lAf.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由上述定理得到以下算法</span></span><br><span class="line"><span class="function">BTNOde * <span class="title">CreateBT2</span><span class="params">(<span class="keyword">char</span> * post, <span class="keyword">char</span> * in, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * b; <span class="keyword">char</span> r, * p; <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    r = *(post+n<span class="number">-1</span>);                       <span class="comment">//根节点值</span></span><br><span class="line">    b = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));  <span class="comment">//创建二叉树根节点*b</span></span><br><span class="line">    b-&gt;data = r;</span><br><span class="line">    <span class="keyword">for</span>(p = in;p &lt; in+n;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*p == r)<span class="comment">//在in中找为*pre的位置k</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = p-in;<span class="comment">//k为根节点在in中的下标</span></span><br><span class="line">s-&gt;lchild = CreateBT2(post, in, k);<span class="comment">//构造左子树</span></span><br><span class="line">    s-&gt;rchild = CreateBT2(post + k, p+<span class="number">1</span>, n-k<span class="number">-1</span>);<span class="comment">//构造右子树</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题1："><a href="#例题1：" class="headerlink" title="例题1："></a><strong><font color=red>例题1：</font></strong></h3><p>设计一个算法将二叉树的<strong>顺序存储结构</strong>转化成<strong>二叉链存储结构</strong>。</p><p><strong><font color=green>解：</font></strong>设二叉树的顺序存储结构为a，由f(a,1)返回创建的二叉链存储结构的根节点指针b</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YI50VU.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode * <span class="title">trans1</span><span class="params">(SqBTree a, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * b;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[i] == <span class="string">'#'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//当节点不存在时返回NULL</span></span><br><span class="line">    b = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));   <span class="comment">//创建根节点</span></span><br><span class="line">    b -&gt; data = a[i];</span><br><span class="line">    b -&gt; lchild = trans1(a, <span class="number">2</span>*i);     <span class="comment">//递归创建左子树</span></span><br><span class="line">    b -&gt; rchild = trans1(a, <span class="number">2</span>*i+<span class="number">1</span>);     <span class="comment">//递归创建左子树</span></span><br><span class="line">    <span class="keyword">return</span>(b);<span class="comment">//返回根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此算法是先序遍历的思路</span></span><br></pre></td></tr></table></figure><h3 id="例题2："><a href="#例题2：" class="headerlink" title="例题2："></a><strong><font color=red>例题2：</font></strong></h3><p>设计一个算法将二叉树的<strong>二叉链存储结构</strong>转化成<strong>顺序存储结构</strong>。</p><p><strong><font color=green>解：</font></strong>f(b，a，i)：由二叉链b创建a[i]为根节点的顺序存储结构a</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/19/YIoA1A.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">trans2</span><span class="params">(BTNode * b, SqBTree a, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = b -&gt; data;<span class="comment">//创建根节点</span></span><br><span class="line">        trans2(b -&gt; lchild, a, <span class="number">2</span>*i);     <span class="comment">//递归创建左子树</span></span><br><span class="line">        trans2(b -&gt; rchild, a, <span class="number">2</span>*i+<span class="number">1</span>);     <span class="comment">//递归创建左子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此算法是先序遍历的思路</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树和二叉树 </tag>
            
            <tag> 构造二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的基本运算及其实现 详细总结</title>
      <link href="/2020/05/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的基本运算概述"><a href="#二叉树的基本运算概述" class="headerlink" title="二叉树的基本运算概述"></a>二叉树的基本运算概述</h2><p>①  <strong><font color=red>创建二叉树 CreateBTNode(*b, *str)：</font></strong> 根据根据二叉树括号表示法字符串str生成对应的二叉链存储结构b</p><p>②  <strong><font color=red>销毁二叉链存储结构 DestoryBT( *b)：</font></strong> 销毁二叉链b并释放空间</p><p>③  <strong><font color=red>查找节点 FindNode(*b, x)：</font></strong> 在二叉树b中寻找data域值为x的节点，并返回指向该节点的指针</p><p>④  <strong><font color=red>找孩子节点 LchildNode(p) 和 RchildNode(p)：</font></strong>分别求二叉树中节点*p的左孩子节点和右孩子节点</p><p>⑤  <strong><font color=red>求高度 BTNodeDepth(*b)：</font></strong>求二叉树b的高度。若二叉树为空，则其高度为0; 否则，其高度等于左子树和右子树中的最大高度加1</p><p>⑥  <strong><font color=red>输出二叉树 DispBTNode(*b)：</font></strong>以括号表示法输出一棵二叉树</p><h2 id="二叉树的基本运算算法实现"><a href="#二叉树的基本运算算法实现" class="headerlink" title="二叉树的基本运算算法实现"></a>二叉树的基本运算算法实现</h2><h3 id="1-创建二叉树-CreateBTNode-b-str-："><a href="#1-创建二叉树-CreateBTNode-b-str-：" class="headerlink" title="1. 创建二叉树 CreateBTNode(*b, *str)："></a><strong><font color=red>1. 创建二叉树 CreateBTNode(*b, *str)：</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YN4QmR.md.png" alt=""></p><h4 id="算法设计："><a href="#算法设计：" class="headerlink" title=" 算法设计："></a><strong><font color=red> 算法设计：</font></strong></h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YN4KX9.md.png" alt=""></p><h4 id="用ch扫描采用括号表示法表示二叉树的字符串："><a href="#用ch扫描采用括号表示法表示二叉树的字符串：" class="headerlink" title=" 用ch扫描采用括号表示法表示二叉树的字符串："></a><strong><font color=red> 用ch扫描采用括号表示法表示二叉树的字符串：</font></strong></h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YN4zAx.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由str → 二叉链b</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBTNode</span><span class="params">(BTNode *b, <span class="keyword">char</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *St[MaxSize], *p;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>, k, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;                   </span><br><span class="line">    b = <span class="literal">NULL</span>;       <span class="comment">//建立的二叉链初始时为空</span></span><br><span class="line">    ch = str[j];</span><br><span class="line">    <span class="keyword">while</span>(ch != <span class="string">'\0'</span>)  <span class="comment">//str未扫描完时循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span> :top++;St[top] = p; k = <span class="number">1</span>; <span class="keyword">break</span>;  <span class="comment">//可能有左孩子节点，进栈</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span> :top--;<span class="keyword">break</span>;<span class="comment">//退栈</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">','</span> :k = <span class="number">2</span>;<span class="keyword">break</span>;      <span class="comment">//后面为右孩子节点</span></span><br><span class="line">            <span class="keyword">default</span> :<span class="comment">//遇到节点值</span></span><br><span class="line">                p = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>)(BTNode);</span><br><span class="line">                p-&gt;data=ch;</span><br><span class="line">                p-&gt;lchild = p-&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span>(b = <span class="literal">NULL</span>)<span class="comment">//p为二叉树的根节点</span></span><br><span class="line">                    b = p;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//已建立二叉树根节点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">switch</span>(k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>: St[top]-&gt;lchild = p;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>: St[top]-&gt;rchild = p;<span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        j++; ch =str[j];      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-销毁二叉链-DestoryBT-b-："><a href="#2-销毁二叉链-DestoryBT-b-：" class="headerlink" title="2. 销毁二叉链 DestoryBT( *b)："></a><strong><font color=red>2. 销毁二叉链 DestoryBT( *b)：</font></strong></h3><p>设f(b)销毁二叉链b：<strong><font color=red>大问题</font></strong></p><p>则f(b-&gt;lchild)销毁左子树，f(b-&gt;rchild)销毁右子树：<strong><font color=red>两个小问题</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YNzUgA.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryBT</span><span class="params">(BTNOde *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        DestoryBT(b-&gt;lchild);</span><br><span class="line">        DestoryBT(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(b);  <span class="comment">//剩下一个节点*b，直接释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-查找节点-FindNode-b-x"><a href="#3-查找节点-FindNode-b-x" class="headerlink" title="3. 查找节点 FindNode(*b, x)"></a><strong><font color=red>3. 查找节点 FindNode(*b, x)</font></strong></h3><p>设f(b, x)在二叉树b中查找值为x的节点（唯一）。找到后返回其指针，否则返回NULL。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YUF5Qg.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function">BTNode * <span class="title">FindNode</span><span class="params">(BTNode * b, ELemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * p;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;data == x)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = FindNode(b-&gt;lchild, x);</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> FindNode(b-&gt;rchild, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-找孩子节点-LchildNode-p-和-RchildNode-p"><a href="#4-找孩子节点-LchildNode-p-和-RchildNode-p" class="headerlink" title="4. 找孩子节点 LchildNode(p) 和 RchildNode(p)"></a><strong><font color=red>4. 找孩子节点 LchildNode(p) 和 RchildNode(p)</font></strong></h3><p>直接返回 *p 节点的左孩子节点或右孩子节点的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode * <span class="title">LchildNode</span><span class="params">(BTNode * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BTNode * <span class="title">RchildNode</span><span class="params">(BTNode * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-求高度-BTNodeDepth-b"><a href="#5-求高度-BTNodeDepth-b" class="headerlink" title="5. 求高度 BTNodeDepth(*b)"></a><strong><font color=red>5. 求高度 BTNodeDepth(*b)</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YUAzZ9.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BTNodeDepth</span><span class="params">(BTNode * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lchildep,rchilddep;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);    <span class="comment">//空树的高度为0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        lchildep = BTNodeDepth(b-&gt;lchild);   <span class="comment">//求左子树的高度lchildep</span></span><br><span class="line">        rchilddep = BTNodeDepth(b-&gt;rchild);  <span class="comment">//求右子树的高度rchildep</span></span><br><span class="line">        <span class="keyword">return</span> ((lchildep&gt;rchilddep)?(lchildep+<span class="number">1</span>):(rchildep+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-输出二叉树-DispBTNode-b"><a href="#6-输出二叉树-DispBTNode-b" class="headerlink" title="6. 输出二叉树 DispBTNode(*b)"></a><strong><font color=red>6. 输出二叉树 DispBTNode(*b)</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YUVOHJ.md.png" alt=""></p><p>根节点 （ 左子树  ，右子树） ←  括号表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">DispBTNode</span><span class="params">(BTNode * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;lchild != <span class="literal">NULL</span> || b-&gt;rchild != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">            DispBTNode(b-&gt;lchild);  <span class="comment">//递归处理左子树</span></span><br><span class="line">            <span class="keyword">if</span>(b-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">","</span>);</span><br><span class="line">            DispBTNode(b-&gt;rchild);  <span class="comment">//递归处理右子树</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树和二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历及其应用 详细总结</title>
      <link href="/2020/05/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树遍历的概念"><a href="#二叉树遍历的概念" class="headerlink" title="二叉树遍历的概念"></a>二叉树遍历的概念</h2><p><strong><font color=red>二叉树的遍历</font></strong> 是指按照一定次序访问树中所有节点，并且 <strong><font color=red>每个节点仅被访问一次</font></strong> 的过程。</p><p>遍历是二叉树最基本的运算，是二叉树其他运算的基础。</p><p><strong>二叉树的组成：</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/Yd2JFf.png" alt=""></p><h3 id="1-先序遍历过程"><a href="#1-先序遍历过程" class="headerlink" title="1. 先序遍历过程"></a><strong><font color=red>1. 先序遍历过程</font></strong></h3><p>先序遍历NLR二叉树的过程是：</p><p>① 访问根节点;</p><p>② 先序遍历左子树;</p><p>③ 先序遍历右子树。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdR9tf.md.png" alt=""></p><h3 id="2-中序遍历过程"><a href="#2-中序遍历过程" class="headerlink" title="2. 中序遍历过程"></a><strong><font color=red>2. 中序遍历过程</font></strong></h3><p>中序遍历LNR二叉树的过程是：</p><p>① 中序遍历左子树；</p><p>② 访问根节点；</p><p>③ 中序遍历右子树。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdRi9S.md.png" alt=""></p><h3 id="3-后序遍历过程"><a href="#3-后序遍历过程" class="headerlink" title="3. 后序遍历过程"></a><strong><font color=red>3. 后序遍历过程</font></strong></h3><p>中序遍历LNR二叉树的过程是：</p><p>① 后序遍历左子树；</p><p>② 后序遍历右子树；</p><p>③ 访问根节点。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdRCh8.md.png" alt=""></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a><strong><font color=green>例题</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YdftfK.md.png" alt=""></p><h2 id="二叉树遍历递归算法"><a href="#二叉树遍历递归算法" class="headerlink" title="二叉树遍历递归算法"></a>二叉树遍历递归算法</h2><p>由二叉树的三种遍历过程直接得到3种递归算法</p><h3 id="先序遍历的递归算法"><a href="#先序遍历的递归算法" class="headerlink" title="先序遍历的递归算法"></a><strong><font color=blue>先序遍历的递归算法</font></strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(b-&gt;lchild);</span><br><span class="line">        PreOrder(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 <strong>访问</strong> 是直接输出节点值。实际上，访问节点可以对该节点进行各种操作，如计数，删除节点等。</p><h3 id="中序遍历的递归算法"><a href="#中序遍历的递归算法" class="headerlink" title="中序遍历的递归算法"></a><strong><font color=blue>中序遍历的递归算法</font></strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrder(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">        InOrder(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历的递归算法"><a href="#后序遍历的递归算法" class="headerlink" title="后序遍历的递归算法"></a><strong><font color=blue>后序遍历的递归算法</font></strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrder(b-&gt;lchild);</span><br><span class="line">        PostOrder(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层次遍历算法"><a href="#层次遍历算法" class="headerlink" title="层次遍历算法"></a>层次遍历算法</h2><p>层次遍历过程：</p><p>对于一棵二叉树，从根节点开始，按从上到下，从左到右的顺序访问每一个节点。</p><p>每个节点仅仅访问一次。</p><h3 id="算法设计思路"><a href="#算法设计思路" class="headerlink" title="算法设计思路"></a>算法设计思路</h3><p>使用一个队列。</p><p>Ⅰ 将根节点进队;</p><p>Ⅱ <strong><font color=blue>队不空时循环</font></strong>：从队列中列出一个节点 *p 访问它；</p><p>​    ① 若它有左孩子节点，将左孩子节点进队；</p><p>​    ② 若它有右孩子节点，将右孩子节点进队。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BTNode * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode * p;</span><br><span class="line">    BTNode *qu[MaxSize];  <span class="comment">//定义环形队列，存放节点指针</span></span><br><span class="line">    <span class="keyword">int</span> front,rear;       <span class="comment">//定义对头和队尾指针</span></span><br><span class="line">    front = rear = <span class="number">0</span>;     <span class="comment">//置队列为空队列</span></span><br><span class="line">    rear++;</span><br><span class="line">    qu[rear] = b;         <span class="comment">//根节点指针进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(front != rear)  <span class="comment">//队列不为空循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        front = (front + <span class="number">1</span>)%MaxSize;</span><br><span class="line">        p = qu[front];    <span class="comment">//队头出队列</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);  <span class="comment">//访问节点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)   <span class="comment">//有左孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear = (rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">            qu[rear] = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)   <span class="comment">//有右孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear = (rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">            qu[rear] = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法的时间复杂度为O(n)</strong></p><h2 id="二叉树3种递归遍历算法的应用"><a href="#二叉树3种递归遍历算法的应用" class="headerlink" title="二叉树3种递归遍历算法的应用"></a>二叉树3种递归遍历算法的应用</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><strong><font color=green>基本思路</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/Yw1DA0.md.png" alt=""></p><p><strong><font color=green>例1：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法，计算一棵给定二叉树的所有节点个数</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwGAkq.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Nodes</span><span class="params">(BTNode * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Nodes(b-&gt;lchild)+Nodes(b-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//先左子树，再右子树，最后根节点，是后序遍历的思路</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>提示</font></strong>:<strong>本例算法可以基于任何一种遍历算法</strong></p><p><strong><font color=green>例2：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法，计算一棵给定二叉树的所有叶子节点个数</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwGp6g.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafNodes</span><span class="params">(BTNode * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1,num2;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; b-&gt;rchlid == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        num1 = LeafNodes(b-&gt;lchild);</span><br><span class="line">        num2 = LeafNodes(b-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> (num1+num2);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>提示</font></strong>:<strong>本例算法可以基于任何一种遍历算法</strong></p><p><strong><font color=green>例3：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法把二叉树b复制到二叉树t中</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwJUP0.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(BTNode * b, BTNode * t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">        t-&gt;data = b-&gt;data;<span class="comment">//复制一个根节点*t</span></span><br><span class="line">        Copy(b-&gt;lchild, t-&gt;lchild);    <span class="comment">//递归复制左子树</span></span><br><span class="line">        Copy(b-&gt;rchild, t-&gt;rchild);     <span class="comment">//递归复制右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>先根节点，再左子树，最后右子树，是先序遍历的思路</p><p><strong><font color=green>例4：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法把二叉树b的左、右子树进行交换。要求 <font color=red>不破坏原二叉树</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwYGQO.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(BTNode * b, BTNode * t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">        t-&gt;data = b-&gt;data;<span class="comment">//复制一个根节点*t</span></span><br><span class="line">        Swap(b-&gt;lchild, t-&gt;rchild);    <span class="comment">//递归交换左子树</span></span><br><span class="line">        Swap(b-&gt;rchild, t-&gt;lchild);     <span class="comment">//递归交换右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=green>例5：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法level()求二叉树b中值为x的节点的层次（假设所有节点值唯一）。</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwtDE9.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwtrNR.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/Ywt0HJ.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">(BTNode * b, ElemType x, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空树时返回0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;data == x)<span class="comment">//找到节点时</span></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        l = level(b-&gt;lchild, x, h+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> level(b-&gt;rchild, x, h+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> l;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>注意：</font></strong>基于<strong>先序遍历</strong>算法思想</p><h2 id="层次遍历算法的应用"><a href="#层次遍历算法的应用" class="headerlink" title="层次遍历算法的应用"></a>层次遍历算法的应用</h2><p><strong><font color=green>例1：</font></strong>假设二叉树采用二叉链存储结构存储，<strong>设计一个算法输出从根节点到每个叶子节点的逆路径。</strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwNJVH.png" alt=""></p><p><strong>解：</strong> 设计的队列为非环形队列qu，将所有已访问过的节点指针进队，并在队列中保存双亲节点的位置。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/13/YwNxsO.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AllPath</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snode</span>;</span></span><br><span class="line">    &#123;</span><br><span class="line">        BTNode * node;     <span class="comment">//存放当前节点指针</span></span><br><span class="line">        <span class="keyword">int</span> parent;   <span class="comment">//存放双亲节点在队列中的位置</span></span><br><span class="line">    &#125;qu[MaxSize];   <span class="comment">//定义非环形队列</span></span><br><span class="line">    BTNode *q;</span><br><span class="line">    <span class="keyword">int</span> front, rear, p;    <span class="comment">//定义队头和队尾指针</span></span><br><span class="line">    front = rear = <span class="number">-1</span>;     <span class="comment">//置队列为空队列</span></span><br><span class="line">    rear++;</span><br><span class="line">    qu[rear].node = b;     <span class="comment">//根节点指针进去队列</span></span><br><span class="line">    qu[rear].parent = <span class="number">-1</span>;  <span class="comment">//根节点没有双亲节点</span></span><br><span class="line">    <span class="keyword">while</span>(front != rear)   <span class="comment">//队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        front++;   <span class="comment">//front是当前节点*q在qu中的位置</span></span><br><span class="line">        q = qu[front].node;  <span class="comment">//队列出队列，该节点指针仍在qu中</span></span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; q-&gt;rchild == <span class="literal">NULL</span>)  <span class="comment">//*q为叶子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = front;     <span class="comment">//输出*q到根节点的逆路径序列</span></span><br><span class="line">            <span class="keyword">while</span>(qu[p].parent != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c-&gt;"</span>, qu[p].node-&gt;data);</span><br><span class="line">                p = qu[p].parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c\m"</span>, qu[p].node-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild != <span class="literal">NULL</span>)   <span class="comment">//*q节点有左孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear++;</span><br><span class="line">            qu[rear].node = q-&gt;lchild;</span><br><span class="line">            qu[rear].parent = front;  <span class="comment">//*q的左孩子的双亲位置为front</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild != <span class="literal">NULL</span>)   <span class="comment">//*q节点有右孩子时将其进队</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear++;</span><br><span class="line">            qu[rear].node = q-&gt;rchild;</span><br><span class="line">            qu[rear].parent = front;  <span class="comment">//*q的右孩子的双亲位置为front</span></span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树和二叉树 </tag>
            
            <tag> 遍历二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的存储结构 详细总结</title>
      <link href="/2020/05/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YNQAcq.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YNQEj0.md.png" alt=""></p><h3 id="二叉树顺序存储结构的特点"><a href="#二叉树顺序存储结构的特点" class="headerlink" title="二叉树顺序存储结构的特点"></a>二叉树顺序存储结构的特点</h3><p>① 对于 <strong><font color=red>完全二叉树</font></strong> 来说，期顺序存储是十分合适的。</p><p>② 对于 <strong><font color=red>一般的二叉树</font></strong> ，特别是对于那些单分支节点较多的二叉树来说是很不合适的，因为可能只有少数的存储单元被利用，特别是对退化的二叉树(即每个节点都是单分支的)，空间浪费更是惊人。</p><p>③ 在顺序存储结构中，<strong><font color=red>找一个节点的双亲和孩子都很容易</font></strong>。</p><h2 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h2><p>借鉴 <strong><font color=blue>树的孩子链存储结构</font></strong> → 二叉树的链式存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉树的链式存储中，节点定义如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>*<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>  <span class="comment">//指向的都是二叉树:递归性</span></span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YNGs76.md.png" alt=""></p><h3 id="二叉链存储结构的特点"><a href="#二叉链存储结构的特点" class="headerlink" title="二叉链存储结构的特点"></a>二叉链存储结构的特点</h3><p>① 除了指针外，二叉链  <strong><font color=red>比较节省存储空间</font></strong>。占用的存储空间与树形没有关系，只与树中节点个数有关。</p><p>② 在二叉链中，<strong><font color=red>找一个节点的孩子很容易</font></strong>，但找其双亲不方便。</p><p>一棵树采用孩子兄弟链存储结构表示  →  二叉链</p><h3 id="二叉链中空指针的个数"><a href="#二叉链中空指针的个数" class="headerlink" title="二叉链中空指针的个数"></a>二叉链中空指针的个数</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YNJTM9.md.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树和二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的概念 详细总结</title>
      <link href="/2020/05/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树是有限的节点集合 （<strong><font color=red>递归定义</font></strong> ）</p><p>① 这个集合或者是空</p><p>② 或者由一个根节点和两颗互不相交的称为  <strong><font color=red>左子树</font></strong> 和 <strong><font color=red>右子树</font></strong> 的二叉树组成。</p><h3 id="二叉树的五种基本形态："><a href="#二叉树的五种基本形态：" class="headerlink" title="二叉树的五种基本形态："></a><strong><font color=blue>二叉树的五种基本形态：</font></strong></h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YtFeq1.md.png" alt=""></p><h3 id="二叉树的逻辑结构表示法："><a href="#二叉树的逻辑结构表示法：" class="headerlink" title="二叉树的逻辑结构表示法："></a><strong><font color=blue>二叉树的逻辑结构表示法：</font></strong></h3><p>① 树形表示法</p><p>② 文氏图表示法</p><p>③ 凹入表示法</p><p>④ 括号表示法</p><h3 id="二叉树和二次树区别："><a href="#二叉树和二次树区别：" class="headerlink" title="二叉树和二次树区别："></a><strong><font color=red>二叉树和二次树区别：</font></strong></h3><p>① <strong>度不同</strong></p><p>度为2的树要求每个节点最多只能有两棵子树，并且至少有一个节点有两棵子树。二叉树的要求是度不超过2，节点最多有两个叉，可以是1或者0。</p><p>② <strong>分支不同</strong></p><p>度为2的树有两个分支，但分支没有左右之版分；一棵二叉树也有两个分支，但有左右之分，左右子树的次序不能随意颠倒。</p><p>③ <strong>次序不同</strong></p><p>度为2的树从形式上看与二叉树很相似，但它的子树是无序的，而二叉树是有序的。即，在一般树中若某结点只有一个孩子，就无需区分其左右次序，而在二叉树中即使是一个孩子也有左右之分。</p><h3 id="两种特殊的二叉树："><a href="#两种特殊的二叉树：" class="headerlink" title="两种特殊的二叉树："></a><strong><font color=blue>两种特殊的二叉树：</font></strong></h3><p><strong><font color=red>满二叉树：</font></strong></p><p>在一棵二叉树中：</p><p>① 如果所有分支节点都有分支节点;</p><p>② 并且叶节点都集中在二叉树的最下一层。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YtZfxS.md.png" alt=""></p><p><strong><font color=red>完全二叉树：</font></strong></p><p>在一棵二叉树中：</p><p>① 最多只有下面两层节点的度数小于2</p><p>② 并且最下面一层的叶节点都依次排列在该层最左边的位置上。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YtYujA.md.png" alt=""></p><p><strong><font color=red>完全二叉树</font></strong> 实际上是对应的 <strong><font color=red>满二叉树</font></strong> 删除叶节点层最右边若干个节点得到的。</p><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YttzLR.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YtNVQH.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YtNESe.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/Ytdrp8.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/Ytds1S.md.png" alt=""></p><h2 id="二叉树与树、森林之间的转换"><a href="#二叉树与树、森林之间的转换" class="headerlink" title="二叉树与树、森林之间的转换"></a>二叉树与树、森林之间的转换</h2><h3 id="1-森林、树转换为二叉树"><a href="#1-森林、树转换为二叉树" class="headerlink" title="1. 森林、树转换为二叉树"></a><strong><font color=red>1. 森林、树转换为二叉树</font></strong></h3><p><strong>一棵树转换为二叉树</strong></p><p>① 把兄弟节点连接起来</p><p>② 所有节点顺时针旋转45度</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/Yt02iq.md.png" alt=""></p><p><strong>多颗树转换为二叉树</strong></p><p><strong>方法一：</strong></p><p>① 把每个树分别转换为二叉树</p><p>② 把后一个二叉树作为前一个二叉树的右子树，依次连接成一棵二叉树</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/Yt0con.md.png" alt=""></p><p><strong>方法二：</strong></p><p>① 给这几个树加上一个根节点</p><p>② 再将这棵新的树转换为二叉树</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/Yt0yZj.md.png" alt=""></p><h3 id="2-二叉树还原为森林、树"><a href="#2-二叉树还原为森林、树" class="headerlink" title="2. 二叉树还原为森林、树"></a><strong><font color=red>2. 二叉树还原为森林、树</font></strong></h3><p>*<em>一棵二叉树还原为一棵 树 *</em></p><p>① 考察每个节点的右分支节点，把每个右分支节点节点与它的双亲节点连接起来</p><p>② 删除掉右分支线</p><p>③ 再将此树逆时针旋转45度。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YtBXAs.md.png" alt=""></p><p>*<em>一棵二叉树还原为 多颗树 *</em></p><p>① 考察这棵树，把从根节点的右分支节点开始，每个节点对应的树圈起来。也就是把这棵二叉树转换为3棵二叉树(以图为例)</p><p>② 再把三棵二叉树分别还原成树</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/Ytr1MT.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/YtrQzV.md.png" alt=""></p><p><strong><font color=green>例题：</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/12/Yt7jUI.md.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树和二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的概念运算和存储结构 详细总结</title>
      <link href="/2020/05/24/%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E8%BF%90%E7%AE%97%E5%92%8C%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/24/%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E8%BF%90%E7%AE%97%E5%92%8C%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%20%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p><strong><font color=red>树形式化定义：</font></strong>T = {D, R} 。（D表示 数据对象，R 表示数据关系）</p><p>D是包含n个节点的有限集合（n≥0）。当n = 0时为 <strong>空树</strong>，否则关系 R 满足以下条件：</p><p>① 有且仅有一个节点 d0 ∈ D，它对于关系R来说没有前趋节点，节点d0称作 树的 <font color=red><strong>根节点</strong></font>。</p><p>② 除<font color=red> <strong>根节点</strong> </font>外每个节点有且 <font color=red><strong>仅有一个前趋节点</strong></font>。</p><p>③ D中每个节点可以有 <font color=red><strong>零个或多个后继节点</strong></font> 。</p><p><strong><font color=red>树的递归定义：</font></strong>树是由n （n≥0）个节点组成的有限集合（记为T）。其中：</p><p>① 如果n = 0, 它是一棵空树，这是树的特例。</p><p>② 如果n &gt; 0, 其中存在一个唯一节点作为输的根节点（root），其余节点可分为m（m≥0）个互不相交的有限子集T1、T2 、…、Tm，而每个子集本身又是一棵 <font color=red><strong>树</strong></font> ，称为根节点root的子树。</p><p>**<font color=blue>树中所有节点构成一种层次关系</font> **</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/YlI2GR.md.jpg" style="zoom:50%;" /><h3 id="树的实际应用"><a href="#树的实际应用" class="headerlink" title="树的实际应用"></a>树的实际应用</h3><p>① <strong>红黑树:</strong> JAVA8中的hashMap满足一定的阈值，自动扩容时会变为红黑树，treeMap，linux中的epoll模型，nginx中的Timer管理等。</p><p>② <strong>B，B＋树:</strong>广泛用于数据库(mysql，oracle等)的索引。</p><p>③ <strong>字典树:</strong>用于海量文本词频统计，查询效率比哈希表还高。</p><p>④ 生活中的树状结构有公司职级关系，国家省市区级联，族谱等等都有树结构形式.</p><h3 id="树的（逻辑）表示"><a href="#树的（逻辑）表示" class="headerlink" title="树的（逻辑）表示"></a>树的（逻辑）表示</h3><p>(1) <font color=red><strong>树形表示法：</strong></font> 使用一棵倒置的树表示树结构，非常直观和形象。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/YlzPFx.png" style="zoom: 67%;" /><p>(2) <font color=red><strong>文氏图表示法：</strong></font> 使用集合以及集合的包含关系来描述树结构。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/YlziY6.png" style="zoom: 50%;" /><p>(3) <font color=red><strong>凹入表示法：</strong></font>使用线段的伸缩关系描述树结构</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/YlzFfK.png" style="zoom:50%;" /><p>(4) <font color=red><strong>括号表示法：</strong></font>用一个字符串表示树</p><p>基本形式： 根（子树1，子树2，…，子树m）</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Ylz9T1.png" style="zoom:50%;" /><h3 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h3><p><strong><font color=red>1. 节点的度与树的度：</font></strong></p><p>树中一个节点的子树的个数称为该<font color=red><strong>节点的度</strong></font>。树中各节点的度的最大值称为<font color=red><strong>树的度</strong></font>，通常将度为m的树称为 <font color=red><strong>m次树</strong></font> 或者 <font color=red><strong>m叉树</strong></font>。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Y19tne.png" style="zoom:50%;" /><p><strong><font color=red>2. 分支节点与叶节点：</font></strong></p><p>度不为0的节点称为非终端节点，又叫 <font color=red><strong>分支节点</strong></font>。度为0的节点称为终端节点或<font color=red><strong>叶节点</strong></font>（或<font color=red><strong>叶子节点</strong></font>）。</p><p>度为1的节点称为 <font color=red><strong>单分支节点</strong></font>；度为2的节点称为<font color=red><strong>双分支节点</strong></font>，依次类推。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Y1PFMT.png" alt="Y1PFMT.png" style="zoom:50%;" /><p><strong><font color=red>3. 路径与路径长度：</font></strong></p><p>两个节点di和dj的节点序列（di，di1，di2，…，dj）称为<font color=red><strong>路径</strong></font>。其中&lt;dx,dy&gt;是 分支。</p><p><strong><font color=red>路径长度</font></strong> 等于路径所通过的节点数目减1（即路径上分支数目）。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Y1PksU.png" alt="Y1PksU.png" style="zoom:67%;" /><p><strong><font color=red>4. 孩子节点，双亲节点和兄弟节点：</font></strong></p><p>在一棵树中。每个节点的后继称作该节点的 <font color=red><strong>孩子节点</strong></font>（或子女节点）。相应地，该节点被称作孩子节点的 <font color=red><strong>双亲节点</strong></font>（或父母节点）。具有同一双亲的孩子节点互为 <font color=red><strong>兄弟节点</strong></font>。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Y1PVZ4.png" alt="Y1PVZ4.png" style="zoom:67%;" /><p><strong><font color=red>5.子孙节点和祖先节点：</font></strong></p><p>在一棵树中，一个节点的所有子树中的节点称为该节点的 <font color=red><strong>子孙节点</strong></font>。</p><p>从根节点到达一个节点的路径上经过的所有节点被称为该节点的<font color=red><strong>祖先节点</strong></font>。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Y1PALF.png" alt="Y1PALF.png" style="zoom:67%;" /><p><strong><font color=red>6.节点的层次和树的高度：</font></strong></p><p>树中的每个节点都处在一个层次上。节点的层次从树根开始定义，根节点为第一层，它的孩子节点为第二层，以此类推，一个节点所在的层次为其双亲节点所在层次加1。</p><p>树中节点的最大层次称为树的<font color=red><strong>树的高度</strong></font>（或树的 <font color=red><strong>深度</strong></font>）。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Y1kT0S.png" style="zoom:67%;" /><p><strong><font color=red>7.有序树和无需树：</font></strong></p><p>若树中各节点的子树是按照一定的次序从左往右安排的，且相对次序是不能随意变换的，则称为 <font color=red><strong>有序树</strong></font>，否则称为 <font color=red><strong>无序树</strong></font>。</p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/09/Y1AMAe.png" style="zoom:67%;" /><p><strong><font color=red>8.森林：</font></strong></p><p>n（n&gt;0）个互不相交的树的集合称为 <font color=red><strong>森林</strong></font>。</p><p>只要把树的根节点删去就成了森林。反之，只要给n棵独立的树加上一个根节点，并把这n棵树作为该节点的子树，则森林就变成了一棵树。</p><p><strong><font color=blue>独木也成林！！</font></strong></p><h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><p><strong><font color=red>性质1：</font></strong>树中的节点数等于所有节点的度数+1</p><p>① 树中每个分支为一个节点的度  →  <font color=blue><strong>所有节点的度之和 = 分支数</strong></font></p><p>② 根节点加上一个分支，这分支数与节点数相同 → <font color=blue><strong>实际分支数 = n-1</strong></font></p><p><strong><font color=blue>n = 度之和 +1</font></strong></p><p><strong><font color=green>例题：</font></strong></p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y3fEpq.png" style="zoom:67%;" /><p><strong><font color=red>性质2：</font></strong>度为m的树中第i层上至多有m的(i-1)次个节点（i≥1）</p><p><strong><font color=blue>度为3的树第二层至多有3个节点</font></strong>    3的(2-1)次 = 3</p><p><strong><font color=red>性质3：</font></strong></p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y34AyV.png" style="zoom:67%;" /><p><strong><font color=red>性质4：</font></strong></p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y34kQ0.png" style="zoom:80%;" /><h2 id="树的运算和存储结构"><a href="#树的运算和存储结构" class="headerlink" title="树的运算和存储结构"></a>树的运算和存储结构</h2><h3 id="树的基本运算"><a href="#树的基本运算" class="headerlink" title="树的基本运算"></a>树的基本运算</h3><p>树的运算主要分为三大类：</p><p><font color=red><strong>查找</strong></font>满足某种特点关系的节点，如查找当前节点的双亲节点等;</p><p><font color=red><strong>插入或删除</strong></font>某个节点，如在树的当前节点上插入一个新节点或者删除当前节点的第i个孩子节点等</p><p><font color=red><strong>遍历</strong></font>树中每个节点。</p><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>树的遍历运算是指按照某种访问方式访问树中的 <strong><font color=blue>每一个节点且每一个节点只能被访问一次。</font></strong></p><p><strong><font color=green>主要的遍历方法：</font></strong></p><p>① <font color=red><strong>先根遍历：</strong></font>若树不空，则先访问根节点，然后依次先根遍历各棵子树。</p><p>② <font color=red><strong>后根遍历：</strong></font>若树不空，则依次后根遍历各棵子树，然后访问根节点。</p><p>③ <font color=red><strong>层次遍历：</strong></font>若树不空，则自上而下、自左至右访问树中每个节点。</p><p><strong><font color=red>注意：</font><font color=blue>先根和后根遍历算法都是递归的。</font></strong></p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y3ThUU.md.png" style="zoom:50%;" /><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y3T45F.md.png" style="zoom:50%;" /><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y3TfET.md.png" style="zoom:50%;" /><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p><strong><font color=red>1. 双亲存储结构</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y8FfZ8.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双亲存储结构的类型声明如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;   <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">int</span> parent;      <span class="comment">//指向双亲的位置</span></span><br><span class="line">&#125;PTree[MaxSize];</span><br></pre></td></tr></table></figure><p><strong><font color=red>2. 孩子链存储结构</font></strong></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y8k7kD.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 孩子链存储结构的类型声明如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;   <span class="comment">//节点的值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">sons</span>[<span class="title">MaxSons</span>];</span>      <span class="comment">//指向孩子节点</span></span><br><span class="line">&#125;PSonNode;</span><br></pre></td></tr></table></figure><p>其中，MaxSons为最多的孩子节点个数。</p><p><strong><font color=red>3. 孩子兄弟链存储结构</font></strong></p><p>孩子兄弟链存储结构是为每个节点设计3个域：</p><p>① 一个数据元素域</p><p>② 第一个孩子节点指针域</p><p>③  一个兄弟节点指针域</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/10/Y8A7D0.md.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 孩子兄弟链存储结构的类型声明如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;   <span class="comment">//节点的值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> * <span class="title">hp</span>;</span>      <span class="comment">//指向兄弟节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> * <span class="title">vp</span>;</span>      <span class="comment">//指向第一个孩子节点</span></span><br><span class="line">&#125;TSBNode;</span><br></pre></td></tr></table></figure><p>每个节点固定只有两个指针域！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树和二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法和算法分析基础</title>
      <link href="/2020/05/23/%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/05/23/%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>抽象化是一种非常的不同于模糊化的东西 … 抽象的目的并不是为了模糊，而是为了创造出一种能让我们做到百分百精确的新语义。<br>                                                                                                                    ——— Edsger Dijkstra</p></blockquote><h2 id="算法VS程序"><a href="#算法VS程序" class="headerlink" title="算法VS程序"></a>算法VS程序</h2><p>很多人误以为程序就是算法，其实不然：算法是解决某个问题的想法、思路；而程序是在心中有算法的前提下编写出来的可以运行的代码。</p><p>例如，要解决依次输出一维数组中的数据元素的值的问题，首先想到的是使用循环结构（ for 或者 while ），在有这个算法的基础上，开始编写程序。</p><p>所以，算法相当于是程序的雏形。当解决问题时，首先心中要有解决问题的算法，围绕算法编写出程序代码。</p><p>##算法定义：<br><strong>算法</strong> 是解决特定问题求解步骤的描述，它是指令的有限序列，其中每条指令表示一个或多个操作</p><h2 id="算法的五大特性"><a href="#算法的五大特性" class="headerlink" title="算法的五大特性"></a>算法的五大特性</h2><blockquote><p>（1）<strong>有穷性：</strong>算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成<br>（2）<strong>确定性：</strong>算法中的每一步都有确定的含义，不会出现二义性<br>（3）<strong>可行性：</strong>算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成<br>（4）<strong>输入：</strong>算法具有0个或多个输入<br>（5）<strong>输出：</strong>算法至少有1个或多个输出</p></blockquote><h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><blockquote><p>（1）<strong>正确性：</strong>满足具体问题的需求<br>（2）<strong>可读性：</strong>便于自己和他人的阅读交流，帮助人更好的理解算法<br>（3）<strong>健壮性：</strong>当输入非法时，能适当做出反应处理，而不是输出莫名其妙的结果<br>（4）<strong>效率与低储存量需求：</strong>尽可能减少算法执行的时间及执行过程中占用的内存 </p></blockquote><h2 id="衡量算法优劣"><a href="#衡量算法优劣" class="headerlink" title="衡量算法优劣"></a>衡量算法优劣</h2><p>一个算法的优劣主要从以下两个方面衡量：</p><p>算法的运行时间。（称为“<strong>时间复杂度</strong>”）<br>运行算法所需的内存空间大小。（称为“<strong>空间复杂度</strong>”）</p><p><strong>好算法的标准</strong>就是：在符合算法本身的要求的基础上，使用算法编写的程序运行的<strong>时间短</strong>，运行过程中占用的<strong>内存空间少</strong>，就可以称这个算法是“好算法”。</p><p>##时间复杂度<br>首先要说的是，时间复杂度的计算并不是计算程序具体运行的时间，而是 <strong>算法执行语句的次数。</strong> 当我们面前有多个算法时，我们可以通过计算时间复杂度，判断出哪一个算法在具体执行时花费时间最多和最少。</p><h3 id="常见的时间复杂度有"><a href="#常见的时间复杂度有" class="headerlink" title="常见的时间复杂度有"></a>常见的时间复杂度有</h3><blockquote><p>常数阶 O(1)     &lt;  对数阶 O(log2 n) &lt;   线性阶 O(n)      &lt;线性对数阶 O(n log2 n) &lt;<br>平方阶 O(n^2) &lt;  立方阶 &lt; O(n^3)  &lt;  k次方阶 O(n^K) &lt; 指数阶 O(2^n)<br>随着n的不断增大，时间复杂度不断增大，算法花费时间越多。</p></blockquote><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><p>①选取相对增长最高的项<br>②最高项系数是都化为1<br>③若是常数的话用 O(1) 表示<br>例如：f（n）=2*n^3+2n+100 , 则 O(n) = n^3。<br>通常我们计算时间复杂度都是计算最坏情况</p><h3 id="时间复杂度的计算"><a href="#时间复杂度的计算" class="headerlink" title="时间复杂度的计算"></a>时间复杂度的计算</h3><p>（1）如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：该算法执行次数是10，是一个常数，用时间复杂度表示是 O(1)。</strong></p><p>（2）当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">   &#123;</span><br><span class="line">        ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：该算法for循环，最外层循环每执行一次，内层循环都要执行n次，执行次数是根据n所决定的，时间复杂度是O(n^2)。</strong></p><p>（3）循环不仅与n有关，还与执行循环所满足的判断条件有关。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n &amp;&amp; arr[i]!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在此循环，如果arr[i]不等于1的话，时间复杂度是O（n）。如果arr[i]等于1的话，则循环不能执行，时间复杂度是0。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。</p><h3 id="计算方法-1"><a href="#计算方法-1" class="headerlink" title="计算方法"></a>计算方法</h3><p>①忽略常数，用O(1)表示<br>②递归算法的空间复杂度 = 递归深度N × 每次递归所要的辅助空间<br>③对于单线程来说，递归有运行时堆栈，求的是递归最深的那一次压栈所耗费的空间的个数，因为递归最深的那一次所耗费的空间足以容纳它所有递归过程。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d %d \n"</span>,a,b,c);</span><br></pre></td></tr></table></figure><p><strong>分析：它的空间复杂度 O(n) = O(1)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n,)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>（n==k)</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> fun(++n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：递归实现，调用fun函数，每次都创建1个变量k。调用n次，空间复杂度 O(n*1) = O(n)。</strong></p><h2 id="拿时间换空间，用空间换时间"><a href="#拿时间换空间，用空间换时间" class="headerlink" title="拿时间换空间，用空间换时间"></a>拿时间换空间，用空间换时间</h2><p>算法的时间复杂度和空间复杂度是可以相互转化的。</p><p>谷歌浏览器相比于其他的浏览器，运行速度要快。是因为它占用了更多的内存空间，以空间换取了时间。</p><p>算法中，例如判断某个年份是否为闰年时，如果想以时间换取空间，算法思路就是：当给定一个年份时，判断该年份是否能被4或者400整除，如果可以，就是闰年。</p><p>如果想以空间换时间的话，判断闰年的思路就是：把所有的年份先判断出来，存储在数组中（年份和数组下标对应），如果是闰年，数组值是1，否则是0；当需要判断某年是否为闰年时，直接看对应的数组值是1还是0，不用计算就可以马上知道。</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构基础</title>
      <link href="/2020/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>给与足够的眼球，所有的Bugs都很容易发现（例如，大量的beta测试，结对开发，所有的问题都能很快的发现和修复</p><p>​                                — Eric S. Raymond, 程序员，开源软件的倡导者, 出自《The Cathedral and the Bazaar》</p></blockquote><h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><p>1) <strong>数据</strong></p><p>数据（Data）是信息的载体，是可以被计算机识别，存储并加工处理的描述客观事物的信息符号的总称。数据不仅仅包括了整形，浮点数等数值类型，还包括了字符甚至声音，视频，图像等非数值的类型。</p><p>2) <strong>数据元素</strong></p><p>数据元素（Data Element）是描述数据的基本单位，也被称为记录。一个数据元素有若干个数据项组成。</p><p>如禽类，鸡鸭都属于禽类的数据元素。</p><p>3) <strong>数据项</strong></p><p>数据项（Data Item）是描述数据的最小单位，其可以分为组合项和原子项：</p><p>   (a) <strong>组合项</strong></p><p>如果数据元素可以再度分割，则每一个独立处理单元就是数据项，数据元素就是数据项的集合。</p><p>   (b) <strong>原子项</strong></p><p>如果数据元素不能再度分割，则每一个独立处理的单元就是原子项。</p><p>如日期2019年4月25日就是一个组合项，其表示日期，但如果单独拿25日这个数据出来观测，这就是一个原子项，因为其不可以再分割。</p><p>4) <strong>数据对象</strong></p><p>数据对象（Data Object）是性质相同的一类数据元素的集合，是数据的一个子集。数据对象可以是有限的，也可以是无限的。</p><p>5) <strong>数据结构</strong></p><p>数据结构（Data Structures）主要是指数据和关系的集合，数据指的是计算机中需要处理的数据，而关系指的是这些数据相关的前后逻辑，这些逻辑与计算机储存的位置无关，其主要包含以下四大逻辑结构。</p><p>##四大逻辑结构（Logic Structure）</p><p>1) <strong>集合结构</strong></p><p>集合结构（Set Structure）中所有数据元素除了同属于一个集合外，并无其他关系。</p><p>如图：</p><p><img src= "/img/loading.gif" data-src="/images/6.png" alt=""></p><p>2) <strong>线性结构</strong></p><p>线性结构（Linear Structure）指的是数据元素之间存在“一对一的关系”</p><p>如图:</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190426/2-1Z426164F1L9.gif" alt="enter image description here"></p><p>3) <strong>树形结构</strong></p><p>树形结构（Tree Structure）指的是数据元素之间存在“一对多”的层次关系。</p><p>如图：</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190426/2-1Z426164P3416.gif" alt="enter image description here"></p><p>4) <strong>图形结构</strong></p><p>图形结构（Graphic Structure，也称：网状结构）指的是数据元素之间存在“多对多的关系”（注：此时的“多对多”中的多表示，至少有一个）</p><p>图示：</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190426/2-1Z4261A50Q16.gif" alt="enter image description here"></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>1) <strong>数据类型</strong></p><p>数据类型（Data Type）是高级程序设计语言中的概念，是数据的取值范围和对数进行操作的总和。数据类型规定了程序中对象的特性。程序中的每一个变量，常量或者表达式都属于一种数据类型。</p><p>2) <strong>抽象数据类型</strong></p><p>抽象数据类型（Abstract Data Type，ADT）只是一个数学模型以及定义在模型上的一组操作。通常是对数据的抽象，定义了数据的取值范围以及对数据操作的集合。</p><p>抽象数据类型的 <strong>特征</strong> 是 <strong>实现与操作分离，从而实现封装。</strong></p><p>例：我们拿《魂斗罗》做比方, 我们给予主角打，跳，移动的基本操作，这些操作就可以看作是抽象数据类型，这一组操作就属于一个模型，这组抽象的数据类型可以在《魂斗罗》这个环境中使用。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法的关系理解</title>
      <link href="/2020/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB%E7%90%86%E8%A7%A3/"/>
      <url>/2020/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法的关系理解"><a href="#数据结构与算法的关系理解" class="headerlink" title="数据结构与算法的关系理解"></a>数据结构与算法的关系理解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于大量数据结构教程中都将数据结构的知识和算法掺杂起来讲，使很多初学者认为数据结构就是在讲算法，这样理解是不准确的。</p><p>数据结构和算法之间完全是两个相互独立的学科，如果非说它们有关系，那也只是互利共赢、“1+1&gt;2”的关系。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="定义理解"><a href="#定义理解" class="headerlink" title="定义理解"></a>定义理解</h3><p><strong>数据结构</strong> 操作的对象是数据元素，即他们有相同的属性（属性也取决于观察者的角度），它们之间的存在的关系会产生不同的结构，数据元素之间的关系+操作构成了数据类型，对已有的数据类型进行抽象就构成了抽象数据类型（ADT），就是封装了值和操作的模型。</p><p><strong>算法</strong> 就是根据输入，设计可行的计算方法并用有限的可执行步骤描述出来（程序），最终得到确定的输出。（从中也可以看出算法的5大特性：输入，输出，有穷性，确定性，可行性）。</p><h3 id="实例理解"><a href="#实例理解" class="headerlink" title="实例理解"></a>实例理解</h3><p>我们也可以从分析问题的角度去理清数据结构和算法之间的关系。通常, 每个问题的解决都经过以下两个步骤：</p><ol><li>分析问题，从问题中提取出有价值的数据，将其存储；</li><li>对存储的数据进行处理，最终得出问题的答案；</li></ol><p>*<em>数据结构 *</em>负责解决第一个问题，即数据的存储问题。通过前面的学习我们知道，针对数据不同的逻辑结构和物理结构，可以选出最优的数据存储结构来存储数据。</p><p>*<em>算法 *</em> 负责剩下的第二个问题。算法，从表面意思来理解，即解决问题的方法。我们知道，评价一个算法的好坏，取决于在解决相同问题的前提下，哪种算法的效率最高，而这里的效率指的就是处理数据、分析数据的能力。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>数据结构用于解决数据存储问题，而算法用于处理和分析数据，它们是完全不同的两类学科。</p><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>数据结构和算法存在“互利共赢、1+1&gt;2”的关系。在解决问题的过程中，数据结构要配合算法选择最优的存储结构来存储数据，而算法也要结合数据存储的特点，用最优的策略来分析并处理数据，由此可以最高效地解决问题。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>看图理解数据结构与算法的关系</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20190213105638785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODkzMzI2,size_16,color_FFFFFF,t_70" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 微信小程序 开发环境配置 详细教程</title>
      <link href="/2020/05/01/VSCode%20%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"/>
      <url>/2020/05/01/VSCode%20%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>配置 VsCode 微信小程序开发环境并不是不用微信官方的 <strong>微信小程序开发者工具</strong> ，而是两者配合适用，可以极大的提高我们的开发效率。</p><h1 id="安装微信小程序开发者工具"><a href="#安装微信小程序开发者工具" class="headerlink" title="安装微信小程序开发者工具"></a>安装微信小程序开发者工具</h1><p>下载地址：<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a></p><p>根据自己的系统下载对应版本，然后一直点击下一步安装即可。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/09/03/winVAS.png" alt=""></p><h1 id="安装VsCode"><a href="#安装VsCode" class="headerlink" title="安装VsCode"></a>安装VsCode</h1><p>下载地址：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a><br>如下图选择适合自己系统的下载之后安装就行</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130195410736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>注意：建议直接安装在Ｃ盘，方便配置，软件大小本身不大！！！</strong></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020013021212998.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>注意：一定要将 添加到PATH 这项打钩！！！</strong></p><h1 id="安装开发必备插件"><a href="#安装开发必备插件" class="headerlink" title="安装开发必备插件"></a>安装开发必备插件</h1><p>1) Easy less  支持使用less语法 ，因为微信小程序开发者工具不支持less ，所以要配合使用</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/09/03/wiukvR.png" alt=""></p><p>2) 微信小程序开发者工具插件，开发必备</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/09/03/wiuEK1.png" alt=""></p><h1 id="配置Less"><a href="#配置Less" class="headerlink" title="配置Less"></a>配置Less</h1><p>快捷键command+逗号打开用户设置，搜less.complie, 点击编辑添加到右边，设置commpress是否开启压缩，sourceMap是否生成.map文件。配置如下图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"less.compile"</span>: &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="string">"outExt"</span>: <span class="string">".wxss"</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="string">"[less]"</span>: &#123;</span><br><span class="line"></span><br><span class="line"><span class="string">"editor.suggest.insertMode"</span>: <span class="string">"replace"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>至此，开始开发你的小程序吧！！！</p>]]></content>
      
      
      <categories>
          
          <category> 开发配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VsCode </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora 最好的Markdown编辑器</title>
      <link href="/2020/04/27/Typora%20Markdown%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2020/04/27/Typora%20Markdown%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBhSaj.md.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBfvqg.md.png" alt="typora-img"></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBfzZQ.md.jpg" alt="img"></p><h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><p>0.9.92</p><p>1.导出PDF时无法加载修复主题。<br>2.修复以一体式样式导出PDF / HTML的问题。<br>3.修复编辑大型数学块时不必要的滚动。</p><p>1.导出PDF时无法加载修复主题。</p><p>0.9.90<br>上线中国镜像：<a href="https://gitee.com/typora-mirror/Typora-Mirror/" target="_blank" rel="noopener">https://gitee.com/typora-mirror/Typora-Mirror/</a></p><p>1.添加ABAP代码语法突出显示。</p><p>2.支持<code>id</code>属性作为链接锚。</p><p>3.升级mermaidjs版本，支持链接样式，实体关系图等。</p><p>4.添加土耳其语支持。</p><p>5.对内置主题的小改进。</p><p>6.在“首选项”面板中添加自定义快捷方式条目。</p><p>7.修复韩文的全局搜索。</p><p>8.解决有关复制/粘贴图像的问题。</p><p>9.解决了打印不会弹出选项对话框的问题。</p><p>10.其他修复错误和改进。</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p>官网下载：<a href="https://www.typora.io" target="_blank" rel="noopener">https://www.typora.io</a></p><p>蓝奏云：<a href="https://ghpym.lanzous.com/b00zng7gd" target="_blank" rel="noopener">https://ghpym.lanzous.com/b00zng7gd</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用教程 </category>
          
          <category> 惊奇软件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Total Uninstall 6.27.0.565 便携破解版</title>
      <link href="/2020/04/26/Total%20Uninstall%206.27.0.565%20%E4%BE%BF%E6%90%BA%E7%A0%B4%E8%A7%A3%E7%89%88/"/>
      <url>/2020/04/26/Total%20Uninstall%206.27.0.565%20%E4%BE%BF%E6%90%BA%E7%A0%B4%E8%A7%A3%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Total Uninstall Pro[完全卸载专业版] 官方中文注册版被成为最受欢迎的卸载程序,能帮你监视软件安装的所有过程，记录下它对系统所做的任何改变，比如：添加的文件、对注 册表和系统文件的修改，并制作成安装前和安装后的快照。卸载软件时，不需要使用卸载程序，直接通过该软件便可将其完全地清除出系统，不留下任何痕迹。从而 保证了系统的清洁。</p><p>Total Uninstall(完全卸载)可以监控软件安装过程，或分析系统中已安装的软件。它可以找出特定软件在系统中留下的每一处痕迹，进行完全的卸载。 Total Uninstall 6 采用了全新的UI设计，包含了原生64bit支持、界面优化、内存使用率下降、程序分析速度比原来版本快5倍等让人惊喜的改进！</p><p>Total Uninstall 的“监控软件安装”功能，可以记录特定时间段特定软件对系统做出的更改，对于便携软件的制作，Total Uninstall 是不可缺少的利器。</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>@果核剥壳 便携制作</p><p>支持win32/64位 破解授权，精简不必要的文件</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UByxhT.md.png" alt=""></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://ghboke.ctfile.com/dir/7369060-27314375-a73ca4/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-27314375-a73ca4/</a></p><p>链接: <a href="https://pan.baidu.com/s/1qZ76xdy" target="_blank" rel="noopener">https://pan.baidu.com/s/1qZ76xdy</a> 密码: rfwf</p><p><strong>温馨提示：</strong>任选一链接下载即可</p>]]></content>
      
      
      <categories>
          
          <category> 实用教程 </category>
          
          <category> 惊奇软件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stardock Fences 3.0.9.11 破解版</title>
      <link href="/2020/04/25/Stardock%20Fences%203.0.9.11%20%E7%A0%B4%E8%A7%A3%E7%89%88/"/>
      <url>/2020/04/25/Stardock%20Fences%203.0.9.11%20%E7%A0%B4%E8%A7%A3%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Stardock Fences 是著名的 Stardock 公司新推出的一款软件，用来分类和组织桌面上的图标。它可以将不同的图标放到不同的半透明“容器”当中，你还可以移动和拉伸这个“容器”。这样将图标分类以后，你的桌面再也不会看起来一团糟了。此外，Fences还提供了一个有趣的功能：双击桌面，隐藏所有图标；再次双击桌面，显示所有图标。</p><h1 id="软件特色"><a href="#软件特色" class="headerlink" title="软件特色"></a>软件特色</h1><p>在高DPI的现代显示器上使用围栏。<br>创建阴影区域以整理桌面。<br>在Windows 10上模糊栅栏后面的壁纸。<br>将围栏卷起来到标题栏，以获得更清洁的桌面。<br>双击桌面以隐藏或显示图标。<br>定义规则以组织桌面图标。<br>在多页围栏之间滑动。<br>从任何文件夹创建一个桌面门户。<br>从围栏内浏览文件夹结构。<br>兼容Windows 10</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><a href="https://img.lguohe.com/uploads/2020/02/20200227212528.jpg" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBsQRe.md.png" alt="img"></a></p><h2 id="破解教程"><a href="#破解教程" class="headerlink" title="破解教程"></a>破解教程</h2><p>本文件是一个exe自解压文件，运行后自动解压，得到安装包和破解补丁。</p><p>安装完成后提示注册或者试用，直接关闭，把补丁复制到软件目录，运行点击破解，然后重启电脑即可。</p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="http://ct.ghpym.com/dir/7369060-37562879-355e79" target="_blank" rel="noopener">http://ct.ghpym.com/dir/7369060-37562879-355e79</a></p><p>链接：<a href="https://pan.baidu.com/s/1eVg3YbrwScRMEpGLP3AfVg" target="_blank" rel="noopener">https://pan.baidu.com/s/1eVg3YbrwScRMEpGLP3AfVg</a> 提取码：4zpq</p><p><a href="https://www.lanzous.com/b00z9m2ze" target="_blank" rel="noopener">https://www.lanzous.com/b00z9m2ze</a></p><p>温馨提示：任选一个链接点击下载即可。</p>]]></content>
      
      
      <categories>
          
          <category> 实用教程 </category>
          
          <category> 惊奇软件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Snipaste(截图&amp;贴图)v2.4 Beta 绿色版</title>
      <link href="/2020/04/24/Snipaste(%E6%88%AA%E5%9B%BE&amp;%E8%B4%B4%E5%9B%BE)v2.4%20Beta%20%E7%BB%BF%E8%89%B2%E7%89%88/"/>
      <url>/2020/04/24/Snipaste(%E6%88%AA%E5%9B%BE&amp;%E8%B4%B4%E5%9B%BE)v2.4%20Beta%20%E7%BB%BF%E8%89%B2%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Snipaste 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上！下载并打开 Snipaste，按下 <code>F1</code> 来开始截图，再按 <code>F3</code>，截图就在桌面置顶显示了。就这么简单！</p><p>你还可以将剪贴板里的文字或者颜色信息转化为图片窗口，并且将它们进行缩放、旋转、翻转、设为半透明，甚至让鼠标能穿透它们！如果你是程序员、设计师，或者是大部分工作时间都在电脑前，贴图功能将改变你的工作方式、提升工作效率。</p><p>Snipaste 使用很简单，但同时也有一些较高级的用法可以进一步提升你的工作效率。感兴趣的话，请抽空读一读<a href="https://docs.snipaste.com/#/zh-cn/" target="_blank" rel="noopener">用户手册</a>。</p><p>Snipaste 是免费软件，它也很安全，没有广告、不会扫描你的硬盘、更不会上传用户数据，它只做它应该做的事。</p><p><a href="https://img.lguohe.com/uploads/2019/07/N3QEb3VA.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/07/N3QEb3VA.png" alt="img"></a></p><h2 id="软件特色"><a href="#软件特色" class="headerlink" title="软件特色"></a>软件特色</h2><h3 id="强大的截图"><a href="#强大的截图" class="headerlink" title="强大的截图"></a>强大的截图</h3><p><a href="https://img.lguohe.com/uploads/2019/07/N3038l46.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/07/N3038l46.png" alt="img"></a></p><ul><li>自动检测界面元素区域</li><li>像素级的鼠标移动控制、截图范围控制</li><li>取色器 (试试 <code>F1</code>, <code>C</code>, <code>F3</code>)</li><li><strong>历史记录回放</strong> (<code>,</code>/<code>.</code>)</li><li>支持多屏</li><li>支持高分屏</li></ul><h3 id="把图片作为窗口置顶显示"><a href="#把图片作为窗口置顶显示" class="headerlink" title="把图片作为窗口置顶显示"></a>把图片作为窗口置顶显示</h3><p><a href="https://img.lguohe.com/uploads/2019/07/P9A3LpoY.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/07/P9A3LpoY.png" alt="img"></a></p><ul><li>支持将剪贴板中的以下内容转为图片<ul><li>图像</li><li>纯文本</li><li>HTML 文本</li><li>颜色信息</li><li>图像文件：PNG, JPG, BMP, ICO, <strong>GIF</strong> 等</li></ul></li><li>图片窗口支持的操作<ul><li>缩放 (<code>鼠标滚轮</code> 或者 <code>+</code>/<code>-</code>)<br>对于 GIF 图片则是加速/减速</li><li>旋转 (<code>1</code>/<code>2</code>)<br>对于 GIF 图片则是 上一帧/下一帧</li><li>镜像翻转 (<code>3</code>/<code>4</code>)</li><li>设置透明度 (<code>Ctrl</code> + <code>鼠标滚轮</code> 或者 <code>Ctrl</code>+ <code>+</code>/<code>-</code>)</li><li>鼠标穿透 (<code>X</code>, 取消则按 <code>F4</code>)</li><li>缩略图 (<code>Shift</code> + <code>双击</code>)</li><li>图像标注 (<code>空格键</code>)</li><li>隐藏 (<code>左键双击</code>)</li><li>…</li></ul></li><li>取色 (<code>Alt</code>)</li><li>文件拖放</li><li><strong>贴图分组</strong></li><li><strong>自动备份、恢复</strong></li></ul><h3 id="方便地标注图像"><a href="#方便地标注图像" class="headerlink" title="方便地标注图像"></a>方便地标注图像</h3><p><a href="https://img.lguohe.com/uploads/2019/07/vu1nkxdD.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/07/vu1nkxdD.png" alt="img"></a></p><ul><li>丰富的画图工具<ul><li>矩形</li><li>椭圆</li><li>线条</li><li>箭头</li><li>铅笔</li><li>马克笔</li><li>文字</li></ul></li><li>高级标注工具<ul><li>马赛克</li><li>高斯模糊</li><li>橡皮擦</li></ul></li><li>撤销、重做</li></ul><h3 id="自定义设置"><a href="#自定义设置" class="headerlink" title="自定义设置"></a>自定义设置</h3><p><a href="https://img.lguohe.com/uploads/2019/07/TNqoS229.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2019/07/TNqoS229.png" alt="img"></a></p><p>主题色、界面字体、通知栏图标等<br>快捷键<br>丰富的功能性选项</p><h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><p>修复无法以管理员权限开机启动<br>修复中文字体描边 #1475<br>[Mac] 修复首选项窗口在深色模式下的样式错误<br>[Mac] 修复菜单栏图标的菜单点击无效的问题 #1467</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://ghboke.ctfile.com/dir/7369060-34701258-d02fe8/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-34701258-d02fe8/</a></p><p>链接：<a href="https://pan.baidu.com/s/14EVfjqFNLfF8WJptxcK0Ug" target="_blank" rel="noopener">https://pan.baidu.com/s/14EVfjqFNLfF8WJptxcK0Ug</a>    提取码：4ngr</p><p><a href="https://www.lanzous.com/b00zdqjod" target="_blank" rel="noopener">https://www.lanzous.com/b00zdqjod</a></p><p><strong>温馨提示：</strong> 任选一链接下载即可</p>]]></content>
      
      
      <categories>
          
          <category> 实用教程 </category>
          
          <category> 惊奇软件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PotPlayer(网络播放器) v1.7.21264 绿色版</title>
      <link href="/2020/04/23/PotPlayer(%E7%BD%91%E7%BB%9C%E6%92%AD%E6%94%BE%E5%99%A8)%20v1.7.21264%20%E7%BB%BF%E8%89%B2%E7%89%88/"/>
      <url>/2020/04/23/PotPlayer(%E7%BD%91%E7%BB%9C%E6%92%AD%E6%94%BE%E5%99%A8)%20v1.7.21264%20%E7%BB%BF%E8%89%B2%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        PotPlayer 是 KMPlayer 的原制作者姜龙喜先生（韩国）进入 Daum 公司后的新一代网络播放器。PotPlayer 的优势在于强大的内置解码器；而 KMPlayer 的优势在于强大的定制能力和个性化功能。PotPlayer 使用 VC++ 编写， KMPlayer 为 Delphi 编写。PotPlayer 是 Daum 公司的一款网络播放器，有自己的独立著作权，并非由姜龙喜先生原创，目前由 KMPlayer 的原始作者姜龙喜进行后续开发。目前(1428以后版本)的 KMPlayer 由 PandoraTV 团队负责集体开发。应 PandoraTV 的要求，PotPlayer 不会加入在 KMPlayer 中一些受欢迎功能，但作者答应加入一些近似的功能。</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>@闻雷 @果核剥壳</p><p>绿色便携制作</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UB0T5F.md.png" alt=""></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p>新增58个皮肤，需要的请自行下载皮肤包，解压到程序skin目录即可</p><p><a href="https://www.lanzous.com/b00zausmb" target="_blank" rel="noopener">https://www.lanzous.com/b00zausmb</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用教程 </category>
          
          <category> 惊奇软件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MindMaster(亿图思维导图 ) Pro 破解版</title>
      <link href="/2020/04/23/MindMaster(%E4%BA%BF%E5%9B%BE%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%20)%20Pro%20%E7%A0%B4%E8%A7%A3%E7%89%88/"/>
      <url>/2020/04/23/MindMaster(%E4%BA%BF%E5%9B%BE%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%20)%20Pro%20%E7%A0%B4%E8%A7%A3%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        MindMaster 自带幻灯片展示功能，不需要借助其他的工具，就可以进行幻灯片展示。同时支持一键将思维导图拆分成多个幻灯片页面，可以在全屏模式下遍历思维导图的主题或者分支，当思维导图内容较多时，也可以很好的将每个细节展示清楚，除此之外，MindMaster 专业版还可以将思维导图幻灯片导出为 PPT 格式，在 Office PowerPoint 中，进行分页展示和打印。</p><p>MindMaster 专业版搭载亿图云服务，提供多人协作办公的功能，团队办公中轻松实现文件共享、编辑，1G 云空间让文件保存和分享更方便自由。通过添加、管理自定义的标签，在进行任务管理的人员分配时，还可以更高效地设置任务信息。MindMaster 专业版还可以从思维导图一键生产甘特图。在思维导图中添加的任务信息会一一对应到甘特图中，思维导图和甘特可以同步编辑、更新。绘制好的甘特图，还可以导出至 PDF 格式，对于进行日程计划、安排、任务管理等，都非常的实用。</p><p>MindMaster 专业版在免费版的基础上，增加了更多主题样式，通过彩虹色、单色、对称色、交替色四种配色，让思维导图色彩更丰富，同时还可以一键切换漂亮的手绘模式的思维导图，除此之外，MindMaster 专业版还提供了丰富的高清且纯矢量剪贴画，适用于商业、教育、人物、自然、科技等各个领域。</p><p>MindMaster 专业版可以将思维导图导出为 Word、PPT、Excel、PDF 等文件格式，无需使用MindMaster 软件就可以进行再次编辑、修改。同时 MindMaster 专业版还支持导出更高 DPI 图片格式，以及 HTML 和 SVG 格式。</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>@果核剥壳 绿色破解制作</p><p>破解后无需屏蔽程序联网</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UDbK6s.md.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UDbMXn.md.png" alt=""></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://www.lanzous.com/b00zda7wd" target="_blank" rel="noopener">https://www.lanzous.com/b00zda7wd</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用教程 </category>
          
          <category> 惊奇软件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Office 2016 2020.6.12 绿色精简版/安装版</title>
      <link href="/2020/04/21/Office%202016%202020.6.12%20%E7%BB%BF%E8%89%B2%E7%B2%BE%E7%AE%80%E7%89%88%E5%AE%89%E8%A3%85%E7%89%88/"/>
      <url>/2020/04/21/Office%202016%202020.6.12%20%E7%BB%BF%E8%89%B2%E7%B2%BE%E7%AE%80%E7%89%88%E5%AE%89%E8%A3%85%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Office 2016 For Windows 四合一Office 2016是微软的一个庞大的办公软件集合，其中包括了Word、Excel、PowerPoint、Access等组件和服务。</p><p>Office2016支持Windows 7、Windows 8和Windows 10 PC、笔记本和平板电脑。用户必须首先卸载Office 2013。两个版本无法同时安装。本站提供Office2016四合一激活破解版下载。</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>采用32位版本制作，关键更新及安全更新至2020年5月，其它改进；</p><p>保留Word、Excel、Ppt、Access 四大组件 (含VBA)，其它全部删除；</p><p>支持打开PDF文档、支持联机模板、支持规划求解、分析等Excel加载项;</p><p>1、自选三合一或四合一安装（access默认取消）<br>2、增加英文语法检查（中文语法检查功能太大没添加!）<br>3、增加 wps 文件关联（不需要可删除data\wps.dat）<br>3、注册表补充些优化项<br>4、已集成到最新2020.5月最新补丁<br>5、重点：鉴于巨硬最新补丁限制XP使用，针对XP新和谐</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2018/03/Office4in1.jpg" alt=""></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://ghboke.ctfile.com/dir/7369060-27575577-1b4639/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-27575577-1b4639/</a></p><p>链接：<a href="https://pan.baidu.com/s/1rLM0aJR8fv4KPBc8lrMYuA" target="_blank" rel="noopener">https://pan.baidu.com/s/1rLM0aJR8fv4KPBc8lrMYuA</a> 提取码：hv2d</p><p><strong>温馨提示：</strong>任选一链接下载即可</p>]]></content>
      
      
      <categories>
          
          <category> 实用教程 </category>
          
          <category> 惊奇软件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Motrix(全能下载软件)</title>
      <link href="/2020/04/21/Motrix(%E5%85%A8%E8%83%BD%E4%B8%8B%E8%BD%BD%E8%BD%AF%E4%BB%B6)v1.5.15%20%E7%BB%BF%E8%89%B2%E7%89%88/"/>
      <url>/2020/04/21/Motrix(%E5%85%A8%E8%83%BD%E4%B8%8B%E8%BD%BD%E8%BD%AF%E4%BB%B6)v1.5.15%20%E7%BB%BF%E8%89%B2%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Motrix是一款基于electron开发的跨平台下载软件，核心下载服务还是由aria2c支持，是一款精品的下载工具，支持支持下载 HTTP、FTP、BT、磁力链、百度网盘等资源，是一款不可多得的高颜值下载软件。</p><h1 id="软件特色"><a href="#软件特色" class="headerlink" title="软件特色"></a>软件特色</h1><p>简洁明了的图形操作界面</p><p>支持BT和磁力链任务</p><p>支持下载百度云盘资源</p><p>最高支持 10 个任务同时下载</p><p>单任务最高支持 64 线程下载</p><p>模拟用户代理UA</p><p>下载完成后通知</p><p>支持触控栏快捷健(Mac 专享)</p><p>常驻系统托盘，操作更加便捷</p><p>移除任务时可同时删除相关文件</p><p>国际化(可选择简体中文或英文界面)</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBrJ4U.md.png" alt=""></p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p>官网下载：<a href="https://motrix.app/zh-CN/" target="_blank" rel="noopener">https://motrix.app/zh-CN/</a></p><p>绿色版：<a href="https://ghboke.ctfile.com/dir/7369060-33488776-d50dcc/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-33488776-d50dcc/</a></p><p><strong>温馨提示：</strong>绿色版为exe自解压包，解压即可使用</p>]]></content>
      
      
      <categories>
          
          <category> 实用教程 </category>
          
          <category> 惊奇软件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bandizip(跨平台解压缩软件) v7.09 企业激活版</title>
      <link href="/2020/04/20/Bandizip(%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%A7%A3%E5%8E%8B%E7%BC%A9%E8%BD%AF%E4%BB%B6)%20v7.09%20%E4%BC%81%E4%B8%9A%E6%BF%80%E6%B4%BB%E7%89%88/"/>
      <url>/2020/04/20/Bandizip(%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%A7%A3%E5%8E%8B%E7%BC%A9%E8%BD%AF%E4%BB%B6)%20v7.09%20%E4%BC%81%E4%B8%9A%E6%BF%80%E6%B4%BB%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        虽然 7-Zip 是开源免费压缩工具中的佼佼者，但用得不是很顺手，今天试了下推荐的 Bandizip 却出人意料的好用！Bandizip 是一款来自韩国的免费优秀的文件压缩/解压缩软件，支持 Win 与 Mac，操作方式与 WinRAR 相似，支持压缩和解压 rar、zip、7z 等众多主流格式…</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li>支持操作系统: Windows Vista/7/8/10 (x86/x64/ARM64)</li><li>许可类型：免费软件(EULA)</li><li>全能的压缩/解压/浏览/编辑软件</li><li>可提取30多种格式，包括RAR/RAR5/7Z/ZIP等</li><li>包含密码压缩和分卷压缩功能</li><li>支持多核高速压缩</li></ul><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><ul><li>支持的格式: ZIP, 7Z(lzma2), ZIPX(xz), EXE(sfx), TAR, TGZ, LZH(lh7), ISO(joliet), GZ, XZ</li><li>ZIP文件修改（添加/删除/重命名）</li><li>支持多核并行，压缩速度可提升至多达6倍</li><li>加密压缩</li><li>支持AES256加密算法</li><li>支持4GB 以上大小的文件压缩</li><li>对ZIP格式支持Unicode或MBCS文件名</li><li>对ZIP/7z格式可进行分卷压缩</li></ul><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><ul><li>支持的格式: 7Z, ACE, AES, ALZ, ARJ, BH, BIN, BZ, BZ2, CAB, Compound(MSI), EGG, GZ,  IMG, ISO, ISZ, LHA, LZ, LZH, LZMA, PMA, RAR, RAR5, SFX(EXE), TAR, TBZ,  TBZ2, TGZ, TLZ, TXZ, UDF, WIM, XPI, XZ, Z, ZIP, ZIPX, ZPAQ</li><li>轻松查看压缩包内文件</li><li>可只解压选定文件，支持拖拽解压</li><li>可对ZIP和RAR格式添加注释</li><li>一步解压TGZ/TBZ格式的文件</li></ul><h2 id="功能多样"><a href="#功能多样" class="headerlink" title="功能多样"></a>功能多样</h2><ul><li>测试文件完整性以确定压缩包是否损坏</li><li>支持修改代码页改</li><li>可集成至资源管理器右键菜单</li></ul><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/16/UBIaFJ.md.png" alt=""></p><h1 id="破解教程"><a href="#破解教程" class="headerlink" title="破解教程"></a>破解教程</h1><p>7系列版本，安装后，下载破解补丁，破解后，使用激活码如下激活码</p><p>20380808-ENT000002-0E34A52561-166371E0</p><p>20380808-PRO0BFAEBFDAE23C425E-173E2DF1</p><p>邮箱地址：可任意填写，即随意填个假冒邮箱格式</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><strong>官网下载：</strong></p><p>系列版本：【原生无广告】</p><p>安装版：<a href="https://dl.bandisoft.com/bandizip/BANDIZIP-SETUP.EXE" target="_blank" rel="noopener">https://dl.bandisoft.com/bandizip/BANDIZIP-SETUP.EXE</a></p><p>32位便携版：<a href="https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-32BIT.ZIP" target="_blank" rel="noopener">https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-32BIT.ZIP</a></p><p>64位便携版：<a href="https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-64BIT.ZIP" target="_blank" rel="noopener">https://dl.bandisoft.com/bandizip/BANDIZIP-PORTABLE-GL-64BIT.ZIP</a></p><p>7系列版本：</p><p>安装版：<a href="http://dl.bandisoft.com/bandizip.std/BANDIZIP-SETUP-STD-ALL.EXE" target="_blank" rel="noopener">http://dl.bandisoft.com/bandizip.std/BANDIZIP-SETUP-STD-ALL.EXE</a></p><p><strong>破解版下载：</strong></p><p><a href="https://ghpym.lanzous.com/b00zdekyh" target="_blank" rel="noopener">https://ghpym.lanzous.com/b00zdekyh</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用教程 </category>
          
          <category> 惊奇软件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bandicam v4.6.1.1688 便携特别版</title>
      <link href="/2020/04/20/Bandicam%20v4.6.1.1688%20%E4%BE%BF%E6%90%BA%E7%89%B9%E5%88%AB%E7%89%88/"/>
      <url>/2020/04/20/Bandicam%20v4.6.1.1688%20%E4%BE%BF%E6%90%BA%E7%89%B9%E5%88%AB%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>​        Bandicam，游戏录制神器，视频录制利器，高清频录制专家，号称世界三大视频录制神器之一！Bandicam是一款由韩国开发的高清游戏及视频录制的电脑工具。它录制的视频文件不仅体积小，而且画质相当清晰，支持H.264预制高清，以较高的压缩率可录制超过分辨率高达2560×1600高画质视频（1080p全高清视频），录制的同时还可以添加个性化 LOGO到视频中，Bandicam支持bmp、png 、jpeg等格式截图。</p><p>专业高清录屏软件Bandicam现已更新至 4.x，4.0版本界面更好看，功能更多</p><p>Bandicam游戏机可以记录程序/ OpenGL和DirectX Fraps（Fraps Alternative，Better thanFraps®）</p><p>您可以在不停机的情况下录制超过24小时（全自动录音功能可以使用）</p><p>您可以将录制的文件上传到YouTube而不进行转换（可以制作720p / 1080p全高清视频）</p><p>录制的文件大小远小于其他软件。</p><p>您可以录制高达3840 x 2160像素分辨率的4K超高清视频</p><p>您将会遇到比其他捕获软件游戏少得多的滞后（使用更低的CPU / GPU / HDD）</p><h1 id="修改说明"><a href="#修改说明" class="headerlink" title="修改说明"></a>修改说明</h1><p>@果核剥壳</p><p>便携制作</p><p>启动即为破解版，无需屏蔽联网</p><h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1><p><a href="https://img.lguohe.com/uploads/2017/07/Bandicamjt4.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://img.lguohe.com/uploads/2017/07/Bandicamjt4.png" alt="img"></a></p><h1 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h1><p>andicam现在支持AMD VCE / VCN HEVC编码器。<br>更新了英特尔快速同步视频编码器。<br>改进了HEVC编码器的稳定性。<br>改进了Vulkan挂钩兼容性。<br>错误修复<br>在屏幕录制模式下，橡皮擦功能的撤消/重做无法正常工作。<br>多个命令行参数无法正常工作。<br>例如）bdcam.exe / nosplash / record<br>其他小错误已得到修复。</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://ghboke.ctfile.com/dir/7369060-23599787-7e8657/" target="_blank" rel="noopener">https://ghboke.ctfile.com/dir/7369060-23599787-7e8657/</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用教程 </category>
          
          <category> 惊奇软件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>彻底删除烦人的Linux系统引导项文件</title>
      <link href="/2020/04/19/%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E7%83%A6%E4%BA%BA%E7%9A%84Linux%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E9%A1%B9%E6%96%87%E4%BB%B6/"/>
      <url>/2020/04/19/%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E7%83%A6%E4%BA%BA%E7%9A%84Linux%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E9%A1%B9%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在使用win10 + deepin的过程中，由于 deepin 系统安装失败/重装时，需要删除掉deepin系统引项。</p><p>常用的做法是在win10安装<strong>EasyUEFI</strong>,使用其中的 <strong>管理EFI启动项</strong> 来对deepin启动项进行删除，可能的原因是之前无意中将 deepin 的启动项文件损坏了，结果删除时总是显示无效的文件。但是明明deepin启动项仍然存在于BIOS启动项选项里面。意思就是它明明存在，但是你就是删不掉。</p><p>如果你在 win10安装<strong>EasyUEFI</strong> 删除引导无效，请看以下教程。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>使用快捷键 <code>win+x</code>，打开 <code>Windows PowerShell(管理员)(A)</code>，依次输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">diskpart         #打开diskpart</span><br><span class="line">list disk        #列出系统中拥有的磁盘，我笔记本上有两块磁盘，记得当时ubuntu启动项文件安装到了SSD所在的磁盘0中</span><br><span class="line">select disk 0    #选择EFI引导分区所在的磁盘，请根据实际情况选择</span><br><span class="line">list partition   #列出所选磁盘拥有的分区</span><br><span class="line">select partition 1    #选择EFI引导分区，类型为系统的分区，就是EFI引导分区</span><br><span class="line">assign letter&#x3D;p:      #为所选分区分配盘符，请分配空闲盘符</span><br><span class="line">exit                 # 退出</span><br><span class="line">taskkill &#x2F;im explorer.exe &#x2F;f   #关闭explorer</span><br><span class="line">explorer.exe     #再以管理员身份打开explorer</span><br></pre></td></tr></table></figure><p>此时，在<strong>我的电脑</strong>中会发现，新增加了一个磁盘分区p，但是直接双击打开仍然打不开，于是直接在刚才的PowerShell命令行中进行操作了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p:  #转到p磁盘</span><br><span class="line">ls  #查看p磁盘下的文件信息，正常的话会看见一个名为EFI的文件夹，回想上面在EasyUEFI中看到的ubuntu启动项的文件路径，ubuntu启动项文件就在这个EFI文件夹下面</span><br><span class="line">cd EFI  #进入EFI文件夹</span><br><span class="line">ls       #此时会看到一个名为ubuntu的文件夹，终于找到它了！同时还会看到一个名为Microsoft的文件夹，它应该就是win10系统的启动项文件</span><br><span class="line">cd ubuntu    #进入ubuntu文件夹</span><br><span class="line">ls       #查看有哪些启动项文件，这里会看见EasyUEFI&#x2F;文件路径中提到的shimx64.efi文件</span><br><span class="line">cd ..  #跳回EFI文件夹</span><br><span class="line">del ubuntu  #再将ubuntu文件夹整个删掉，斩草除根！</span><br><span class="line">ls      #此时会发现已经没有ubuntu文件夹了！</span><br></pre></td></tr></table></figure><p>自此，清理 ubuntu 启动项文件的工作就结束了,不用管刚才分配的 <strong>p盘符</strong>，关掉 PowerShell，关掉笔记本重启，重启后之前分配的p盘符会自动移除。</p><p><strong><font color=red>温馨提示：</font></strong>其他 Linux 系统只需找到对应名字的引导文件删除即可。</p>]]></content>
      
      
      <categories>
          
          <category> L i n u x </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux引导 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统分区方案</title>
      <link href="/2020/04/18/Linux%E7%B3%BB%E7%BB%9F%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88/"/>
      <url>/2020/04/18/Linux%E7%B3%BB%E7%BB%9F%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="简单分区方案"><a href="#简单分区方案" class="headerlink" title="简单分区方案"></a>简单分区方案</h2><p>实际上，很多时候我们只需要分两个区：<code>/</code>和交换分区，日常使用基本不会有任何影响，甚至于交换分区对于现在的电脑来说都不是必要的，我们完全可以只分配一个根分区。linux只需要一个/根分区就可以正常运行。</p><h2 id="常用分区方案"><a href="#常用分区方案" class="headerlink" title="常用分区方案"></a>常用分区方案</h2><p>以使用 <strong>100G 空间</strong> 安装 linux 为例，各目录含义，请参考文章结尾附录。</p><table><thead><tr><th align="center">目录类型</th><th align="center">挂载点</th><th align="center">分区格式</th><th align="center">大小</th></tr></thead><tbody><tr><td align="center">根目录</td><td align="center">/</td><td align="center">ext4</td><td align="center">20-40G</td></tr><tr><td align="center">家目录</td><td align="center">/home</td><td align="center">ext4</td><td align="center">剩余所有空间</td></tr><tr><td align="center">交换分区</td><td align="center">swap</td><td align="center">无</td><td align="center">2G</td></tr></tbody></table><p><strong><font color=red>注意：</font></strong> 交换分区 无挂载点 分区格式选择交换分区（swap） 最大不建议超过真实内存大小，除非内存小于2G，你的内存大于4G，推荐2G即可，没必要有些人推荐的与内存相当。</p><h2 id="DIY分区方案"><a href="#DIY分区方案" class="headerlink" title="DIY分区方案"></a>DIY分区方案</h2><p>更高级的分区，我们就要了解一下自己电脑的使用场景。</p><p>linux的整体目录就是一个树状结构，根据文章结尾的附录一，我们会知道/分区下的各个目录存放的内容都是不一样的，所以他们的内容变化速度也会不一样。</p><p>了解了这些，试想一个场景，如果我们只分配一个/分区，内容增加速度快的目录，比如个人桌面系统的/home，服务器的/var目录可能会迅速占领大部分的存储容量，以至于当存储容量用尽时出现电脑无法开机的现象。</p><p>为了避免出现这样的情形，我们可以给电脑分区，然后将分区‘挂载’到根分区的指定目录，限制目录的大小，同时保护一些重要目录，比如/boot，这样，即便目录某个目录扩张很快，最终也只会占用我们分配的大小，不会影响到电脑的正常运行。所以第二种方法里，我们把/boot和/home单独分了出来，避免/分区的内容扩张影响到系统启动，同时，分配/home分区可以在电脑系统崩溃，重装系统时避免个人文件丢失，直接将分区挂载上去，个人的数据就不会丢失。</p><p>但是有的时候，我们要安装linux是给服务器安装的，这时，/home就不应该分配这么多空间了，因为对于个人电脑桌面系统，我们可能需要安装很多的软件、文件和视频音乐等，会导致/home目录变得十分臃肿，而其他目录相对来说比较小。不过对于服务器来说，更占用存储的地方可能集中在了/var目录，比如日志文件，比如web服务器的根目录，一般都在/var目录中，这时，我们就应该给/var目录分配更多的空间，保证服务器的正常运行。当然，如果你的服务器目录结构是自己组织的，你就要按照你自己电脑的情况来分析你的电脑该如何来选择分区。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><table><thead><tr><th align="center">目录名</th><th align="center">简介</th></tr></thead><tbody><tr><td align="center">swap</td><td align="center">类似于windows的虚拟内存文件</td></tr><tr><td align="center">/</td><td align="center">根目录，根目录下最好只有目录，文件放在目录下，不要放在根目录中。</td></tr><tr><td align="center">/boot</td><td align="center">包括操作系统的内核和启动过程需要用的文件</td></tr><tr><td align="center">/root</td><td align="center">超级管理员的家目录</td></tr><tr><td align="center">/home</td><td align="center">家目录，用来存放用户文件</td></tr><tr><td align="center">/etc</td><td align="center">大部分的配置文件默认都放在这里</td></tr><tr><td align="center">/dev</td><td align="center">Linux系统中，所有的硬件都以文件的形式放在这个目录中</td></tr><tr><td align="center">/lost+found</td><td align="center">突然停电或者非正常关机，存放临时文件</td></tr><tr><td align="center">/sbin</td><td align="center">管理员才能运行的一些程序</td></tr><tr><td align="center">/opt</td><td align="center">存储第三方软件的目录</td></tr><tr><td align="center">/proc</td><td align="center">存储进程相关的信息，用于方便的访问进程信息，伪文件系统，所有的内容都存储在内存中</td></tr><tr><td align="center">/mnt</td><td align="center">一般我们将手动挂载的分区放在这里（例如新加一款硬盘，可以挂载在这里）</td></tr><tr><td align="center">/media</td><td align="center">系统自动挂载的分区放在这里</td></tr><tr><td align="center">/lib</td><td align="center">用于存放库文件</td></tr><tr><td align="center">/usr</td><td align="center"></td></tr><tr><td align="center">/usr/lib</td><td align="center">同/lib</td></tr><tr><td align="center">/usr/sbin</td><td align="center">同/sbin</td></tr><tr><td align="center">/usr/local/bin</td><td align="center">系统实用程序</td></tr><tr><td align="center">/usr/local/sbin</td><td align="center">同/sbin</td></tr><tr><td align="center">/usr/local/lib</td><td align="center">同/lib</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> L i n u x </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux分区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux/deepin/uos 系统安装后无法使用无线网问题解决</title>
      <link href="/2020/04/17/Linux(deepin-uos)%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E6%97%A0%E7%BA%BF%E7%BD%91%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/04/17/Linux(deepin-uos)%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E6%97%A0%E7%BA%BF%E7%BD%91%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人笔记本电脑型号已测试，联想Y7000，安装deepin/uos后，100%遇到此问题。</p><h2 id="问题检查"><a href="#问题检查" class="headerlink" title="问题检查"></a>问题检查</h2><p><strong>驱动问题</strong></p><p>如果通过命令<code>ifconfig</code>没能发现类似<code>wlp7s0</code>的无线网络，可以判断是这个问题。</p><p><strong>无线网卡被hard blocked的问题</strong></p><p>运行命令<code>rfkill list all</code>，出现如下结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:ideapad_wlan: Wireless LAN </span><br><span class="line">Soft blocked: no </span><br><span class="line">Hard blocked:yes </span><br><span class="line">1:ideapad_bluetooth: Bluetooth </span><br><span class="line">Soft blocked: no </span><br><span class="line">Hard blocked: yes </span><br><span class="line">2:phy0: Wireless LAN </span><br><span class="line">Soft blocked: no </span><br><span class="line">Hard blocked:no </span><br><span class="line">3:hci0: Bluetooth </span><br><span class="line">Soft blocked: yes </span><br><span class="line">Hard blocked: no</span><br></pre></td></tr></table></figure><p>可以看到，优先级前的ideapad_wlan的Hard blocked 默认为yes，即deepin默认关闭了硬件wifi开关，而联想拯救者Y7000的wifi只有软件开关，没有硬件开关的启动，所以引起了wifi无法开启的问题。</p><p><strong>网卡驱动的电源管理问题</strong></p><p>使用命令<code>dmesg</code>查看日志，如果出现</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/16/Y68IZ8.png" alt=""></p><p>那很可能就是这个问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>驱动问题解决方案：</strong></p><p>如果确认是驱动问题，则可以尝试通过重装驱动解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install --reinstall firmware-realtek</span><br></pre></td></tr></table></figure><p><strong>无线网卡被hard blocked解决方案：</strong></p><p>禁用 *<em>ideapad_laptop *</em>驱动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;blacklist ideapad_laptop&quot; | sudo tee &#x2F;etc&#x2F;modprobe.d&#x2F;backlist-ideapad.conf</span><br></pre></td></tr></table></figure><p><strong>网卡驱动的电源管理问题解决方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;options r8822be aspm&#x3D;0&quot; | sudo tee &#x2F;etc&#x2F;modprobe.d&#x2F;r8822be.conf</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> L i n u x </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Qt 项目实战(一)之文本编辑器</title>
      <link href="/2020/04/16/C++%20Qt%20%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98(%E4%B8%80)%E4%B9%8B%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2020/04/16/C++%20Qt%20%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98(%E4%B8%80)%E4%B9%8B%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="文本编辑器例图"><a href="#文本编辑器例图" class="headerlink" title="文本编辑器例图"></a>文本编辑器例图</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/13/d9KgiT.md.png" alt=""></p><h2 id="项目开发环境"><a href="#项目开发环境" class="headerlink" title="项目开发环境"></a>项目开发环境</h2><p><strong>系统版本：</strong>windows10<br><strong>Q T 版本：</strong> 5.9.9<br><strong>开发语言：</strong>C++</p><h2 id="已实现功能"><a href="#已实现功能" class="headerlink" title="已实现功能"></a>已实现功能</h2><ol><li><strong>文件操作：</strong>新建，打开，保存，另存为，打印，退出</li><li><strong>编辑操作：</strong>复制，粘贴，剪切，查找，替换，撤销，恢复</li><li><strong>文字编辑：</strong>字体，字号，加粗，倾斜，颜色</li><li><strong>个性化功能：</strong>背景色修改 (软件默认背景色为护眼绿)，背景图修改</li><li><strong>快捷键操作：</strong>大部分功能已匹配相关的快捷键操作</li></ol><h2 id="未完善功能"><a href="#未完善功能" class="headerlink" title="未完善功能"></a>未完善功能</h2><ol><li><p>查找和替换操作，仅支持从当前光标位置向后查找</p></li><li><p>文字居中，对齐等功能尚未实现</p></li><li><p>无法将图片插入文本进行操作</p><p>……</p></li></ol><h2 id="未解决BUG"><a href="#未解决BUG" class="headerlink" title="未解决BUG"></a>未解决BUG</h2><ol><li><p>打开操作BUG：从 文件 — 右键打开方式 — 选择本软件 — 打开后不显示文件内容</p></li><li><p>个性化功能BUG：背景图修改后，仅当前状态有效，退出软件重新打开后，背景图失效</p></li><li><p>可能有其它未知BUG，尚未发现</p><p>……</p></li></ol><h2 id="部分源码展示"><a href="#部分源码展示" class="headerlink" title="部分源码展示"></a>部分源码展示</h2><p><strong>mainwindow.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCloseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QImage&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMenu&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QAction&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QComboBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFontComboBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QToolButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextCharFormat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QAction&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QColorDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QColor&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MainWindow(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~MainWindow();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">creatMenus</span><span class="params">()</span></span>;      <span class="comment">//创建菜单栏</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">creatToolbars</span><span class="params">()</span></span>;   <span class="comment">//创建工具栏</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">creatActions</span><span class="params">()</span></span>;    <span class="comment">//创建动作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowNewFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowOpenFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadFile</span><span class="params">(QString &amp; filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">maybeSave</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">saveFile</span><span class="params">(QString &amp; filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">saveAs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPrintText</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeFormat</span><span class="params">(QTextCharFormat format)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowFontComBox</span><span class="params">(QString comboStr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowSizeSpinBox</span><span class="params">(QString spinValue)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowBoldBtn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowItalicBtn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowUnderlineBtn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowColorBtn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowCurrentFormatChanged</span><span class="params">(<span class="keyword">const</span> QTextCharFormat &amp;fmt)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowFind</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowReplace</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetBackgroundColor</span><span class="params">(QColor color)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetBackgroundImage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">closeEvent</span><span class="params">(QCloseEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QMenu * fileMenu;        <span class="comment">//菜单栏各项</span></span><br><span class="line">    QMenu * editMenu;</span><br><span class="line">    QMenu * personaliseMenu;</span><br><span class="line">    QMenu * helpMenu;</span><br><span class="line"></span><br><span class="line">    QToolBar * filetoolbar;  <span class="comment">//文件工具栏</span></span><br><span class="line">    QToolBar * fontToolBar;  <span class="comment">//字体工具栏</span></span><br><span class="line"></span><br><span class="line">    QImage img;</span><br><span class="line">    QString filePath;</span><br><span class="line">    QTextEdit * <span class="built_in">text</span>;</span><br><span class="line">    <span class="keyword">bool</span> isUntitled;</span><br><span class="line"></span><br><span class="line">    QAction * openFileAction;          <span class="comment">//文件菜单项</span></span><br><span class="line">    QAction * newFileAction;</span><br><span class="line">    QAction * saveFileAction;</span><br><span class="line">    QAction * saveasFileAction;</span><br><span class="line">    QAction * printFileAction;</span><br><span class="line">    QAction * exitAction;</span><br><span class="line"></span><br><span class="line">    QAction * copyAction;              <span class="comment">//编辑菜单项</span></span><br><span class="line">    QAction * pasteAction;</span><br><span class="line">    QAction * cutAction;</span><br><span class="line">    QAction * undoAction;</span><br><span class="line">    QAction * restoreAction;</span><br><span class="line">    QAction * findAction;</span><br><span class="line">    QAction * replaceAction;</span><br><span class="line"></span><br><span class="line">    QAction * setBkColorAction;</span><br><span class="line">    QAction * setBkImageAction;</span><br><span class="line"></span><br><span class="line">    QAction * helpInformationAction;   <span class="comment">//帮助菜单项</span></span><br><span class="line">    QAction * aboutSoftwareAction;</span><br><span class="line">    QAction * AboutAuthorAction;</span><br><span class="line"></span><br><span class="line">    QLabel * fontLabel1;               <span class="comment">//字体设置项</span></span><br><span class="line">    QFontComboBox * fontComboBox;</span><br><span class="line">    QLabel * fontLabel2;</span><br><span class="line">    QComboBox * sizeComboBox;</span><br><span class="line">    QToolButton * boldBtn;</span><br><span class="line">    QToolButton * italicBtn;</span><br><span class="line">    QToolButton * underlineBtn;</span><br><span class="line">    QToolButton * colorBtn;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><h2 id="打包软件下载"><a href="#打包软件下载" class="headerlink" title="打包软件下载"></a>打包软件下载</h2><p><a href="https://wws.lanzous.com/i5HeRfmkf6d" target="_blank" rel="noopener">https://wws.lanzous.com/i5HeRfmkf6d</a></p><h2 id="程序源码下载"><a href="#程序源码下载" class="headerlink" title="程序源码下载"></a>程序源码下载</h2><p><a href="https://wws.lanzous.com/iDwC2fmkf8f" target="_blank" rel="noopener">https://wws.lanzous.com/iDwC2fmkf8f</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本人 QQ 2694218551，欢迎加我一起讨论编程问题！！</p>]]></content>
      
      
      <categories>
          
          <category> Qt 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt 程序打包发布 详细教程</title>
      <link href="/2020/04/15/Qt%20%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"/>
      <url>/2020/04/15/Qt%20%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当我们用QT写好了一个软件，要把你的程序分享出去的时候，不可能把编译的目录拷贝给别人去运行。编译好的程序应该是一个主程序，加一些资源文件，再加一些动态链接库，高大上一些的还可以做一个安装文件。</p><p>QT开发的程序发布的时候经常采用两种方式：</p><ol><li><strong>静态编译</strong>：可生成单一的可执行文件</li><li><strong>动态编译</strong>：需同时附上需要的dll文件。</li></ol><h2 id="发布准备"><a href="#发布准备" class="headerlink" title="发布准备"></a>发布准备</h2><h3 id="设置程序图标"><a href="#设置程序图标" class="headerlink" title="设置程序图标"></a>设置程序图标</h3><ol><li><p><strong>主窗口图标</strong>：主要在程序运行时显示在主窗口左上角，或在任务栏上显示。</p></li><li><p><strong>运行程序图标</strong>：一般在桌面或文件夹中显示的缩略图标，可以点击后运行程序。</p></li></ol><h4 id="设置主窗口图标"><a href="#设置主窗口图标" class="headerlink" title="设置主窗口图标"></a>设置主窗口图标</h4><p>（1）首先在绘图工具（例如Photoshop）中设计好图标，图标的分辨率最好大于32<em>32。图标需要用</em>ico或*png的文件。如果想偷懒一点，直接去 <a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a> 下载，大量好看免费的图标。</p><p>（2）将刚才的生成的图标文件放到yourProjectFolder/Resources/images目录下,或者任意一个程序可以找到的位置。最好将图标文件添加到qrc中统一管理。</p><p>（3）然后再主窗口中使用，代码如下，代码很简单，不过记住这句代码一定要放到 *<em>Mainwindow *</em>的构造函数里去，不然不会work。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*setwindowicon*/</span></span><br><span class="line"> setWindowIcon(QIcon(QStringLiteral(<span class="string">":/background/mainlogo"</span>)));<span class="comment">//括号写你自己实际路径就好</span></span><br></pre></td></tr></table></figure><p>程序运行后的效果如下：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/04/17/JZrtnf.png" alt=""></p><h4 id="设置运行程序的图标"><a href="#设置运行程序的图标" class="headerlink" title="设置运行程序的图标"></a>设置运行程序的图标</h4><p>如果你是使用qmake生成makefile文件或使用QT Creator IDE，那么按下面三步实施：</p><p>（1）创建一个包含图标图像的ICO文件，并将其保存在资源文件目录下，例如命名为：myapp.ico；</p><p>（2）新建一个.rc 文件    新建文件–&gt;C++–&gt;source文件–&gt;命名为  myapp.rc  (不能掉了rc后缀)</p><p>​        <strong>打开rc文件添加如下一行代码。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDI_ICON1 ICON DISCARDABLE <span class="string">"myapp.ico"</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>myapp.ico 是你的exe程序图标名。</p><p>​       <strong>最后在pro文件添加一行代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RC_FILE += myapp.rc</span><br></pre></td></tr></table></figure><p>保存项目重新编译，exe图标和执行时window图标都将发生变化。</p><h3 id="编译release版本程序"><a href="#编译release版本程序" class="headerlink" title="编译release版本程序"></a>编译release版本程序</h3><p>注意将运行程序编译方式设置成Release，因为debug版本的程序中包含了调试信息，可以用来调试。而真正要发布程序时，要使用release版本，这样可以减少发布程序的体积同时增加软件的安全。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/04/17/JZrFh9.png" alt=""></p><blockquote><p>上图演示在Qt Creator中的设置方式，选中IDE左边的侧边栏的项目，然后再构建设置中将构建配置设置为Release。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/04/17/JZDDOK.png" alt=""></p><blockquote><p>上图演示在VS2015中的设置方式，选中IDE右边的解决方案管理器中的项目，然后在IDE上边的工具栏中将构建配置设置为Release。</p></blockquote><h2 id="发布程序"><a href="#发布程序" class="headerlink" title="发布程序"></a>发布程序</h2><p>Qt官方开发环境默认使用动态链接库方式，在发布生成的可执行程序时，我们需要复制一大堆动态库，如果自己去复制动态库，很可能丢三落四，导致程序在别的电脑里无法正常运行。 因此 Qt 官方开发环境里自带了一个部署工具来帮助开发者自动拷贝大部分的依赖库。在不同的平台使用方式也有所不同。</p><h3 id="windows平台"><a href="#windows平台" class="headerlink" title="windows平台"></a>windows平台</h3><p>Windows开发环境下 <strong>windeployqt</strong> 工具 (如果你已经将Qt的bin目录加入PATH环境,那么你可以直接在命令行使用windeployqt调用.)。</p><p>（1）将项目中的release文件中的可执行文件拷到一个新建的文件夹中，例如project.exe，</p><p>（2）用Qt自带的生成必备的dll文件的程序windeployqt，来把必要的动态库拷到该文件夹中。</p><p>打开命令行，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windeployqt  project.exe</span><br></pre></td></tr></table></figure><p>这时候大部分的dll文件都自动拷贝过来了，但是 <strong>如果项目还用了一些其他的SDK，比如OpenCV，Chartdir51等等，就需要手动将所需dll拷贝过来</strong> ，如果不知道还需要哪些软件，可以用Dependency Walker来查看缺少哪些dll文件。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/04/17/JZDywD.png" alt=""></p><p>拷贝完成后文件夹下的文件清单如下：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/04/17/JZDseO.png" alt=""></p><p><strong>注意：</strong>如果发布的应用是<strong>Qt Quick Application应用</strong>，那么命令行需要加上<strong>QML的安装目录</strong>。命令中的D:\Qt\Qt5.5.1\qml是qml的安装目录,请换成你自己的qml安装目录!!!!!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windeployqt hello.exe--qmldir D:\Qt\Qt5.5.1\qml</span><br></pre></td></tr></table></figure><h3 id="linux平台"><a href="#linux平台" class="headerlink" title="linux平台"></a><strong>linux平台</strong></h3><p>在X11平台下qt程序，首先准备好程序中需要使用的资源，库和插件…，比如你的可运行程序取名叫作panel，那把你的panel,那些libQt<em>.so.4和libQt</em>.so.4.6.0（链接和共享库都要）放在同一目录下(也可以不同,只要小小修改下shell文件).plugins就不多说了。</p><p>在程序的同目录下，新建一個空文档，取名panel.sh (文件名与程序名同名,扩展名为sh,shell文件)。在panel.sh中原封不动的写入以下语句:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">appname&#x3D;&#96;basename $0 | sed s,&#x2F;.sh$,,&#96;</span><br><span class="line"></span><br><span class="line">  dirname&#x3D;&#96;dirname$0&#96;</span><br><span class="line"></span><br><span class="line">  tmp&#x3D;&quot;$&#123;dirname#?&#125;&quot;</span><br><span class="line"></span><br><span class="line">  if [&quot;$&#123;dirname%$tmp&#125;&quot; !&#x3D; &quot;&#x2F;&quot; ]; then</span><br><span class="line"></span><br><span class="line">   dirname&#x3D;$PWD&#x2F;$dirname</span><br><span class="line"></span><br><span class="line"> fi</span><br><span class="line"></span><br><span class="line">   LD_LIBRARY_PATH&#x3D;$dirname</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">   $dirname&#x2F;$appname$*</span><br></pre></td></tr></table></figure><p>保存文件，退出。在终端給文件+x属性: 切换到程序的目录，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x panel.sh</span><br></pre></td></tr></table></figure><p>然后运行shell文件就行了（确保panel程序具备X属性）,它会自动更改环境变量,运行程序。</p><p>如果要调试shell文件,只需要在终端输入:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -x panel.sh</span><br></pre></td></tr></table></figure><p>这样就 ok 了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>现在你就可以把现在的文件夹压缩成一个压缩包，分享给你的朋友使用了！！</p>]]></content>
      
      
      <categories>
          
          <category> Qt 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt 项目管理文件(.pro)及其作用详解</title>
      <link href="/2020/04/05/Qt%20%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%EF%BC%88.pro%EF%BC%89%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/04/05/Qt%20%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%EF%BC%88.pro%EF%BC%89%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="项目文件目录树"><a href="#项目文件目录树" class="headerlink" title="项目文件目录树"></a>项目文件目录树</h2><p>在 Qt Creator 中新建一个 Widget Application 项目 samp2_1，在选择窗口基类的页面选择 QWidget 作为窗体基类，并选中“Generate form”复选框。创建后的项目文件目录树如图 1 所示。</p><p> <img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/181229/2-1Q22Z95914431.gif" alt="img"><br> 图 1 项目文件的目录树</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p> 这个项目包含以下一些文件：</p><blockquote><p>（1）项目管理文件 samp2_1.pro，存储项目设置的文件。</p><p>（2）主程序入口文件 main.cpp，实现 main()函数的程序文件。</p><p>（3）窗体界面文件 widget.ui，一个 XML 格式存储的窗体上的元件及 其布局的文件。</p><p>（4）widget.h 是所设计的窗体类的头文件，widget.cpp 是 widget.h 里 定义类的实现文件。C++中，任何窗体或界面组件都是用类封装的，一个类一般有一个头文件（.h 文件）和一个源程序文件（.cpp 文件）。</p></blockquote><h2 id="项目管理文件（-pro文件）"><a href="#项目管理文件（-pro文件）" class="headerlink" title="项目管理文件（.pro文件）"></a>项目管理文件（.pro文件）</h2><p> 下面介绍一下项目管理文件（.pro文件）。</p><p>后缀为“ <strong>.pro</strong> ”的文件是项目的管理文件，文件名就是项目的名称，如本项目中的 <strong>samp2_1.pro</strong>。 下面是 *<em>samp2_1.pro *</em>文件的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QT       += core gui</span><br><span class="line">greaterThan(QT_MAJOR_VERSION, <span class="number">4</span>): QT += widgets</span><br><span class="line">TARGET = samp2_1</span><br><span class="line">TEMPLATE = app</span><br><span class="line">SOURCES += \</span><br><span class="line">        main.cpp \</span><br><span class="line">        widget.cpp</span><br><span class="line">HEADERS += \</span><br><span class="line">        widget.h</span><br><span class="line">FORMS += \</span><br><span class="line">        widget.ui</span><br></pre></td></tr></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>项目管理文件用于记录项目的一些设置，以及项目包含文件的组织管理。</p><h3 id="代码介绍"><a href="#代码介绍" class="headerlink" title="代码介绍"></a>代码介绍</h3><p>（1）“Qt += core gui”表示项目中加入 core gui 模块。core gui 是 Qt 用于 GUI 设计的类库模块，如果创建的是控制台（Console）应用程序，就不需要添加 core gui。</p><p>（2） Qt 类库以模块的形式组织各种功能的类，根据项目涉及的功能需求，在项目中添加适当的类库模块支持。例如，如果项目中使用到了涉及数据库操作的类就需要用到 sql 模块，在 pro 文件中需要更改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT       += core gui sql</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/images/qt5.png" alt=""></p><p>（3）samp2_1.pro 中的第 2 行是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">greaterThan(Qt_MAJOR_VERSION, <span class="number">4</span>): Qt += widgets</span><br></pre></td></tr></table></figure><p>这是个条件执行语句，表示当 Qt 主版本大于 <strong>4</strong> 时，才加入 widgets 模块。</p><p> （4）“ TARGET = samp2_1 ”表示生成的目标可执行文件的名称，即编译后生成的可执行文件是 samp2_1.exe。</p><p> （5）“TEMPLATE = app”表示项目使用的模板是 app，即 application，是一般的应用程序。</p><p> （6）后面的 SOURCES、HEADERS、FORMS 记录了项目中包含的源程序文件、头文件和窗体文件（.ui 文件）的名称。这些文件列表是 Qt  Creator  自动添加到项目管理文件里面的，用户不需要手动修改。当添加一个文件到项目，或从项目里删除一个文件时，项目管理文件里的条目会自动修改。</p>]]></content>
      
      
      <categories>
          
          <category> Qt 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt Creator 常用快捷键 总结</title>
      <link href="/2020/04/05/Qt%20Creator%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2020/04/05/Qt%20Creator%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Qt-Creator-常用快捷键"><a href="#Qt-Creator-常用快捷键" class="headerlink" title="Qt Creator 常用快捷键"></a>Qt Creator 常用快捷键</h1><table><thead><tr><th align="center">快捷键</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">F1</td><td align="center">查看帮助文档</td></tr><tr><td align="center">Shift + F2</td><td align="center">函数的声明和定义之间快速切换</td></tr><tr><td align="center">F4</td><td align="center">对应.h 文件和对应.cpp 文件切换</td></tr><tr><td align="center">Ctrl + /</td><td align="center">代码注释及取消注释（前提是选中代码）</td></tr><tr><td align="center">Ctrl + 鼠标滚轮向上向下</td><td align="center">调整字体变大变小</td></tr><tr><td align="center">ctrl + shift + 键盘方向键</td><td align="center">移动代码（前提是选中所要移动的代码）</td></tr><tr><td align="center">ctrl + f</td><td align="center">查找替换关键字</td></tr><tr><td align="center">Ctrl + B</td><td align="center">只编译（Build）不运行</td></tr><tr><td align="center">Ctrl + R</td><td align="center">编译并运行（run）</td></tr><tr><td align="center">Ctrl + I</td><td align="center">自动缩进当前行</td></tr><tr><td align="center">Ctrl +M</td><td align="center">创建书签</td></tr><tr><td align="center">Ctrl + .</td><td align="center">切换书签</td></tr><tr><td align="center">Alt + M</td><td align="center">打开书签栏</td></tr><tr><td align="center">Ctrl + [</td><td align="center">光标跳到程序段开头</td></tr><tr><td align="center">Ctrl + ]</td><td align="center">光标跳到程序段结尾</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Qt 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt C++ 开发环境配置 详细教程</title>
      <link href="/2020/04/04/Qt%20C++-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"/>
      <url>/2020/04/04/Qt%20C++-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Qt-下载"><a href="#Qt-下载" class="headerlink" title="Qt 下载"></a>Qt 下载</h1><p>Qt 体积很大，有 1GB~3GB，官方下载通道非常慢，相信很多读者会崩溃，所以建议大家使用国内的镜像网站（较快），或者使用迅雷下载（很快）。作为 Qt 下载教程，本文会同时讲解以上三种下载方式。</p><h2 id="Qt-官方下载（非常慢）"><a href="#Qt-官方下载（非常慢）" class="headerlink" title="Qt 官方下载（非常慢）"></a>Qt 官方下载（非常慢）</h2><p>Qt 官网有一个专门的资源下载网站，所有的开发环境和相关工具都可以从这里下载，具体地址是：<a href="http://download.qt.io/" target="_blank" rel="noopener">http://download.qt.io/</a></p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190528/1-1Z52QF229606.gif" alt="Qt官方下载网站截图"></p><p>​                                                                                     图1：Qt 官方下载网站截图</p><table><thead><tr><th align="center">目录</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">archive</td><td align="center">各种 Qt 开发工具安装包，新旧都有（可以下载 Qt 开发环境和源代码）。</td></tr><tr><td align="center">community_releases</td><td align="center">社区定制的 Qt 库，Tizen 版 Qt 以及 Qt 附加源码包。</td></tr><tr><td align="center">development_releases</td><td align="center">开发版，有新的和旧的不稳定版本，在 Qt 开发过程中的非正式版本。</td></tr><tr><td align="center">learning</td><td align="center">有学习 Qt 的文档教程和示范视频。</td></tr><tr><td align="center">ministro</td><td align="center">迷你版，目前是针对 <a href="http://c.biancheng.net/android/" target="_blank" rel="noopener">Android</a> 的版本。</td></tr><tr><td align="center">official_releases</td><td align="center">正式发布版，是与开发版相对的稳定版 Qt 库和开发工具（可以下载Qt开发环境和源代码）。</td></tr><tr><td align="center">online</td><td align="center">Qt 在线安装源。</td></tr><tr><td align="center">snapshots</td><td align="center">预览版，最新的开发测试中的 Qt 库和开发工具。</td></tr></tbody></table><p> archive 和 official_releases 两个目录都有最新的 Qt 开发环境安装包，我们以 archive 目录里的内容为例来说明。点击进入 archive 目录，会看到四个子目录：</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190528/1-1Z52QG4223W.gif" alt="archive的四个子目录"></p><p>​                                                                                                图2：进入 archive 目录</p><table><thead><tr><th align="center">目录</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">vsaddin</td><td align="center">这是 Qt 针对 Visual Studio 集成的插件，本教程基本不使用 Visual Studio ，所以不需要插件。</td></tr><tr><td align="center">qtcreator</td><td align="center">这是 Qt 官方的集成开发工具，但是 qtcreator 本身是个空壳，它没有编译套件和 Qt 开发库。    除了老版本的 Qt 4 需要手动下载 qtcreator、编译套件、Qt 开发库进行搭配之外，一般用不到。对于我们教程压根不需要下载它，因为 Qt 5 有专门的大安装包，里面包含开发需要的东西，并且能自动配置好。</td></tr><tr><td align="center">qt</td><td align="center">这是 Qt 开发环境的下载目录，我们刚说的 Qt 5 的大安装包就在这里面。</td></tr><tr><td align="center">online_installers</td><td align="center">在线安装器，国内用户不建议使用，在线安装是龟速，还经常断线。我们教程采用的全部是离线的大安装包。</td></tr></tbody></table><p> 我们再进入 qt 子目录 ，看到如下列表：</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190528/1-1Z52QH249511.gif" alt="qt子目录"></p><p>​                                                                                         图3：进入 qt 子目录</p><p> 上图没有列完整，这个 qt 目录包含了所有的 Qt 版本，从 1.0 到目前的 5.12 。</p><p> 由于 Qt 5.9 是一个长期技术支持版本（Long Term Support，LTS），在未来几年里都将有更新支持，因此，本教程以 Qt 5.9 LTS 版本为例进行讲解，并且所有实例程序均使用 Qt 5.9 编译测试通过。</p><blockquote><p>Qt 的上一个 LTS 版本是 5.6，它其实已经超出支持期了。</p></blockquote><p>进入 5.9 目录，会看到各种子版本：</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190528/1-1Z52QI023222.gif" alt=" qt 5.9 子目录"></p><p>​                                                                                    图4：Qt 5.9 的各个子版本</p><p> 这里解释一下 Qt 的版本号，比如 5.9.8 是完整的 Qt 版本号，第一个数字 5 是大版本号（major），第二个数字 9  是小版本号(minor)，第三个数字 8 是补丁号 (patch)。 只要前面两个数字相同，Qt  的特性就是一致的，最后的数字是对该版本的补丁更新。也就是说本教程对 5.9.* 系列的 Qt 都是通用的，下载 5.9.*  任意一个版本都可以，这里我们以下载 5.9.0。</p><p> 点击 5.9.0，进入子目录：</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190528/1-1Z52QK0309D.gif" alt="Qt 5.9.0 下载页面"></p><p>​                                                                                             图5：Qt 5.9.0 下载页面</p><p> 根据不同的操作系统，选择不同的安装包即可，不用管源码包，除非你想自己编译或者阅读源码。</p><p> 我们以 Windows 安装包（qt-opensource-windows-x86-5.9.0.exe）讲解一下 Qt 安装包命名规则，其中：</p><ul><li>opensource 是指开源版本；</li><li>windows 是指开发环境的操作系统；</li><li>x86 是指 32 位系统；</li><li>5.9.0 是 Qt 版本号。</li></ul><h2 id="Qt-国内镜像站下载（较快）"><a href="#Qt-国内镜像站下载（较快）" class="headerlink" title="Qt 国内镜像站下载（较快）"></a>Qt 国内镜像站下载（较快）</h2><p>请读者注意图5中最后一栏的 Details 链接（红色方框圈起来的地方）。点击 Details 链接可以进入详情页，在该页面可以看到文件的大小、校验和以及世界各地镜像下载链接（这才是重点）。</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190528/1-1Z52QP11N93.gif" alt="国内镜像下载链接"></p><p>​                                                                                            图6：国内镜像下载链接</p><p> 可以清楚地看到，Qt 在国内的有三个镜像网站可以下载，点击这些地址中的一个就可以下载，从国内镜像网站下载速度快一些。</p><h3 id="国内镜像网站"><a href="#国内镜像网站" class="headerlink" title="国内镜像网站"></a>国内镜像网站</h3><p>这里给大家推荐几个国内著名的 Qt 镜像网站，主要是各个高校的：</p><ul><li>中国科学技术大学：<a href="http://mirrors.ustc.edu.cn/qtproject/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/qtproject/</a></li><li>清华大学：<a href="https://mirrors.tuna.tsinghua.edu.cn/qt/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/qt/</a></li><li>北京理工大学：<a href="http://mirror.bit.edu.cn/qtproject/" target="_blank" rel="noopener">http://mirror.bit.edu.cn/qtproject/</a></li><li>中国互联网络信息中心：<a href="https://mirrors.cnnic.cn/qt/" target="_blank" rel="noopener">https://mirrors.cnnic.cn/qt/</a></li></ul><p> 国内镜像网站的结构和官方是类似的，我们在第一部分已经分析过了，这里不再赘述。</p><h2 id="迅雷下载（很快）"><a href="#迅雷下载（很快）" class="headerlink" title="迅雷下载（很快）"></a>迅雷下载（很快）</h2><p>将 Qt 软件的下载地址复制到迅雷的下载框，如果迅雷官方有资源，就会自动识别，下载速度就很快了。</p><p> 如何找到 Qt 软件的下载地址呢？以清华大学开源软件镜像站为例，进入 Qt 5.9.0 的下载目录（<a href="https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/5.9/5.9.0/），在某个链接处单击鼠标右键，会弹出一个菜单，选择“复制链接地址”，如下图所示：" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/5.9/5.9.0/），在某个链接处单击鼠标右键，会弹出一个菜单，选择“复制链接地址”，如下图所示：</a></p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190529/1-1Z529105333515.gif" alt="找到Qt下载地址"></p><p>​                                                                                                        图7：找到 Qt 下载地址</p><p> 这样就把 Qt 5.9.0 的下载地址（具体为  <a href="https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/5.9/5.9.0/qt-opensource-windows-x86-5.9.0.exe）复制到了剪切板，然后再粘贴到迅雷的下载框：" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/5.9/5.9.0/qt-opensource-windows-x86-5.9.0.exe）复制到了剪切板，然后再粘贴到迅雷的下载框：</a></p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190529/1-1Z529105R0a0.gif" alt="把Qt下载地址粘贴到迅雷下载框"></p><p>​                                                                                 图8：把Qt下载地址粘贴到迅雷下载框</p><p> 点击 *<em>立即下载 *</em>按钮，稍等片刻，迅雷会自动匹配到资源，速度飞快</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190529/1-1Z529110011311.gif" alt="下载速度 2.7MB/s"></p><p>​                                                                                            图9：下载速度 2.7MB/s</p><p>注意，常用的 Qt  版本一般都能匹配到资源，但是不保证每个版本都能匹配到资源，上面的例子仅对清华大学镜像站的 Qt 5.9.0 Windows  版 <a href="https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/5.9/5.9.0/qt-opensource-windows-x86-5.9.0.exe" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/5.9/5.9.0/qt-opensource-windows-x86-5.9.0.exe</a> 有效。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>对 Qt 版本更新感兴趣的读者请访问 Qt wiki 网站，地址为：<a href="https://wiki.qt.io/Main" target="_blank" rel="noopener">https://wiki.qt.io/Main</a></p><p> Qt wiki 网站会显示最新的正式版、LTS 版、正在开发中的版本等等，比主站 <a href="https://www.qt.io/" target="_blank" rel="noopener">https://www.qt.io/</a> 靠谱多了。Qt 主站因为商业推广的原因，安装包的下载步骤非常繁琐。</p><h1 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>目前较高版本的 Qt 仅支持 Win7 及其以后的操作系统，不支持 Win XP；使用 Win XP 的读者请安装 Qt 5.5.1 之前的版本。</p><p> Qt 占用的存储空间很大，安装之前建议先准备好 8GB 以上的磁盘空间。对于目前 Qt 最新版开发环境，如果不安装源代码包，实际占用大约 5.5GB；如果选择安装源码包，大约占用 7.5GB。</p><p> 双击下载得到的 qt-opensource-windows-x86-5.9.0.exe 即可开始安装。Qt 的安装过程和普通的 Windows 软件一样，按照向导进行操作即可。</p><p> 关于 Qt 的安装需要说明以下几点。</p><h2 id="1-注册和登录"><a href="#1-注册和登录" class="headerlink" title="1) 注册和登录"></a>1) 注册和登录</h2><p>Qt 在安装过程中会提示用户进行注册和登录，不用理会，跳过（Skip）即可，实际开发时不需要登录。</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190529/1-1Z52913304V60.gif" alt=""></p><h2 id="2-安装路径和关联文件"><a href="#2-安装路径和关联文件" class="headerlink" title="2) 安装路径和关联文件"></a>2) 安装路径和关联文件</h2><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190529/1-1Z529133255346.gif" alt=""></p><p>Qt 允许用户自定义安装路径，但是请注意，安装路径不能带空格、中文字符或者其它任何特殊字符。</p><p>另外，该界面还会询问是否关联特定的文件类型。如果关联（默认是关联的），特定后缀的文件（包括 .cpp 文件）默认使用 Qt 打开。我喜欢使用纯文本编辑器（例如 Sublime Text）来打开 C++ 源文件，所以我取消了该选项，读者根据自己的实际情况定夺。</p><h2 id="3-选择安装组件"><a href="#3-选择安装组件" class="headerlink" title="3) 选择安装组件"></a>3) 选择安装组件</h2><p>Qt 安装过程中最关键的一步是组件的选择，请看下图：</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190529/1-1Z52915401NT.gif" alt="Qt组件"></p><p> Qt 的安装组件分为两部分：一部分是“Qt 5.9”分类下的，该分类包含的是真正的 Qt 开发库组件；另一部分是“Tools”分类下的，该分类包含的是集成开发环境和编译工具。</p><h2 id="Qt-安装组件及其说明"><a href="#Qt-安装组件及其说明" class="headerlink" title="Qt 安装组件及其说明"></a>Qt 安装组件及其说明</h2><table><thead><tr><th align="center">组件</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"></td><td align="center"><strong>“Qt 5.9”分类下的开发组件</strong></td></tr><tr><td align="center">MinGW 5.3.0 32 bit</td><td align="center">编译器模块。MinGW 是 Minimalist GNU for Windows 的缩写，MinGW 是 Windows 平台上使用的 GNU 工具集导入库的集合。是本教程使用 MinGW 编译，所以必须安装。</td></tr><tr><td align="center">UWP</td><td align="center">UWP 是 Windows 10 中 Universal Windows Platform 的简称，有不同编译器类型的 UWP，属于 MSVC 编译器生成的 Qt 库。如果不是开发 UWP 应用程序，就不需要，直接忽略。</td></tr><tr><td align="center">MSVC</td><td align="center">针对 Windows 平台上的 MSVC 编译器的 Qt 组件，如 msvc2015 32-bit 和 msvc2015 64-bit  等。安装该组件需要计算机上已经安装相应版本的 Visual Studio。如果你不使用 MSVC 编译器进行开发，就不用安装。本教程使用  MinGW 编译组件，所以不用安装 MSVC *** 组件。</td></tr><tr><td align="center">Android</td><td align="center">这是针对安卓应用开发的 Qt 库，如果读者有安卓开发这方面需求可以自己选择安装，一般情况下用不到。</td></tr><tr><td align="center">Sources</td><td align="center">Qt 的源代码包，除非你想阅读 Qt 的源码，否则不用安装。</td></tr><tr><td align="center">Qt</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"><strong>“Tools”分类下的开发组件</strong></td></tr><tr><td align="center">组件</td><td align="center">说明</td></tr><tr><td align="center">Qt Creator 4.3.0</td><td align="center">这是集成开发环境，强制安装的，以后所有的项目和代码都在 Qt Creator 里面新建和编辑。</td></tr><tr><td align="center">Qt Creator 4.3.0 CDB Debugger surpport</td><td align="center">用于和 CDB 调试工具对接，默认安装，一般用于调试 VC 编译的 Qt 程序。</td></tr><tr><td align="center">MinGW 5.3.0</td><td align="center">这是开源的编译器套件，这本教程必须用到的，需要读者勾选安装。</td></tr><tr><td align="center">Strawberry Perl 5.22.1.3</td><td align="center">用于编译 Qt 源代码的 Perl 开发环境，不需要安装。如果读者以后用到，也可以另外手动安装，在搜索引擎搜索 Strawberry Perl 关键词，去 Strawberry Perl 官网下载最新的安装包是一样用的。</td></tr></tbody></table><p> 选择完了组件，根据向导一步一步操作就可以了。安装完成后，在 Windows“开始”菜单中会看到 Qt 5.9.0 程序组。</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190529/1-1Z529155424L0.gif" alt="Qt 5.9.0所包含的程序"></p><table><thead><tr><th align="center">程序</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Qt Creator 4.6.2 (Enterprise)</td><td align="center">Qt 的集成开发环境，本教程就使用它来创建和管理 Qt 项目。</td></tr><tr><td align="center">Assistant（Qt 助手）</td><td align="center">用来查看帮助文档，已被集成在 Qt Creator 中。</td></tr><tr><td align="center">Designer（Qt 设计师）</td><td align="center">图形界面可视化编辑工具，已被集成在 Qt Creator 中，在 Qt Creator 中编辑或创建界面文件时，就可以自动打开。</td></tr><tr><td align="center">Linguist（Qt 语言家）</td><td align="center">多国语言翻译支持工具，可以用来编辑语言资源文件，在开发多语言界面的应用程序时会用到。</td></tr><tr><td align="center">Qt 5.11.1 for Desktop (MinGW 5.3.0 32bit)</td><td align="center">Qt 命令行工具，用来配置 Qt 开发环境（主要是设置 PATH 变量）。</td></tr></tbody></table><blockquote><p><strong>温馨提示</strong>：你可以将 Assistant 直接拖到桌面建立快捷方式，方便自己以后查询使用。</p></blockquote><h1 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h1><p>Linux 发行版虽然众多，但 Qt 安装过程大同小异，本节以 CentOS 7 为例来演示 Qt 的安装。</p><p>上文已经讲解了 Qt 安装包的下载方式，Qt 5.9.0 Linux 安装包的名称为 qt-opensource-linux-x64-5.9.0.run。</p><p> 下载的 run 文件不一定具有可执行权限， 可以执行如下命令开启执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x &#x2F;文件夹路径&#x2F;qt-opensource-linux-x64-5.9.0.run</span><br></pre></td></tr></table></figure><p>将“文件夹路径”替换为自己系统里该 run 文件的路径即可。然后可以直接点击运行该 run 文件，开始安装。</p><p>注意以下是以普通用户权限安装的, 安装位置是 /home/用户名/Qt5.9.0/, 如果希望安装到其他的目录(如 /opt/ 目录)，是需要 root 权限的。</p><p>下面示范简单的普通用户安装方式，需要用户主目录 /home 所在磁盘分区至少剩余 2GB 空间。所示范的是 64 位安装包，使用的发行版是 CentOS 7（64 位）。</p><p> 运行 qt-opensource-linux-x64-5.9.0.run 文件，根据向导一步步安装就可以了。关于 Qt 的安装需要说明以下几点。</p><h2 id="1-注册和登录-1"><a href="#1-注册和登录-1" class="headerlink" title="1) 注册和登录"></a>1) 注册和登录</h2><p>Qt 在安装过程中会提示用户进行注册和登录，不用理会，跳过（Skip）即可，实际开发时不需要登录。</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190530/1-1Z530154Z9604.gif" alt="Qt 安装过程中提示用户注册"></p><p>​                                                                                图1：Qt 安装过程中提示用户注册</p><h2 id="2-安装路径"><a href="#2-安装路径" class="headerlink" title="2) 安装路径"></a>2) 安装路径</h2><p>Qt 在安装过程中允许自定义安装路径，我将 Qt 安装在主目录下的 programs/Qt5.9.0 文件夹中，一般使用默认路径即可。</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190531/1-1Z531145A2940.gif" alt="指定 Qt 安装路径"></p><p>​                                                                                         图2：指定 Qt 安装路径</p><h2 id="3-选择安装组件-1"><a href="#3-选择安装组件-1" class="headerlink" title="3) 选择安装组件"></a>3) 选择安装组件</h2><p>Qt 安装过程中最关键的一步是组件的选择，请看下图：</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190531/1-1Z53115100C14.gif" alt="Qt 组件"></p><p>​                                                                                                    图3：Qt 组件</p><p> Qt 的安装组件分为两部分：一部分是“Qt 5.9”分类下的，该分类包含的是 Qt  开发库，也就是动态链接库或者静态链接库；另一部分是“Tools”分类下的，该分类包含的是集成开发环境（可执行程序），也就是 Qt  Creator（在 Windows 下还会有其它工具）</p><table><thead><tr><th align="center"></th><th align="center">“Qt 5.9”分类下的开发库</th></tr></thead><tbody><tr><td align="center">开发库</td><td align="center">说明</td></tr><tr><td align="center">Desktop gcc 64-bit</td><td align="center">这是使用桌面版 GCC 64-bit 编译环境生成的 Qt 库，是 Qt 的核心，必须安装。    注意，虽然名字看起来像是 GCC 编译器套件，但实际上说的是 Qt 库的编译环境。大部分 Linux 发行版 都会预装 GCC 编译器套件，所以 Qt 安装包没必要附带它们。</td></tr><tr><td align="center">Android</td><td align="center">这是针对安卓应用开发的 Qt 库，如果读者有安卓开发这方面需求可以自己选择安装，一般情况下用不到。</td></tr><tr><td align="center">Sources</td><td align="center">Qt 的源代码包，除非你想阅读 Qt 的源码，否则不用安装。</td></tr><tr><td align="center">Qt</td><td align="center">Qt 的附加模块，大部分建议安装，这些附加模块括号里的 TP 是指 Technology Preview  ，技术预览模块的意思，还处在功能测试阶段，不是正式版模块；附加模块括号里的 Deprecated  是指抛弃的旧模块，兼容旧代码使用的，一般用不到。这些附加模块读者可以选择部分或都勾选了安装，占用空间不大。    部分组件说明：  Qt Charts 是二维图表模块，用于绘制柱状图、饼图、曲线图等常用二维图表。 Qt Data Visualization 是三维数据图表模块，用于数据的三维显示，如散点的三维空间分布、三维曲面等。 Qt Scritp（Deprecated）是脚本模块，已被抛弃，不建议安装。</td></tr><tr><td align="center"></td><td align="center"><strong>“Tools”分类下的集成开发环境</strong></td></tr><tr><td align="center">集成开发环境</td><td align="center">说明</td></tr><tr><td align="center">Qt Creator 4.3.0</td><td align="center">这是集成开发环境，强制安装的，以后所有的项目和代码都在 Qt Creator 里面新建和编辑。</td></tr></tbody></table><p> 选择完了组件，根据向导一步一步操作就可以了。安装完成后，在左上角“应用程序 –&gt; 编程”菜单中可以看到 Qt Creator，证明安装成功了。点击 Qt Creator，就可以开始 Qt 编程了。</p><p><img src= "/img/loading.gif" data-src="http://c.biancheng.net/uploads/allimg/190530/1-1Z5301P02L53.gif" alt="Qt 安装完成"></p><p>​                                                                                                        图4：Qt 安装完成</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>至此，马上开始你的Qt学习之旅吧！！！</p>]]></content>
      
      
      <categories>
          
          <category> 开发配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 指针的引用和指向引用的指针</title>
      <link href="/2020/04/04/C++%20%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E5%90%91%E5%BC%95%E7%94%A8%E7%9A%84%E6%8C%87%E9%92%88/"/>
      <url>/2020/04/04/C++%20%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E5%90%91%E5%BC%95%E7%94%A8%E7%9A%84%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="指向引用的指针"><a href="#指向引用的指针" class="headerlink" title="指向引用的指针"></a>指向引用的指针</h2><p>简单使用指针的一个例子就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure><p><strong><font color=red>预先强调：</font></strong> <strong>没有指向引用的指针</strong></p><p><strong>原因：</strong> 因为引用 <strong><font color=red>不是对象，没有地址</font></strong>。</p><p>但是指向引用的指针是什么形式呢？是对一个引用进行如下取地址吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ri = v;<span class="comment">// 整型变量v的引用</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;ri;<span class="comment">// 这是指向引用的指针吗？</span></span><br></pre></td></tr></table></figure><p>事实上不是，这是一个普通的整型指针，虽然我们说引用没有地址，但是对引用ri的操作实际上是对v的操作。这是是定义了一个整型指针p，并且让它指向了v。<br>那如何定义一个指向引用的指针呢(虽然是不合理的请求)？当我们定义指针的时候，我们用到了* ，那么当我们定义指向引用的指针时，免不了要用到*和&amp;。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ri = v;</span><br><span class="line"><span class="keyword">int</span> &amp;*p = &amp;ri;  <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>由于引用并<strong>不存在地址</strong>，因此第三行将会报错。我们可以从右往左读，<code>*</code>表明p是一个指针，余下的<code>&amp;</code>说明了<code>p</code>指向类型的类型。</p><h2 id="指针的引用"><a href="#指针的引用" class="headerlink" title="指针的引用"></a>指针的引用</h2><p>引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。</p><p>之前说到指向引用的指针，现在来说指针的引用就容易多了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;v;</span><br><span class="line"><span class="keyword">int</span>* &amp;rp = p;</span><br></pre></td></tr></table></figure><p><code>&amp;</code>说明rp是一个引用。<code>*</code>确定rp引用的类型是一个指针。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>因为引用不是对象，故无引用的数组，无指向引用的指针，无到引用的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; a[<span class="number">3</span>]; <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">int</span>&amp;* p;   <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">int</span>&amp; &amp;r;   <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>参考博文：<a href="https://blog.csdn.net/fatfish_/article/details/86768887" target="_blank" rel="noopener">https://blog.csdn.net/fatfish_/article/details/86768887</a></p>]]></content>
      
      
      <categories>
          
          <category> C / C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 函数模板实现机制原理剖析</title>
      <link href="/2020/04/03/C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
      <url>/2020/04/03/C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="C-函数模板实现机制原理剖析"><a href="#C-函数模板实现机制原理剖析" class="headerlink" title="C++ 函数模板实现机制原理剖析"></a>C++ 函数模板实现机制原理剖析</h1><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ol><li><p>编译器并不是把函数模板处理成能够处理任意类的函数</p></li><li><p>编译器从函数模板通过具体类型来产生不同的函数</p></li><li><p>编译器会对函数模板进行两次编译</p><p>（1）在声明的位置对模板代码进行编译</p><p>（2）在调用的位置对参数替换后的代码进行编译</p></li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>自己的代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//声明位置，第一次编译</span></span><br><span class="line"><span class="function">T  <span class="title">myswap</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用模板函数!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myswap(<span class="number">1</span>,<span class="number">1</span>);         <span class="comment">//调用位置，第二次编译</span></span><br><span class="line">    myswap(<span class="string">'a'</span>,<span class="string">'b'</span>);</span><br><span class="line">    myswap(<span class="number">2.0</span>,<span class="number">3.0</span>);        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实际编译器处理后的代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>     <span class="title">myswap</span><span class="params">(<span class="keyword">int</span>  a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用模板函数!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span>  <span class="title">myswap</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用模板函数!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">myswap</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用模板函数!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myswap(<span class="number">1</span>,<span class="number">1</span>);         </span><br><span class="line">    myswap(<span class="string">'a'</span>,<span class="string">'b'</span>);</span><br><span class="line">    myswap(<span class="number">2.0</span>,<span class="number">3.0</span>);        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ol><li><p>函数模板不是说只 <strong>一个函数</strong> 就可以实现对任意数据类型的操作，而是通过两次编译生成了满足我们调用需求所需要的所有代码。</p></li><li><p>函数模板使用后，编译器并不会一开始就生成所有处理任何类型的函数，而是通过实际的函数调用来生成。比如调用函数时，需要处理int型数据，就生成处理int型数据的函数，而没有用double型数据，就不会生成处理double型数据的函数。</p></li><li><p>编译器内部帮我们实现了大量重复操作，让程序员节省了大量代码</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C / C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 函数模板和函数重载同时出现如何调用</title>
      <link href="/2020/04/03/C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8/"/>
      <url>/2020/04/03/C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="C-函数模板和函数重载同时出现如何调用"><a href="#C-函数模板和函数重载同时出现如何调用" class="headerlink" title="C++ 函数模板和函数重载同时出现如何调用"></a>C++ 函数模板和函数重载同时出现如何调用</h1><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ol><li>函数模板<strong>不允许自动转换</strong>，普通函数<strong>可以进行自动类型转换</strong></li><li>函数模板可以像普通函数一样被<strong>重载</strong></li><li>C++编译器<strong>优先考虑调用普通函数</strong></li><li>如果函数模板可以<strong>产生一个更好的匹配</strong>，则选择模板函数</li><li>可以通过<strong>空模板实参列表</strong>的语法限定编译器只调用模板函数</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数和模板函数  函数名相同  形成函数重载</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myswap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用普通函数!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T  <span class="title">myswap</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用2个参数 模板函数!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T  <span class="title">myswap</span><span class="params">(T a, T b, T c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用3个参数 模板函数!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'z'</span>; </span><br><span class="line">    myswap(a,a);       <span class="comment">//优先考虑普通函数，匹配成功</span></span><br><span class="line">    myswap&lt;&gt;(a,a);     <span class="comment">//指定使用函数模板，使用空模板实参列表的语法，即 &lt;&gt;</span></span><br><span class="line">    myswap(c,a);       <span class="comment">//普通函数调用，进行隐式类型转换</span></span><br><span class="line"></span><br><span class="line">    myswap(<span class="number">3.0</span>, <span class="number">4.0</span>);  <span class="comment">//调用函数模板可以产生一个更好的匹配，使用函数模板，而普通函数参数是int型</span></span><br><span class="line">    myswap(<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">4.0</span>);   <span class="comment">//函数重载，3个参数版本</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C / C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 内存四区 理解总结</title>
      <link href="/2020/04/01/C++%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93/"/>
      <url>/2020/04/01/C++%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="内存模型图（4G）"><a href="#内存模型图（4G）" class="headerlink" title="内存模型图（4G）"></a>内存模型图（4G）</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/04/17/JZrp0U.png" alt="img"></p><h3 id="整体简单说明"><a href="#整体简单说明" class="headerlink" title="整体简单说明"></a>整体简单说明</h3><p>32位CPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中 <strong>0~3G是用户空间</strong>，<strong>3~4G是内核空间</strong>即<strong>3G用户空间和1G内核空间</strong>，不同进程相同的逻辑地址会映射到不同的物理地址中。</p><h3 id="各段详细说明"><a href="#各段详细说明" class="headerlink" title="各段详细说明"></a>各段详细说明</h3><p><strong>静态区域：</strong></p><p>text segment(<strong>代码段</strong>):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p><p>data segment(<strong>数据段</strong>)：存储程序中已初始化的全局变量和静态变量</p><p>bss segment(<strong>BSS段</strong>)：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0</p><p><strong>动态区域：</strong></p><p>heap（<strong>堆区</strong>）：  当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。</p><p>memory mapping segment(<strong>映射区</strong>):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）</p><p>stack（<strong>栈区</strong>）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。</p><h2 id="内存四区"><a href="#内存四区" class="headerlink" title="内存四区"></a>内存四区</h2><p>一个由C/C++编译的程序占用的内存分为以下几个部分：</p><ol><li><p><strong>栈区(stack)</strong>：就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是函数的返回地址、参数、局部变量、返回值等，从高地址向低地址增长。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。其操作方式类似于数据结构中的栈。</p></li><li><p><strong>堆区(heap)</strong>： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。</p><p>​    <strong>堆</strong>：是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free()可把内存交还。</p><p>​    <strong>自由存储区</strong>：自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区和堆区就有区别了。</p></li><li><p><strong>数据区</strong>：主要包括静态全局区和静态区，如果要站在汇编角度细分的话还可以分为很多小的区。</p><p>​    <strong>全局区&amp;静态区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的 C 语言中，全局变量和静态变量又分为</p></li></ol><p>　　　　全局初始化区(<strong>DATA段</strong>) ：存储程序中已初始化的全局变量和静态变量</p><p>　　　　未初始化段(<strong>BSS段</strong>) ：存储未初始化的全局变量和静态变量（局部+全局）。BSS段在DATA段的相邻的  另一块区域。BBS段特点：在程序执行前BBS段自动清零，所以未初始化的全局变量和静态变量在程序执行前已经成为0。</p><p>　　<font color=red><strong>在 C++ 里面没有这个区分了，它们共同占用同一块内存区。</strong></font></p><ol start="4"><li><strong>代码区</strong>：包括<strong>只读存储区</strong>和<strong>文本区</strong>，其中<strong>只读存储区</strong>存储<strong>字符串常量</strong>，就是常量区，<strong>文本区</strong>存储<strong>程序的机器代码</strong>。</li></ol><h2 id="明确区分堆与栈"><a href="#明确区分堆与栈" class="headerlink" title="明确区分堆与栈"></a>明确区分堆与栈</h2><p>在 BBS 上，堆与栈的区分问题，似乎是一个永恒的话题，由此可见，初学者对此往往是混淆不清的，所以我决定拿他第一个开刀。</p><p>首先，我们举一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; &#125;</span><br></pre></td></tr></table></figure><p>这条短短的一句话就包含了堆与栈，看到 new，我们首先就应该想到，我们分配了一块堆内存，那么指针 p  呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针 p。在程序会先确定在堆中分配内存的大小，然后调用  operator new 分配内存，然后返回这块内存的首地址，放入栈中，他在 VC6 下的汇编代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00401028</span>push <span class="number">14</span>h</span><br><span class="line"><span class="number">0040102</span><span class="function">Acall <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="number">00401060</span>)</span></span></span><br><span class="line">0040102Fadd esp,4</span><br><span class="line"><span class="number">00401032</span>mov dword ptr [ebp<span class="number">-8</span>],eax</span><br><span class="line"><span class="number">00401035</span>mov eax,dword ptr [ebp<span class="number">-8</span>]</span><br><span class="line"><span class="number">00401038</span>mov dword ptr [ebp<span class="number">-4</span>],eax</span><br></pre></td></tr></table></figure><p>这里，我们为了简单并没有释放内存，那么该怎么去释放呢？</p><p>是 delete p 么？噢，错了，应该是 delete []p，这是为了告诉编译器：我删除的是一个数组，VC6 就会根据相应的 Cookie 信息去进行释放内存的工作。</p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>好了，我们回到我们的主题：堆和栈究竟有什么区别？主要的区别由以下几点：</p><ol><li>管理方式不同；</li><li>空间大小不同；</li><li>能否产生碎片不同；</li><li>生长方向不同；</li><li>分配方式不同；</li><li>分配效率不同；</li></ol><p><strong><font color=red>管理方式：</font></strong>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p><p><strong><font color=red>空间大小：</font></strong>一般来讲在 32  位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：打开工程，依次操作菜单如下：Project-&gt;Setting-&gt;Link，在 Category 中选中 Output，然后在 Reserve 中设定堆栈的最大值和 commit。注意：reserve 最小值为  4Byte；commit 是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。</p><p><strong><font color=red>碎片问题：</font></strong>对于堆来讲，频繁的  new/delete  势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。</p><p><strong><font color=red>生长方向：</font></strong>对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</p><p><strong><font color=red>分配方式：</font></strong>堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p><p><strong><font color=red>分配效率：</font></strong>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是 C/C++  函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><p>​        从这里我们可以看到，堆和栈相比，由于大量 new/delete  的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP 和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。</p><p>　　虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。</p><p>　　无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候 debug 可是相当困难的）</p><p>　　对了，还有一件事，如果有人把堆栈合起来说，那它的意思是栈，可不是堆，呵呵，清楚了？</p><h2 id="static-用来控制变量的存储方式和可见性"><a href="#static-用来控制变量的存储方式和可见性" class="headerlink" title="static 用来控制变量的存储方式和可见性"></a>static 用来控制变量的存储方式和可见性</h2><p>函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？  最容易想到的方法是定义一个全局的变量，但定义为一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅受此函数控制）。需要一个数据对象为整个类而非某个对象服务，同时又力求不破坏类的封装性，即要求此成员隐藏在类的内部，对外不可见。</p><p><strong>static 的内部机制：</strong></p><p>　　静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；三是应用程序的 main(）函数前的全局数据声明和定义处。</p><p>　　静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的“尺寸和规格”，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。</p><p>　　static 被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。</p><p><strong>static 的优势：</strong></p><p>　　可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。引用静态数据成员时，采用如下格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;静态成员名&gt;</span><br></pre></td></tr></table></figure><p>　　如果静态数据成员的访问权限允许的话(即 public 的成员)，可在程序中，按上述格式来引用静态数据成员。</p><p>Ps：</p><p>　　(1) 类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。</p><p>　　(2) 不能将静态成员函数定义为虚函数。</p><p>　　(3) 由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针，函数地址类型是一个“nonmember 函数指针”。</p><p>　　(4) 由于静态成员函数没有 this 指针，所以就差不多等同于 nonmember 函数，结果就产生了一个意想不到的好处：成为一个  callback 函数，使得我们得以将 c++ 和 c-based x window 系统结合，同时也成功的应用于线程函数身上。</p><p>　　(5) static 并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。</p><p>　　(6) 静态数据成员在&lt;定义或说明&gt;时前面加关键字 static。</p><p>　　(7) 静态数据成员是静态存储的，所以必须对它进行初始化。</p><p>　　(8) 静态成员初始化与一般数据成员初始化不同：</p><p>　　初始化在类体外进行，而前面不加 static，以免与一般静态变量或对象相混淆；</p><p>　　初始化时不加该成员的访问权限控制符 private、public；</p><p>　　初始化时使用作用域运算符来标明它所属类；</p><p>　　所以我们得出静态数据成员初始化的格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</span><br></pre></td></tr></table></figure><p>　　(9)  为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。</p><p>​        <strong>注意：</strong>我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</p><h2 id="函数调用模型"><a href="#函数调用模型" class="headerlink" title="函数调用模型"></a>函数调用模型</h2><p>变量三要素是：名称、大小、作用域。那么变量的生命周期是多长呢？</p><p>编译器是如何管理每个函数间变量的生命周期呢？</p><p>要研究变量的生命周期，而变量一般又是在函数中定义分配空间的。</p><p>因此下面研究一下变量作为函数参数和返回值传递分析,下面我们具体总结一下，各个函数的变量的生命周期</p><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190809175733510-648621844.png" alt=""></p><p>main里面的变量分配内存，函数fa(),函数fb()中的变量分配的内存空间它们的生命周期都是多长呢？</p><p>开始已经说明了内存主要分为四区，因此每个函数中变量在堆栈的生命周期是不同的，同时在函数调用的时候，先执行的函数最后才执行完毕</p><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190809175748821-260989720.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">fa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span>*pa = <span class="string">"123456"</span>;<span class="comment">//pa指针在栈区，“123456”在常量区，该函数调用完后指针变量pa就被释放了</span></span><br><span class="line">     <span class="keyword">char</span>*p = <span class="literal">NULL</span>;     <span class="comment">//指针变量p在栈中分配4字节</span></span><br><span class="line">     p=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);<span class="comment">//本函数在这里开辟了一块堆区的内存空间，并把地址赋值给p</span></span><br><span class="line">     <span class="built_in">strcpy</span>(p, <span class="string">"wudunxiong 1234566"</span>);<span class="comment">//把常量区的字符串拷贝到堆区</span></span><br><span class="line">     <span class="keyword">return</span> p;<span class="comment">//返回给主调函数fb()，相对fa来说fb是主调函数，相对main来说，fa(),fb()都是被调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">fb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span>*pstr = <span class="literal">NULL</span>;</span><br><span class="line">     pstr = fa();</span><br><span class="line">     <span class="keyword">return</span> pstr;<span class="comment">//指针变量pstr在这就结束</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     <span class="keyword">char</span>*str = <span class="literal">NULL</span>;</span><br><span class="line">     str = fb();</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"str = %s\n"</span>,str);</span><br><span class="line">     <span class="built_in">free</span>(str);    <span class="comment">//防止内存泄露，被调函数fa()分配的内存存的值通过返回值传给主调函数，然后主调函数释放内存</span></span><br><span class="line">     str = <span class="literal">NULL</span>;<span class="comment">//防止产生野指针</span></span><br><span class="line">     system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用总结：</p><ol><li><p>主调函数分配的内存空间（堆，栈，全局区）可以在被调用函数中使用，可以以指针作函数参数的形式来使用</p></li><li><p>被调用函数分配的内存空间只有堆区和全局区可以在主调函数中使用（返回值和函数参数），而栈区却不行，因为栈区函数体运行完之后这个函数占用的内存编译器自动帮你释放了。</p></li><li><p>一定要明白函数的主被调关系以及主被调函数内存分配回收，也就是后面接下几篇总结的函数的输入输出内存模型</p></li></ol><p>[参考: <a href="https://www.cnblogs.com/WindSun/p/11328820.html]" target="_blank" rel="noopener">https://www.cnblogs.com/WindSun/p/11328820.html]</a></p>]]></content>
      
      
      <categories>
          
          <category> C / C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存四区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 重载、重写、重定义的区别</title>
      <link href="/2020/03/21/C++%20%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%87%8D%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/03/21/C++%20%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%87%8D%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="C-中-重载、重写、重定义的区别"><a href="#C-中-重载、重写、重定义的区别" class="headerlink" title="C++ 中 重载、重写、重定义的区别"></a>C++ 中 重载、重写、重定义的区别</h1><h2 id="重载（overload）"><a href="#重载（overload）" class="headerlink" title="重载（overload）"></a>重载（overload）</h2><p><strong>定义：</strong></p><p>在同一个作用域内，两函数的<strong>函数名相同</strong>, <strong>参数不相同</strong>（可以是参数类型不同或者是参数个数不同）, 那么就说这两个 <strong>函数重载</strong>。</p><p><strong>分类：</strong>函数重载 和 运算符重载 （本质都一样）</p><p><strong>注意：</strong> 返回值类型 <strong>不是</strong> 函数重载判断依据。</p><p><strong>成员函数重载特征：</strong></p><blockquote><p><strong>a : 相同的范围（在同一个类中）</strong></p><p><strong>b : 函数名字相同</strong></p><p><strong>c : 参数不同</strong></p></blockquote><p><strong>实现重载原理：</strong></p><p>C++代码在编译时会根据参数列表对函数进行重命名，例如void Test(int a, int b)会被重命名为_Test_int_int，void Test(int x, double y)会被重命名为_Test_int_double。所以说<strong>函数重载从底层上看它们还是不同的函数。</strong></p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"int a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"double a"</span> &lt;&lt; <span class="built_in">endl</span>;; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"int a , int b"</span> &lt;&lt; <span class="built_in">endl</span>;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//函数名相同，参数不同</span></span><br><span class="line">    fun(<span class="number">1</span>);</span><br><span class="line">    fun(<span class="number">1.1</span>);</span><br><span class="line">    fun(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>int a</p><p>double a</p><p>int a , int b</p></blockquote><h2 id="重写（override）"><a href="#重写（override）" class="headerlink" title="重写（override）"></a>重写（override）</h2><p><strong>定义：</strong></p><p>重写也叫做<strong>覆盖</strong>。子类 <strong>重新定义</strong> 父类中 <strong>有相同名称和参数</strong>  的 <strong>虚函数</strong>。函数<strong>特征相同</strong>，但是具体实现不同，主要是在<strong>继承关系</strong>中出现的 。简单说，<strong>重写(覆盖)</strong> 是指 <strong>派生类函数覆盖基类函数</strong> 。</p><p><strong>注意：</strong></p><ol><li><p>被重写的函数不能是 <strong>static</strong> 的。必须是 *<em>virtual *</em>的。</p></li><li><p>重写函数必须有 <strong>相同的类型，名称和参数列表</strong></p></li><li><p><strong>重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public,protected也是可以的</strong></p></li></ol><p><strong>特征：</strong></p><blockquote><p><strong>a : 不同的范围，分别位于基类和派生类中</strong></p><p><strong>b : 函数的名字相同</strong></p><p><strong>c : 参数相同</strong></p><p><strong>d : 基类函数必须有virtual关键字</strong></p></blockquote><p><strong>作用：</strong></p><blockquote><p>通过重写，可以实现动态多态，何为动态多态，就是当父类的指针或引用指向被重写的虚函数时，父类的指针或引用指向谁就调用谁的虚函数，而不是说根据类型。<br>在这里，如果去掉父类的虚函数的virtual，则构不成多态，如果去掉子类虚函数的virtual可以构成多态，可以理解为编译器优化。</p></blockquote><h2 id="重定义（redefining）"><a href="#重定义（redefining）" class="headerlink" title="重定义（redefining）"></a>重定义（redefining）</h2><p><strong>定义：</strong>重定义也叫做<strong>隐藏</strong>。子类 <strong>重新定义</strong> 父类中有 <strong>相同名称</strong> 的 <strong>非虚函数</strong> ( 参数列表可以不同 ) 。也就是说，<strong>重定义(隐藏)</strong> 是指 <strong>派生类的函数屏蔽了与其同名的基类函数</strong>。</p><p><strong>规则：</strong></p><blockquote><p><strong>a : 如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual，基类的函数被隐藏。</strong></p><p><strong>b : 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 vitual 关键字，此时，基类的函数被隐藏。</strong></p></blockquote><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>分析：</strong></p><p>很明显，<strong>子类隐藏了父类的f函数</strong>，这个题目比较迷惑人的是<strong>子类的f函数有参数</strong>，所以<strong>会以为调的是父类的f函数</strong>； 但是<strong>隐藏只与函数名有关</strong>，与<strong>参数</strong>是没关系的，所以<strong>调用的还是子类的f函数</strong>，这个程序会<strong>提示出错</strong>（可能是没有匹配的重载函数之类的错误）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C / C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 变量声明 定义 作用域 链接性总结</title>
      <link href="/2020/03/19/C++%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%20%E5%AE%9A%E4%B9%89%20%E4%BD%9C%E7%94%A8%E5%9F%9F%20%E9%93%BE%E6%8E%A5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/19/C++%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%20%E5%AE%9A%E4%B9%89%20%E4%BD%9C%E7%94%A8%E5%9F%9F%20%E9%93%BE%E6%8E%A5%E6%80%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>变量的定义用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>用于向程序表明变量的类型和名字。程序中变量可以声明多次，但只能定义一次。</p><h2 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h2><p>（1）<strong>自动存储变量：</strong>在函数定义中声明的变量(包括函数参数)。当函数或代码块执行时创建变量，当函数或代码块执行完时，这些变量的内存被释放。这类变量在 <strong>栈</strong> 中分配内存。<br>（2）<strong>静态持续变量：</strong>在函数定义外定义的变量和使用关键字 <strong>static</strong> 定义的变量，简称 <strong>静态变量*</strong>。这类变量在程序整个运行过程中都存在<br>（3）<strong>动态存储变量：</strong> 由 <strong>new</strong> 运算符分配内存的变量，直到使用delete运算符将其释放或程序结束。这类变量在 <strong>堆</strong>（自由存储区） 中分配内存。<br>（4）<strong>线程存储变量：</strong>此变量生命周期和线程一样长。这里不做过多解释。</p><p>​                                                                                     <strong>5种变量储存方式</strong></p><table><thead><tr><th align="center">存储描述</th><th align="center">持续性</th><th align="center">作用域</th><th align="center">链接性</th><th>如何声明</th></tr></thead><tbody><tr><td align="center">自动</td><td align="center">自动</td><td align="center">代码块</td><td align="center">无</td><td>在代码块中</td></tr><tr><td align="center">寄存器</td><td align="center">自动</td><td align="center">代码块</td><td align="center">无</td><td>在代码块中，使用关键字 register</td></tr><tr><td align="center">静态，无链接性</td><td align="center">静态</td><td align="center">代码块</td><td align="center">无</td><td>在代码块中，使用关键字 static</td></tr><tr><td align="center">静态，外部链接性</td><td align="center">静态</td><td align="center">文件</td><td align="center">外部</td><td>不在任何函数内</td></tr><tr><td align="center">静态，内部链接性</td><td align="center">静态</td><td align="center">文件</td><td align="center">内部</td><td>不在任何函数内，使用关键字 static</td></tr></tbody></table><h2 id="述了名称在文件的多大范围内可见。"><a href="#述了名称在文件的多大范围内可见。" class="headerlink" title="述了名称在文件的多大范围内可见。"></a>述了名称在文件的多大范围内可见。</h2><p>（1）全局作用域：从变量定义到文件结尾都可用，所以也叫 文件作用域。<br>（2）局部作用域：如自动变量的作用域在函数内部。</p><h2 id="链接性"><a href="#链接性" class="headerlink" title="链接性"></a>链接性</h2><p>（1）<strong>外部链接性：</strong>可在其它文件中访问。<br>（2）<strong>内部链接性：</strong>只能在当前文件中访问。<br>（3）<strong>无链接性：</strong>只能在当前函数或代码块中访问。</p><h2 id="静态持续变量初始化"><a href="#静态持续变量初始化" class="headerlink" title="静态持续变量初始化"></a>静态持续变量初始化</h2><p>（1）如果没有显示的初始化静态变量，编译器将把它设置为0<br>（2）在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int global &#x3D; 1000;</span><br><span class="line">static int one_file &#x3D; 50;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">void fun(int n)</span><br><span class="line">&#123;</span><br><span class="line">static int count &#x3D; 0;</span><br><span class="line">int llama &#x3D; 0;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：global和one_file的作用域都为整个文件，global的链接性为外部，所以可以在程序的其他文件使用它，而 one_file的链接性为内部，只可以在本文件中使用它。（程序是多文件）<br>count和llama作用域是局部的，没有链接性，也就是说只能在fun()中用它们。因为count变量是静态变量，所以count变量一直存在，即使fun()函数没有执行。而llama变量是当fun()函数执行时被创建，当fun()函数执行完后被释放内存。</p><h2 id="多文件使用外部链接性变量"><a href="#多文件使用外部链接性变量" class="headerlink" title="多文件使用外部链接性变量"></a>多文件使用外部链接性变量</h2><p>只需在一个文件中包含该变量的定义（单定义规则），但在使用该变量的其他所有文件中，都必须使用关键字 extern 声明它。<br>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;file1.cpp</span><br><span class="line">int cat &#x3D; 20;  &#x2F;&#x2F;在file1.cpp中定义cat变量</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;file2.cpp</span><br><span class="line">extern cat;   &#x2F;&#x2F;在file2.cpp中使用cat变量要先用extern声明</span><br><span class="line">cout &lt;&lt; cat &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>现在读者应该对变量有了更深刻的认识了</p>]]></content>
      
      
      <categories>
          
          <category> C / C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 数组类型语法总结</title>
      <link href="/2020/03/18/C%20%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/18/C%20%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="数组类型语法总结"><a href="#数组类型语法总结" class="headerlink" title="数组类型语法总结"></a>数组类型语法总结</h1><h2 id="数组指针-和-指针数组-区分"><a href="#数组指针-和-指针数组-区分" class="headerlink" title="数组指针 和 指针数组 区分"></a>数组指针 和 指针数组 区分</h2><p><strong>数组指针</strong>是一个指针，只对应类型的数组。<strong>指针数组</strong>是一个数组，其中每个元素都是指针<br><strong>数组指针</strong>遵循指针运算法则。<strong>指针数组</strong>拥有c语言数组的各种特性</p><h2 id="数组类型重命名"><a href="#数组类型重命名" class="headerlink" title="数组类型重命名"></a>数组类型重命名</h2><p>C 通过 <strong>typedef</strong> 为数组类型 <strong>重命名</strong></p><p>*<em>格式 : *</em>typedef type (name)[size]</p><h3 id="定义数组类型"><a href="#定义数组类型" class="headerlink" title="定义数组类型"></a>定义数组类型</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef int (aint)[10];</span><br><span class="line">typedef float (afloat)[10];</span><br></pre></td></tr></table></figure><h3 id="用数组类型定义数组"><a href="#用数组类型定义数组" class="headerlink" title="用数组类型定义数组"></a>用数组类型定义数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aint iarray; <span class="comment">//定义了一个数组</span></span><br><span class="line">afloat farray; <span class="comment">//定义了一个数组</span></span><br></pre></td></tr></table></figure><h3 id="定义指针数组类型"><a href="#定义指针数组类型" class="headerlink" title="定义指针数组类型"></a>定义指针数组类型</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef int (*Paint)[10];</span><br><span class="line">typedef float (*Pafloat)[10];</span><br></pre></td></tr></table></figure><h3 id="定义指向数组的指针"><a href="#定义指向数组的指针" class="headerlink" title="定义指向数组的指针"></a>定义指向数组的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type(*pointer)[n]; </span><br><span class="line"><span class="comment">//pointer 是一个指针，type代表指向的数组的类型，n为指向的数组的大小。</span></span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">typedef int (aint)[10];   //定义一个数组类型</span><br><span class="line">typedef int (*Paint)[10]; //定义一个指针数组类型</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">aint myarr;</span><br><span class="line">myarr[<span class="number">0</span>] = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, myarr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Paint Pmyarr;</span><br><span class="line">Pmyarr = &amp;a;</span><br><span class="line">(*Pmyarr)[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*pointer)[<span class="number">10</span>];  <span class="comment">//定义一个指向数组类型的指针</span></span><br><span class="line">pointer = &amp;a;</span><br><span class="line">(*pointer)[<span class="number">0</span>] = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C / C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 函数指针语法总结</title>
      <link href="/2020/03/18/C%20%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/18/C%20%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="C-函数指针语法总结"><a href="#C-函数指针语法总结" class="headerlink" title="C 函数指针语法总结"></a>C 函数指针语法总结</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>每一个函数都占用一段内存单元，它们有一个起始地址，指向函数入口地址的指针称为<strong>函数指针</strong>。</p><p><strong>注意：</strong>函数指针的本质是一个指针变量，且指针指向的函数的<strong>入口地址</strong>。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>返回类型 (*函数名) (参数表);</p><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//定义一个函数指针pFUN，它指向一个返回类型为char，有一个整型的参数的函数</span></span><br><span class="line"><span class="keyword">char</span> (*pFun)(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//定义一个返回类型为char，参数为int的函数</span></span><br><span class="line"><span class="comment">//从指针层面上理解该函数，即函数的函数名实际上是一个指针，</span></span><br><span class="line"><span class="comment">//该指针指向函数在内存中的首地址</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">glFun</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">    <span class="comment">//return a;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//将函数glFun的地址赋值给变量pFun</span></span><br><span class="line">    pFun = glFun;</span><br><span class="line"><span class="comment">//*pFun”显然是取pFun所指向地址的内容，</span></span><br><span class="line">当然也就是取出了函数glFun()的内容，然后给定参数为<span class="number">2</span>。</span><br><span class="line">    (*pFun)(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//pfun(2);  也是对的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数指针类型"><a href="#函数指针类型" class="headerlink" title="函数指针类型"></a>函数指针类型</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><strong>typedef</strong> 返回类型 (*函数名) (参数表);</p><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//定义一个函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span> <span class="params">(*mypFun)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//定义一个返回类型为char，参数为int的函数</span></span><br><span class="line"><span class="comment">//从指针层面上理解该函数，即函数的函数名实际上是一个指针，</span></span><br><span class="line"><span class="comment">//该指针指向函数在内存中的首地址</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">glFun</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">    <span class="comment">//return a;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义一个函数指针变量，将函数glFun的地址赋值给变量myp</span></span><br><span class="line">    mypFun myp = glFun;</span><br><span class="line"><span class="comment">//*pFun”显然是取pFun所指向地址的内容，</span></span><br><span class="line"><span class="comment">//当然也就是取出了函数glFun()的内容，然后给定参数为2。</span></span><br><span class="line">    (*myp)(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//myp(2);  也是对的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="历史与逻辑"><a href="#历史与逻辑" class="headerlink" title="历史与逻辑"></a>历史与逻辑</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(*myp)(<span class="number">2</span>);<span class="comment">//下文用 星myp表示</span></span><br><span class="line">myp(<span class="number">2</span>);  </span><br><span class="line"><span class="comment">//两种写法都是对的</span></span><br></pre></td></tr></table></figure><blockquote><p>真是非常棒的语法! 为何 myp 和 （ 星 myp）等价呢?一种学派认为，由于 myp 是函数指针，而 （ 星 myp）是函数，因此应将 ( 星 myp)() 用作函数调用。另一种学派认为，由于函数名是指向该函数的指针，指向函数的指针的行为应与函数名相似，因此应将 myp() 用作函数调用使用。C++ 进行了折衷——这 2种方式都是正确的，或者至少是允许的，虽然它们在逻辑上是互相冲突的。在认为这种折衷粗糙之前，应该想到，容忍逻辑上无法自圆其说的观点正是人类思维活动的特点。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C / C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 默认拷贝构造函数 深度拷贝和浅拷贝</title>
      <link href="/2020/03/17/C++%20%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%20%E6%B7%B1%E5%BA%A6%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2020/03/17/C++%20%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%20%E6%B7%B1%E5%BA%A6%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="C-类默认拷贝构造函数的弊端"><a href="#C-类默认拷贝构造函数的弊端" class="headerlink" title="C++类默认拷贝构造函数的弊端"></a>C++类默认拷贝构造函数的弊端</h2><p>C++类的中有两个特殊的构造函数，(1)无参构造函数，(2)拷贝构造函数。它们的特殊之处在于：<br>(1) 当类中没有定义任何构造函数时，编译器会默认提供一个无参构造函数且其函数体为空；<br>(2) 当类中没有定义拷贝构造函数时，编译器会默认提供一个拷贝构造函数，进行成员变量之间的拷贝。<font color=red><strong>(这个拷贝操作是浅拷贝)</strong></font></p><p>这里只讲拷贝构造函数。在C语言中，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;  <span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">b = <span class="number">6</span>;      <span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><p>上面的初始化及赋值操作是最正常不过的语法，C++语言肩挑兼容C语言语法的责任，所以在类的设计上，也兼容这种操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cls</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">pubic:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cls c1;</span><br><span class="line">    cls c2 = c1;    <span class="comment">//初始化类，还可以 cls c2(c1);</span></span><br><span class="line">    cls c3;</span><br><span class="line"></span><br><span class="line">    c3 = c1;        <span class="comment">//赋值类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上的初始化类需要调用到cls类的默认实现的拷贝构造函数，为类赋值需要调用的是cls类的默认实现的赋值操作符重载函数，它们都是<strong>浅度拷贝</strong>的。前者其原型为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cls(<span class="keyword">const</span> cls&amp; c)</span><br></pre></td></tr></table></figure><p>默认的拷贝构造函数存在弊端，看如下类定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCls</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TestCls()   <span class="comment">//无参构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"TestCls()"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~TestCls()     <span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;   </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"~TestCls()"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类中的指针p在构造函数中分配的空间，在析构函数中释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TestCls t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行确实不会出错： </p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20170724193220977?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjkzNDQ3NTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>类在我们没有定义拷贝构造函数的时候，会默认定义默认拷贝构造函数，也就是说可以直接用同类型的类间可以相互赋值、初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TestCls t1;</span><br><span class="line">    TestCls t2 = t1;   <span class="comment">//效果等同于TestCls t2(t1);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译通过，运行却出错了： </p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20170724193330339?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjkzNDQ3NTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><font color=red>原因就在于，默认的拷贝构造函数实现的是<strong>浅拷贝</strong>。</font></p><h2 id="深度拷贝和浅拷贝"><a href="#深度拷贝和浅拷贝" class="headerlink" title="深度拷贝和浅拷贝"></a>深度拷贝和浅拷贝</h2><p>深度拷贝和浅拷贝在c语言中就经常遇到的了，在这里我简单描述。<br> <strong>一般的<font color=red>赋值操作</font>是深度拷贝：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度拷贝</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br></pre></td></tr></table></figure><p><strong>简单的<font color=red>指针指向</font>，则是浅拷贝：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* str1 = <span class="string">"HelloWorld"</span>;</span><br><span class="line"><span class="keyword">char</span>* str2 = str1;</span><br></pre></td></tr></table></figure><p><strong>将上面的浅拷贝改为深度拷贝后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度拷贝</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*p = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* str1 = <span class="string">"HelloWorld"</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str1);</span><br><span class="line"><span class="keyword">char</span> *str2 = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(str2, str1, len);</span><br></pre></td></tr></table></figure><p><strong>总而言之，拷贝者和被拷贝者若是<font color=red>同一个地址</font>，则为浅拷贝，反之为深拷贝。</strong></p><p>例：以字符串拷贝为例，<strong>浅拷贝</strong>后，str1和str2同指向0x123456，不管哪一个指针，对该空间内容的修改都会影响另一个指针。 </p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20170724193601382?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjkzNDQ3NTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>深拷贝</strong>后，str1和str2指向不同的内存空间，各自的空间的内容一样。因为空间不同，所以不管哪一个指针，对该空间内容的修改都不会影响另一个指针。</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20170724193622381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjkzNDQ3NTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="解决默认拷贝构造函数的弊端"><a href="#解决默认拷贝构造函数的弊端" class="headerlink" title="解决默认拷贝构造函数的弊端"></a>解决默认拷贝构造函数的弊端</h2><p>类的默认拷贝构造函数只会用被拷贝类的成员的值为拷贝类简单初始化，也就是说二者的p指针指向的内存空间是一致的。以前面TestCls可以知道，编译器为我们默认定义的拷贝构造函数为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TestCls(<span class="keyword">const</span> TestCls&amp; testCls)</span><br><span class="line">&#123;</span><br><span class="line">    a = testCls.a;</span><br><span class="line">    p = testCls.p;      <span class="comment">//两个类的p指针指向的地址一致。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong><font color=red>main函数将要退出时，拷贝类t2的析构函数先得到执行，它把自身p指向的堆空间释放了；接下来，t1的析构函数得到调用，被拷贝类t1的析构函数得到调用，它同样要去析构自身的p指向指向的堆空间，但是该空间和t2类中p指向的空间一样，造成重复释放，程序运行崩溃。</font></p><p>解决办法十分简单，自定义拷贝构造函数，里面用深度拷贝的方式为拷贝类初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCls</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TestCls()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"TestCls()"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TestCls(<span class="keyword">const</span> TestCls&amp; testCls)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"TestCls(const TestCls&amp; testCls)"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        a = testCls.a;</span><br><span class="line">        <span class="comment">//p = testCls.p;</span></span><br><span class="line">        p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line">        *p = *(testCls.p);      <span class="comment">//为拷贝类的p指针分配空间，实现深度拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~TestCls()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;   </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"~TestCls()"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TestCls t1;</span><br><span class="line">    TestCls t2 = t1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行正常：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20170724194101197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjkzNDQ3NTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>关于c++拷贝构造函数的深度拷贝和浅拷贝的介绍到这里，其实还可以将它们的地址打印出来看看，不过这一步就不再赘述了。</p><h2 id="拷贝构造函数其它妙用"><a href="#拷贝构造函数其它妙用" class="headerlink" title="拷贝构造函数其它妙用"></a>拷贝构造函数其它妙用</h2><p>自定义拷贝构造函数，并设置为private属性，其实现体可以什么都不写，那么这个类将变成一个不可被复制的类了。</p><p>[参考博文: <a href="https://blog.csdn.net/qq_29344757/article/details/76037255]" target="_blank" rel="noopener">https://blog.csdn.net/qq_29344757/article/details/76037255]</a></p>]]></content>
      
      
      <categories>
          
          <category> C / C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ new 运算符 用法总结</title>
      <link href="/2020/03/17/C++%20new%20%E8%BF%90%E7%AE%97%E7%AC%A6%20%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/17/C++%20new%20%E8%BF%90%E7%AE%97%E7%AC%A6%20%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="C-new-运算符-用法总结"><a href="#C-new-运算符-用法总结" class="headerlink" title="C++ new 运算符 用法总结"></a>C++ new 运算符 用法总结</h1><h2 id="使用-new-运算符-分配内存-并-初始化"><a href="#使用-new-运算符-分配内存-并-初始化" class="headerlink" title="使用 new 运算符 分配内存 并 初始化"></a>使用 new 运算符 分配内存 并 初始化</h2><p>1.分配内存初始化标量类型（如 int 或 double），在类型名后加初始值，并用小括号括起，C++11中也支持大括号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">6</span>); </span><br><span class="line"><span class="keyword">double</span> * pd = <span class="keyword">new</span> <span class="keyword">double</span> (<span class="number">9.99</span>); </span><br><span class="line"><span class="comment">//C++11中, 支持以下写法</span></span><br><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">new</span> <span class="keyword">int</span> &#123;<span class="number">6</span>&#125;; </span><br><span class="line"><span class="keyword">double</span> * pd = <span class="keyword">new</span> <span class="keyword">double</span> &#123;<span class="number">9.99</span>&#125;;</span><br></pre></td></tr></table></figure><p>2.初始化结构或数组，需要使用大括号列表初始化 ，需编译器 <strong>支持 C++11</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">where</span>&#123;</span><span class="keyword">double</span> x; <span class="keyword">double</span> y; <span class="keyword">double</span> z;&#125;;</span><br><span class="line">where * one = <span class="keyword">new</span> where &#123;<span class="number">1.2</span>, <span class="number">2.2</span>, <span class="number">3.2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> * ar = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">4</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p>3.使用 delete 释放 new分配的内存 （仅限于常规 new 分配的 堆内存）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pi;</span><br><span class="line"><span class="keyword">delete</span> pd;</span><br><span class="line"><span class="keyword">delete</span> one;</span><br><span class="line"><span class="comment">// 释放数组 记住 加[]</span></span><br><span class="line"><span class="keyword">delete</span> [] ar;</span><br></pre></td></tr></table></figure><p>4.创建类对象</p><p>（1）new创建对象，pTest用来接收对象指针。new申请的对象，则只有调用到delete时才会执行析构函数，如果程序退出而没有执行delete则会造成内存泄漏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTest*  pTest = <span class="keyword">new</span>  CTest();  <span class="keyword">delete</span> pTest;</span><br></pre></td></tr></table></figure><p>（2）不用new，直接使用类定义申明，使用完后不需要手动释放，该类析构函数会自动执行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTest  mTest;</span><br></pre></td></tr></table></figure><p>（3）使用普通方式创建的类对象，在创建之初就已经分配了内存空间。而类指针，如果未经过对象初始化，则不需要delete释放：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTest*  pTest = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h2 id="new-失败时处理方式"><a href="#new-失败时处理方式" class="headerlink" title="new 失败时处理方式"></a>new 失败时处理方式</h2><p>1.常规分配内存，调用构造函数。分配失败时，<strong>抛出异常</strong>。定义如下：</p><blockquote><p>void* operator new(std::size_t) throw(std::bad_alloc);</p><p>void operator delete(void *) throw();</p><p><strong>分配失败则抛出异常std::bad_alloc，不是返回NULL，所以判断返回值是否为NULL是没用的</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">size</span>]; <span class="comment">//分配失败，不是返回NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure><p>2.<strong>不抛出异常</strong>。分配失败时，返回NULL。定义如下：</p><blockquote><p>void* operator new(std::size_t,const std::nothrow_t&amp;) throw();</p><p>void operator delete(void*) throw();</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p=<span class="keyword">new</span>(nothrow) <span class="keyword">char</span>[<span class="built_in">size</span>]; <span class="comment">//分配失败，是返回NULL</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span>==p)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"alloc failure!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="new-运算符、函数和替换函数"><a href="#new-运算符、函数和替换函数" class="headerlink" title="new: 运算符、函数和替换函数"></a>new: 运算符、函数和替换函数</h2><p>运算符new 和 new [] 分别调用如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span></span>;<span class="comment">//use by new</span></span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span> [] (<span class="built_in">std</span>::<span class="keyword">size_t</span>);<span class="comment">//use by new []</span></span><br></pre></td></tr></table></figure><p>运算符delete 和 delete [] 分别调用如下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *)</span></span>;<span class="comment">//use by delete</span></span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">delete</span> [](<span class="keyword">void</span> *);<span class="comment">//use by delete []</span></span><br></pre></td></tr></table></figure><p>这些函数称为 <strong>分配函数</strong> ，位于全局名称空间中。std::size_t 是一个 typedef。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">//将转换为下面这样</span></span><br><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">new</span> (<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span>];</span><br><span class="line"><span class="comment">//将转换为下面这样</span></span><br><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">new</span> (<span class="number">40</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样的</span></span><br><span class="line"><span class="keyword">delete</span> pi;</span><br><span class="line"><span class="comment">//将转换为下面这样</span></span><br><span class="line"><span class="keyword">delete</span> (pi);</span><br></pre></td></tr></table></figure><h2 id="定位-placement-new-运算符"><a href="#定位-placement-new-运算符" class="headerlink" title="定位 placement new 运算符"></a>定位 placement new 运算符</h2><p>通常，new负责在 堆 中分配一个足以满足要求的内存块，但 <strong>定位new可以让程序员指定要使用的内存位置</strong>。不会内存分配失败，因为它根本不分配内存，只调用对象的构造函数。它允许在一块已经分配成功的内存上重新构造对象或对象数组。定义如下：</p><p>void* operator new(size_t,void*);</p><p>void operator delete(void<em>,void</em>);</p><p>1.使用 定位new运算符，首先要包含 <strong>头文件 new</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chaff</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> dross[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> slag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">char</span> buffer1[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">char</span> buffer2[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chaff * p1, p2;</span><br><span class="line">    p2 = <span class="keyword">new</span> (buffer1) chaff;<span class="comment">// 在buffer1中</span></span><br><span class="line">    p2 = <span class="keyword">new</span> (buffer2) <span class="keyword">int</span>[<span class="number">20</span>]; <span class="comment">// 在buffer2中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用placement new构造起来的对象或数组，要<strong>显式调用它们的析构函数</strong>来销毁（析构函数并不释放对象的内存），千万不要使用delete.这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。</p><p>3.当使用new运算符定义一个多维数组变量或数组对象时，它产生一个指向数组第一个元素的指针，返回的类型保持了除最左边维数外的所有维数。</p>]]></content>
      
      
      <categories>
          
          <category> C / C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ pragma once 与 ifndef 用法区别</title>
      <link href="/2020/03/15/C++%20pragma%20once%20%E4%B8%8E%20ifndef%20%E7%94%A8%E6%B3%95%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/03/15/C++%20pragma%20once%20%E4%B8%8E%20ifndef%20%E7%94%A8%E6%B3%95%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="pragma-once-与-ifndef-的作用"><a href="#pragma-once-与-ifndef-的作用" class="headerlink" title="#pragma once 与 #ifndef 的作用"></a>#pragma once 与 #ifndef 的作用</h2><p>（1）在C/C++中，在使用预编译指令#include的时候，为了防止重复引用造成二义性。<br>（2）在能够支持这两种方式的编译器上，二者并没有太大的区别，但是两者仍然还是有一些细微的区别。</p><h2 id="pragma-once-与-ifndef-的用法"><a href="#pragma-once-与-ifndef-的用法" class="headerlink" title="#pragma once 与 #ifndef 的用法"></a>#pragma once 与 #ifndef 的用法</h2><h3 id="pragma-once"><a href="#pragma-once" class="headerlink" title="#pragma once"></a>#pragma once</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br></pre></td></tr></table></figure><p>###*<em>#ifndef *</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _CODE_BLOCK</span><br><span class="line">#define _CODE_BLOCK</span><br><span class="line">&#x2F;&#x2F; code</span><br><span class="line">...  </span><br><span class="line">#endif &#x2F;&#x2F; _CODE_BLOCK</span><br></pre></td></tr></table></figure><h2 id="pragma-once-与-ifndef-两者各有何特点"><a href="#pragma-once-与-ifndef-两者各有何特点" class="headerlink" title="#pragma once 与 #ifndef 两者各有何特点"></a>#pragma once 与 #ifndef 两者各有何特点</h2><h3 id="pragma-once-1"><a href="#pragma-once-1" class="headerlink" title="#pragma once"></a>#pragma once</h3><p>在C/C++中，#pragma once是一个<strong>非标准但是被广泛支持</strong>的方式。</p><p><strong>介绍：</strong>#pragma once 一般由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件。</p><p><strong>优点：</strong>你不必再担心宏名冲突了，当然也就不会出现宏名冲突引发的奇怪问题。大型项目的编译速度也因此提高了一些。</p><p><strong>缺点：</strong>如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名冲突引发的“找不到声明”的问题，这种   重复包含很容易被发现并修正。另外，这种方式不支持跨平台！</p><h3 id="ifndef"><a href="#ifndef" class="headerlink" title="#ifndef"></a>#ifndef</h3><p><strong>介绍：</strong>#ifndef的方式受<strong>C/C++语言标准支持</strong>, ，也是比较常用的方式。</p><p><strong>优点：</strong>它不仅可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件(或者代码片段)不会被不小心同时包含。</p><p><strong>缺点：</strong>就是如果不同头文件中的宏名不小心“撞车”，可能就会导致你看到头文件明明存在，但编译器却硬说找不到声明的状况——这种情况有时非常让人郁闷。 由于编译器每次都需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，ifndef会使得编译时间相对较长，因此一些编译器逐渐开始支持#pragma once的方式。(Visual Studio 2017新建头文件会自带#pragma once指令)。<br>##两者之间的联系</p><p>（1）#pragma once 方式产生于 #ifndef 之后，因此很多人可能甚至没有听说过。目前看来#ifndef更受到推崇。因为#ifndef受C/C++语言标准的支持，不受编译器的任何限制；而#pragma once方式却不受一些较老版本的编译器支持 (如GCC 3.4版本之前不支持#pragmaonce) ，一些支持了的编译器又打算去掉它，所以它的兼容性可能不够好。<br>（2） #ifndef可以针对一个文件中的部分代码，而#pragma once只能针对整个文件。</p><p>##总结</p><p>相对而言，#ifndef  <strong>更加灵活，兼容性好，移植性好</strong>  ，而 #pragma once <strong>操作简单，可以避免名字冲突，效率高</strong>。</p><p>看起来似乎是想兼有两者的优点。不过只要使用了 #ifndef 就会有宏名冲突的危险，也无法避免不支持#pragma once的编译器报错，所以混用两种方法似乎不能带来更多的好处，倒是会让一些不熟悉的人感到困惑。</p><p>选择哪种方式，应该在了解两种方式的情况下，视具体情况而定。只要有一个合理的约定来避开缺点，我认为哪种方式都是可以接受的。而这个已经不是标准或者编译器的责任了，应当由程序员自己或者小范围内的开发规范来搞定。</p><p>##最后<br>一般而言，当程序员听到这样的话，都会选择 #ifndef 方式，为了努力使得自己的代码“存活”时间更久，通常宁愿降低一些编译性能，这是程序员的个性，当然这是题外话啦。</p>]]></content>
      
      
      <categories>
          
          <category> C / C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 类中关于常量定义理解总结</title>
      <link href="/2020/03/15/C++%20%E7%B1%BB%E4%B8%AD%20%E5%85%B3%E4%BA%8E%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89%20%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/15/C++%20%E7%B1%BB%E4%B8%AD%20%E5%85%B3%E4%BA%8E%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89%20%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>##前言<br>有时我们希望某些常量只在类中有效。由于#define定义的宏常量是 <strong>全局</strong> 的，不能达到目的，于是想当然地觉得应该用 <strong>const修饰</strong> 数据成员来实现。const数据成员的确是存在的，但其含义却不是我们所期望的。const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的，因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。</p><p>##正题<br>（1）不能在类声明中初始化 const 数据成员。以下用法是错误的，因为类的对象未被创建时，编译器不知道 SIZE 的值是什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A </span><br><span class="line">&#123;</span><br><span class="line">  const int SIZE &#x3D; 100;   &#x2F;&#x2F; 错误，企图在类声明中初始化 const 数据成员 </span><br><span class="line">  int array[SIZE];  &#x2F;&#x2F; 错误，未知的 SIZE </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（2）const 数据成员的初始化只能在类构造函数的初始化表中进行，例如某变量可以在构造函数的函数体中初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A </span><br><span class="line">&#123;</span><br><span class="line">  A(int size);  &#x2F;&#x2F; 构造函数 </span><br><span class="line">  const int SIZE ;    </span><br><span class="line">&#125;; </span><br><span class="line">A::A(int size) : SIZE(size)  &#x2F;&#x2F; 构造函数的</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">A  a(200); &#x2F;&#x2F; 对象 a 的 SIZE 值为 200 </span><br><span class="line">A  b(300); &#x2F;&#x2F; 对象 b 的 SIZE 值为 300</span><br></pre></td></tr></table></figure><p>##建立在整个类中都恒定的常量<br>以下介绍两种方法：</p><p>1.用类中的枚举常量来实现。例如 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A </span><br><span class="line">&#123;</span><br><span class="line">  enum &#123; SIZE1 &#x3D; 100, SIZE2 &#x3D; 200&#125;; &#x2F;&#x2F; 枚举常量</span><br><span class="line">  int array1[SIZE1];  </span><br><span class="line">  int array2[SIZE2]; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>枚举常量不会占用对象的存储空间，它们在编译时被全部求值。</p><p><strong>缺点：</strong>它的隐含数据类型是整数，其最大值有限，且不能表示浮点数（如 PI=3.14159）。</p><p>2.使用关键字 *<em>static *</em> 来实现。例如 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line"> static const int SIZE&#x3D;100;</span><br><span class="line"> int array[SIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>这将创建一个名为SIZE的常量，该常量将与其他静态变量存储在一起，而不是存储在某个对象中。因此，此常量将被整个类的所有对象共享</p><p><strong>注意：</strong>只能利用这种技术声明值为整数或者枚举的静态常量，或者说只有static const的整型或枚举型量才能如此初始化。而不能存储double类型的常量。这就很有局限性，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Y </span><br><span class="line">&#123;</span><br><span class="line">  const int c3 &#x3D; 7;          &#x2F;&#x2F; error: not static</span><br><span class="line">  static int c4 &#x3D; 7;         &#x2F;&#x2F; error: not const</span><br><span class="line">  static const float c5 &#x3D; 7; &#x2F;&#x2F; error not integral</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注：在自己的VC++6.0运行static const int c4 = 7;是报错的，估计是编译器太老了</strong></p><p>##下面是关于类中 static 的几点详细说明：<br>（1）tatic 是 <strong>属于整个类</strong> 的，不是属于对象的；<br>（2） static 数据成员和普通数据成员一样，不能在类定义体中进行初始化，应该在类定义体外进行初始化，初始化时不要在加static 修饰；注意，static数据成员不是通过类构造函数进行初始化的！<br>（3）static const int数据成员在类定义体内直接初始化，这里 <strong>只能是int</strong> ，不能是其他。<br>（4）static 数据成员的类型可以使是该成员所属的类类型，非static数据成员被限定为其自生类对象的指针或引用。<br>（5）static 成员函数 <strong>没有this指针</strong> 。<br>（6）static 成员函数不能声明为const。为什么呢？因为static成员函数不是任何对象的组成部分。const成员函数是指不会修改该成员函数所属的对象。<br>（7） static 成员函数可以直接访问所属类的static成员，不能访问非static成员，也不能直接使用非static成员函数！也不能访问static const 类型的成员！</p><blockquote><p>那么，为何要有这些不方便的限制？因为类通常声明在头文件中，而头文件往往被许多单元所包含。但是，为了避免链接器设计的复杂化，C++要求每个对象都只能被定义一次。如果C++允许类内定义要作为对象被存在内存中的实体，那么这项要求 就无法满足了。关于C++设计时的一些折衷，参见《The Design and Evolution of C++》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C / C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 入门到进阶学习路线</title>
      <link href="/2020/03/13/C++%20%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%20%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2020/03/13/C++%20%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%20%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>学习这件事不在乎有没有人教你，最重要的是在于你自己有没有觉悟和恒心。             —— 法布尔</strong></p></blockquote><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>随着互联网及互联网+深入蓬勃的发展，经过40余年的时间洗礼，C/C++俨然已成为一门贵族语言，出色的性能使之成为高级语言中的性能王者。而在今天，它又扮演着什么样重要的角色呢？请往下看：</p><p>后端服务器，移动互联网后端，经典Windows界面开发，移动互联网端界面开发，跨平台界面开发，图形分析，系统架构，应用设计，还有现在最为流行的分布架构等一些新的技术领域。</p><p>这么牛的语言，你是不是想知道怎样学习和掌握它呢？接下来请看经过小编整理过C/C++工程师必备知识的思维导图。</p><p>初学者看到这么密集的知识点，是不是有点眼晕呢？的确，C/C++是一门知识面覆盖很广的学科。想学好C/C++的你并不需要慌张，内容虽多，但依然有法可依。只要有足够的耐心和毅力，加上正确的学习方法，就不怕你学不好C/C++。</p><p>既然如此，C/C++开发到底需要学些什么呢，又应该怎么学呢？请大家继续往下看。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/09/03/wCTVqe.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/09/03/wCTAKO.jpg" alt=""></p><h1 id="初级入门阶段"><a href="#初级入门阶段" class="headerlink" title="初级入门阶段"></a>初级入门阶段</h1><p>在入门之初，首先要做的是通过C/C++语言的学习培养编程思维和动手能力，深刻理解面向过程和面向对象的思想方法。这个阶段你需要学习：</p><h2 id="①-C语言"><a href="#①-C语言" class="headerlink" title="① C语言"></a>① C语言</h2><p>数据类型、变量、内存布局、指针基础；</p><p>字符串、一维数组、二维数组；</p><p>一级指针，二级指针，三级指针，N级指针概念，指针数组和数组指针；</p><p>结构体、文件的使用；</p><p>动态库的封装和设计；</p><p>函数指针回调函数。</p><h2 id="②-C-语言"><a href="#②-C-语言" class="headerlink" title="② C++语言"></a>② C++语言</h2><p>面向对象编程思想；</p><p>类的封装，构造和析构、静态成员、对象管理；</p><p>类的构造(有参构造函数、无参构造、拷贝构造、默认构造函数)和析构；</p><p>对象动态管理、友元函数、友元类、操作符重载；</p><p>C++编译器对象管理模型分析；</p><p>类对象的动态管理(new/delete)；</p><p>友元函数和友元类；</p><p>运算符重载(一元运算符、二元运算符、运算符重载难点、项目开发中的运算符重载)；</p><p>类的继承、多继承及其二义性、虚继承；</p><p>多态(概念、意义、原理剖析、多态案例)；</p><p>虚函数、纯虚函数、抽象类(面向抽象类编程思想案例)；</p><p>函数模板、类模板，模板的继承；</p><p>C++类型转换；</p><p>C++输入输出流(标准I/O 文件I/O 字符流I/O)；</p><p>C++异常处理(异常机制、异常类型、异常变量、异常层次结构、标准异常库)；</p><h2 id="③-常用的IDE开发工具"><a href="#③-常用的IDE开发工具" class="headerlink" title="③ 常用的IDE开发工具"></a>③ 常用的IDE开发工具</h2><p>诸如Windows平台VC系列：VC++6.0(比较古老) ；Visual Studio2013, Visual Studio2015；Mac平台的XCode系列，还有CodeBlock，另附<br>一些高级编辑器Notepad++, EditPlus,UE等一些开发工具的常用设置和一些常见快捷键的使用。</p><p>此阶段的学习难度系数不大，掌握这些内容之后，可以做些简单的小项目。当然了如果你想用这些技能找工作的话确实是比较困难的。这<br>时你还应该在加把劲进一步学习第二阶段。</p><h1 id="C-C-开发进阶"><a href="#C-C-开发进阶" class="headerlink" title="C/C++ 开发进阶"></a>C/C++ 开发进阶</h1><p>这一阶段的目标才是达到C/C++软件工程师开发行业的基本要求，这个阶段是我们走向C/C++开发的进阶之路，更是一个让自己找份薪水比较体面的工作的筹码。</p><p>如果在此部分遇到不懂的或者没有见过的知识点和名词，可先将本文收藏，供以后细细研读。</p><p>那么这个阶段，我们又应该掌握什么呢，继续往下看：</p><h2 id="①-C-进阶之STL"><a href="#①-C-进阶之STL" class="headerlink" title="① C++进阶之STL"></a>① C++进阶之STL</h2><p>STL = Standard Template Library，即标准模板库。这是提高开发效率的极品工具。通过学习此阶段，应掌握泛型编程技巧，理解容器类在C++语言中的应用模式，以及熟练掌握全部STL类的使用方法。</p><h2 id="②-C-进阶之设计模式"><a href="#②-C-进阶之设计模式" class="headerlink" title="② C++进阶之设计模式"></a>② C++进阶之设计模式</h2><p>决定一个项目成败最重要的因素是项目总体的设计，通过本阶段的学习，可掌握面向对象编程中重要的一环，是编码前建模的技巧所在。单例模式；工厂模式；代理模式；迭代模式等，这些都是你要掌握的哦。</p><h2 id="③-C-进阶之数据结构基础"><a href="#③-C-进阶之数据结构基础" class="headerlink" title="③ C++进阶之数据结构基础"></a>③ C++进阶之数据结构基础</h2><p>这是所有编程语言中最应该学习的部分，程序组成的基础之一。</p><p>顺序存储、链式存储、循环链表；</p><p>双向链表、栈(顺序和链式)、队列(顺序和链式)；</p><p>栈的应用、树基本概念及遍历、二叉树；</p><p>排序算法、并归算法、选择、插入、快速、希尔。</p><p>以上这些内容你知道吗?</p><h2 id="④-C-进阶之UI界面开发"><a href="#④-C-进阶之UI界面开发" class="headerlink" title="④ C++进阶之UI界面开发"></a>④ C++进阶之UI界面开发</h2><p>掌握QT类库构架，图形界面开发模型；</p><p>掌握QT开发技巧，消息机制，图形处理；</p><p>掌握QT网络编程，UDP，TCP使用方式；</p><p>掌握QT文件处理方式，序列化；</p><p>掌握QT在windows，linux，ios，android不同平台下的移植技术。</p><h2 id="⑤-C-进阶之Unix-Linux网络服务器"><a href="#⑤-C-进阶之Unix-Linux网络服务器" class="headerlink" title="⑤ C++进阶之Unix Linux网络服务器"></a>⑤ C++进阶之Unix Linux网络服务器</h2><p>掌握Unix/Linux平台开发方式；</p><p>熟练使用系统调用；</p><p>熟练Unix/Linux内存管理，进程，线程调度；</p><p>熟悉网络服务器开发方式，熟练编写TCP，UCP网络服务程序；</p><p>掌握同步/异步IO模型在网络编程中的使用方式。</p><h2 id="⑥-C-进阶之数据库开发"><a href="#⑥-C-进阶之数据库开发" class="headerlink" title="⑥ C++进阶之数据库开发"></a>⑥ C++进阶之数据库开发</h2><p>掌握SQL语言的实用技巧。Oracle,MySQL数据库的使用方式。</p><p>如果你能熟练掌握以上列出的技能，具备解决复杂问题和技术难点的能力，而且你能独立开发一些比较复杂的功能模块，那么很荣幸地<br>告诉你，你已经达到中级水平，薪资过万对你来说简直是小菜一碟。</p><h1 id="C-开发高级"><a href="#C-开发高级" class="headerlink" title="C++ 开发高级"></a>C++ 开发高级</h1><p>读到此处的你，相信你有更高的目标。即是当下炙手可热的全栈开发工程师，既晓前端，又通后台。快速定位问题，解决问题对他们来说<br>已是小菜一碟，就是人们常说的神秘大牛，只在公司技术攻关的时候才会才看到他们的身影。</p><p>①此阶段软件开发工作所需的知识和技能相对较难，高级软件工程师编码熟练度和规范性需要达到一定要求；</p><p>②具备一定的项目能力(包括调试能力、文档编写能力、测试能力等)和综合技术素质(包括对软件生命周期的理解、对设计模式的理解、<br>必备的行业知识和经验等)；.</p><p>③了解主流的后台技术和前后端协作方式，能从全局角度理解项目的整个生命周期。</p><p>如果你能熟练掌握以上三个阶段的知识技能,那么你就可以满足C++开发行业的高级需求。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p><strong>不经一番彻骨寒，哪有梅花扑鼻香?</strong></p>]]></content>
      
      
      <categories>
          
          <category> C / C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github 完美解决网页打开慢的问题</title>
      <link href="/2020/03/13/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3Github%E7%BD%91%E9%A1%B5%E6%89%93%E5%BC%80%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/13/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3Github%E7%BD%91%E9%A1%B5%E6%89%93%E5%BC%80%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用Github的时候，网页加载很慢，因为是国外的服务器，加载总是很慢。这里我们通过修改本地host文件方法，只需非常简单的几步<br>操作，就能让 Github 页面能非常快速打开。</p><h2 id="修改host文件"><a href="#修改host文件" class="headerlink" title="修改host文件"></a>修改host文件</h2><ol><li>找到 C:\Windows\System32\drivers\etc目录下 <strong>hosts</strong> 文件。</li><li>可以把文件复制到桌面，用 <strong>Notepad++</strong> 编辑器打开修改,修改完成后再放进去。</li><li>打开之后添加以下内容。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Github</span><br><span class="line">151.101.44.249 github.global.ssl.fastly.net</span><br><span class="line">192.30.253.113 github.com</span><br><span class="line">103.245.222.133 assets-cdn.github.com</span><br><span class="line">23.235.47.133 assets-cdn.github.com</span><br><span class="line">203.208.39.104 assets-cdn.github.com</span><br><span class="line">204.232.175.78 documentcloud.github.com</span><br><span class="line">204.232.175.94 gist.github.com</span><br><span class="line">107.21.116.220 help.github.com</span><br><span class="line">207.97.227.252 nodeload.github.com</span><br><span class="line">199.27.76.130 raw.github.com</span><br><span class="line">107.22.3.110 status.github.com</span><br><span class="line">204.232.175.78 training.github.com</span><br><span class="line">207.97.227.243 www.github.com</span><br><span class="line">185.31.16.184 github.global.ssl.fastly.net</span><br><span class="line">185.31.18.133 avatars0.githubusercontent.com</span><br><span class="line">185.31.19.133 avatars1.githubusercontent.com</span><br><span class="line">192.30.253.120 codeload.github.com</span><br></pre></td></tr></table></figure><ol start="4"><li>保存后 按<strong>电脑键 + R</strong> 打开 运行 输入 <strong>cmd</strong> ，进入命令界面后，输入: <strong>ipconfig/flushdns</strong> ，显示 <strong>dns刷新成功</strong><br>这样本地host文件生效就ok了！！</li></ol><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/09/03/wCO3Mq.png" alt=""></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>重启浏览器再打开Github页面就很快了，亲测有效哦，有需要的小伙伴赶快试试吧！！</p>]]></content>
      
      
      <categories>
          
          <category> 开发配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VsCode C/C++ 开发环境配置 详细教程</title>
      <link href="/2020/03/11/VSCode%20C++%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"/>
      <url>/2020/03/11/VSCode%20C++%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Vscode是一个轻量级的编辑器，但是配置有点复杂，这里我做了C/C++开发环境配置总结，适用于windows/Linux系统</p><h1 id="整体步骤"><a href="#整体步骤" class="headerlink" title="整体步骤"></a>整体步骤</h1><ol><li>安装VSCode</li><li>在VSCode内安装c++插件</li><li>安装编译调试环境</li><li>修改VSCode调试配置文件</li></ol><h1 id="安装VsCode"><a href="#安装VsCode" class="headerlink" title="安装VsCode"></a>安装VsCode</h1><p>下载地址：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a><br>如下图选择适合自己系统的下载之后安装就行</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130195410736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>注意：建议直接安装在Ｃ盘，方便配置，软件大小本身不大！！！</strong></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020013021212998.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>注意：一定要将 添加到PATH 这项打钩！！！</strong></p><h1 id="安装C-插件"><a href="#安装C-插件" class="headerlink" title="安装C++插件"></a>安装C++插件</h1><p>打开VScode,在左侧一栏，最下面一个图标是扩展商店，或者快捷键==ctrl+shift+x==直接切换到商店界面，然后输入C++，然后点击安装，安装之后重启生效，安装其他插件也是在这里搜索安装</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130200351109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><strong>这里我推荐几个我学习码代码常用的插件：</strong></p></blockquote><p>1) 名称: Chinese (Simplified) Language 中文界面配置插件，英语大神请忽略</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130201257789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2) 名称: vscode-icons　图标插件可以使得文件结构更加清晰</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130201508877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>3) 名称: Bracket Pair Colorizer　括号高亮，彩虹括号</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020013023541629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>4) 名称: One Dark Pro　一个非常好看的黑色界面主题插件</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130201954999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>5) 名称: Code Runner　代码运行插件，右键即可编译运行单文件，很方便</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130202812602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="安装编译调试环境"><a href="#安装编译调试环境" class="headerlink" title="安装编译调试环境"></a>安装编译调试环境</h1><h2 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h2><h3 id="安装-mingw-w64"><a href="#安装-mingw-w64" class="headerlink" title="安装 mingw-w64"></a>安装 mingw-w64</h3><p>目前windows下调试仅支持 <strong>Cygwin</strong> 和 <strong>MinGW</strong>，<strong>mingw-w64</strong> ，本文这里使用<strong>mingw-w64</strong>．<br><strong>mingw-w64</strong>下载地址：<a href="https://sourceforge.net/projects/mingw-w64/files/" target="_blank" rel="noopener">https://sourceforge.net/projects/mingw-w64/files/</a></p><p>选择图中红色标记，点击会自动跳转下载页面下载</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130211439730.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>下载完后，直接将 mingw-w64 解压到一个合适的目录，比如我解压C:\Program Files下。推荐放C盘，路径好找，只有600M左右，不影响。</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ol><li><p>找到解压的目录，复制解压出来的bin目录的地址<img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130220932379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>右击此电脑选择属性</p></li></ol><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130221008700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="3"><li>依次点击 高级系统设置 – 环境变量</li></ol><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130221121666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="4"><li>点击Path，选择编辑，用户变量和系统变量两个Path都要改哦</li></ol><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130222311819.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="5"><li>新建，将复制的目录位置粘贴到此，确定</li></ol><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130221940639.png" alt="在这里插入图片描述"></p><ol start="6"><li>在桌面上按住shift点击鼠标右键-在此处打开powershell， 输入 <strong>gcc -v</strong>, 看到如下界面说明环境变量配置成功</li></ol><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130222125450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>   或者检查 win+R cmd 输入 gcc -v，看到如下界面说明环境变量配置成功</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130223152764.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="配置VS-Code调试环境"><a href="#配置VS-Code调试环境" class="headerlink" title="配置VS Code调试环境"></a>配置VS Code调试环境</h3><ol><li><p>建议配置之前新建一个目录专门用来存储C/CPP文件，因为配置设置VS Code会默认保存到配置时文件的目录下。我这里创建有一个 *<em>CPP *</em>文件夹</p></li><li><p>打开<strong>CPP</strong>文件夹，新建 <strong>.vscode</strong>文件夹并打开</p></li></ol><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130223639407.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="3"><li>在 <strong>.vscode</strong> 文件夹中，依次新建3个文件，名称如下：<pre><code>**c_cpp_properties.json**   **launch.json**   **tasks.json**</code></pre></li></ol><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130223957798.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="4"><li><p>配置这3个文件</p><blockquote><p><strong>launch.json</strong> 文件如下图配置<br><strong>“miDebuggerPath”:后面修改为你的 mingw64 路径</strong><br><strong>“preLaunchTask”: “task g++”</strong> 和 <strong>tasks.json</strong> 中的  <strong>“label”: “task g++”</strong> 引号中的名字要一致，本代码中为 <strong>task g++</strong></p></blockquote></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"(gdb) Launch"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"cppdbg"</span>,<span class="comment">//配置类型，只能为cppdbg</span></span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,<span class="comment">//请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe"</span>,<span class="comment">//调试程序的路径名称</span></span><br><span class="line">            <span class="string">"args"</span>: [],<span class="comment">//调试传递参数</span></span><br><span class="line">            <span class="string">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">            <span class="string">"environment"</span>: [],</span><br><span class="line">            <span class="string">"externalConsole"</span>: <span class="literal">true</span>,<span class="comment">//true显示外置的控制台窗口，false显示内置终端</span></span><br><span class="line">            <span class="string">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">            <span class="string">"miDebuggerPath"</span>: <span class="string">"C:\\mingw64\\bin\\gdb.exe"</span>, </span><br><span class="line">            <span class="string">"setupCommands"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"description"</span>: <span class="string">"Enable pretty-printing for gdb"</span>,</span><br><span class="line">                    <span class="string">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">                    <span class="string">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"preLaunchTask"</span>: <span class="string">"task g++"</span>,<span class="comment">//调试前执行的任务，就是之前配置的tasks.json中的label字段</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>tasks.json</strong> 文件如下图配置</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558 </span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="string">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"task g++"</span>,<span class="comment">//任务的名字，就是刚才在命令面板中选择的时候所看到的，可以自己设置</span></span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"g++"</span>,</span><br><span class="line">            <span class="string">"args"</span>: [<span class="comment">//编译时候的参数</span></span><br><span class="line">                <span class="string">"-g"</span>,<span class="comment">//添加gdb调试选项</span></span><br><span class="line">                <span class="string">"$&#123;file&#125;"</span>,</span><br><span class="line">                <span class="string">"-o"</span>,<span class="comment">//指定生成可执行文件的名称</span></span><br><span class="line">                <span class="string">"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"problemMatcher"</span>: &#123;</span><br><span class="line">                <span class="string">"owner"</span>: <span class="string">"cpp"</span>,</span><br><span class="line">                <span class="string">"fileLocation"</span>: [</span><br><span class="line">                    <span class="string">"relative"</span>,</span><br><span class="line">                    <span class="string">"$&#123;workspaceRoot&#125;"</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">"pattern"</span>: &#123;</span><br><span class="line">                    <span class="string">"regexp"</span>: <span class="string">"^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$"</span>,</span><br><span class="line">                    <span class="string">"file"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">"line"</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="string">"column"</span>: <span class="number">3</span>,</span><br><span class="line">                    <span class="string">"severity"</span>: <span class="number">4</span>,</span><br><span class="line">                    <span class="string">"message"</span>: <span class="number">5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"group"</span>: &#123;</span><br><span class="line">                <span class="string">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">                <span class="string">"isDefault"</span>: <span class="literal">true</span><span class="comment">//表示快捷键Ctrl+Shift+B可以运行该任务</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>c_cpp_properties.json</strong> 文件如下图配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Win32&quot;,</span><br><span class="line">            &quot;includePath&quot;: [</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;&#x2F;**&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;defines&quot;: [</span><br><span class="line">                &quot;_DEBUG&quot;,</span><br><span class="line">                &quot;UNICODE&quot;,</span><br><span class="line">                &quot;_UNICODE&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;compilerPath&quot;: &quot;C:&#x2F;mingw64&#x2F;bin&#x2F;g++.exe&quot;,</span><br><span class="line">            &quot;cStandard&quot;: &quot;c11&quot;,</span><br><span class="line">            &quot;cppStandard&quot;: &quot;c++17&quot;,</span><br><span class="line">            &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>配置完上面3项，你的vscode应该就可以正常调试了</li></ol><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130230807783.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020013023082953.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="6"><li>最后几点注意：</li></ol><blockquote><p>【1】程序文件路径不要有 <strong>中文</strong>，否则可能会导致 <strong>调试失败</strong></p><p>【2】vscode设置保留在单文件夹中，你如果要更换文件夹，请把 <strong>.vscode</strong> 文件夹也复制到你要更改的文件夹中</p></blockquote><h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><h3 id="安装-gdb-调试环境"><a href="#安装-gdb-调试环境" class="headerlink" title="安装 gdb 调试环境"></a>安装 gdb 调试环境</h3><ol><li><p>打开终端，在root用户权限下：输入以下命令</p><p> <strong>apt-get update</strong><br> <strong>apt-get install gdb</strong></p><p> 如图，按提示操作即可，等待程序执行完成就安装好gdb了</p></li></ol><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130231718693.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="2"><li><p>参考上面windows教程，安装 <strong>vscode</strong>，安装拓展插件，新建文件夹和4个配置文件。<br> <strong>参考命令：</strong><br> <strong>deb包安装方式步骤：</strong> </p><pre><code>1、找到相应的软件包，比如soft.version.deb，下载到本机某个目录； 2、打开一个终端，su -成root用户； 3、cd soft.version.deb所在的目录； 4、输入dpkg -i soft.version.deb</code></pre></li><li><p>配置这4个文件</p><blockquote><p><strong>launch.json</strong> 文件如下图配置<br> <strong>“miDebuggerPath”:后面修改为你的 gdb 路径</strong><br> <strong>“preLaunchTask”: “build”</strong> 和 <strong>tasks.json</strong> 中的  <strong>“label”: “build”</strong> 引号中的名字要一致，本代码中为 <strong>build</strong></p></blockquote></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"debug"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out"</span>,</span><br><span class="line">            <span class="string">"args"</span>: [],</span><br><span class="line">            <span class="string">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">            <span class="string">"environment"</span>: [],</span><br><span class="line">            <span class="string">"externalConsole"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">            <span class="string">"setupCommands"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"description"</span>: <span class="string">"Enable pretty-printing for gdb"</span>,</span><br><span class="line">                    <span class="string">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">                    <span class="string">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"preLaunchTask"</span>: <span class="string">"build"</span>,</span><br><span class="line">            <span class="string">"miDebuggerPath"</span>: <span class="string">"/usr/bin/gdb"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>tasks.json</strong> 文件如下图配置</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 有关 tasks.json 格式的文档，请参见</span></span><br><span class="line">        <span class="comment">// https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">        <span class="string">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">        <span class="string">"tasks"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"label"</span>: <span class="string">"build"</span>,</span><br><span class="line">                <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">                <span class="string">"command"</span>: <span class="string">"g++"</span>,</span><br><span class="line">                <span class="string">"args"</span>: [</span><br><span class="line">                    <span class="string">"-g"</span>,</span><br><span class="line">                    <span class="string">"$&#123;file&#125;"</span>,</span><br><span class="line">                    <span class="string">"-o"</span>,</span><br><span class="line">                    <span class="string">"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out"</span>,</span><br><span class="line">                    <span class="string">"-l"</span>,</span><br><span class="line">                    <span class="string">"pthread"</span></span><br><span class="line">    ​</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">"presentation"</span>: &#123;</span><br><span class="line">                    <span class="string">"reveal"</span>: <span class="string">"never"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"problemMatcher"</span>: [</span><br><span class="line">                    <span class="string">"$gcc"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>c_cpp_properties.json</strong> 文件如下图配置</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"Linux"</span>,</span><br><span class="line">            <span class="string">"includePath"</span>: [</span><br><span class="line">                <span class="string">"$&#123;workspaceFolder&#125;/**"</span>,</span><br><span class="line">                <span class="string">"/usr/include/**"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"defines"</span>: [],</span><br><span class="line">            <span class="string">"compilerPath"</span>: <span class="string">"/usr/bin/gcc"</span>,</span><br><span class="line">            <span class="string">"cStandard"</span>: <span class="string">"c11"</span>,</span><br><span class="line">            <span class="string">"cppStandard"</span>: <span class="string">"c++17"</span>,</span><br><span class="line">            <span class="string">"intelliSenseMode"</span>: <span class="string">"gcc-x64"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"version"</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>settings.json</strong>文件如下图配置</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"files.associations"</span>: &#123;</span><br><span class="line">        <span class="string">"iostream"</span>: <span class="string">"cpp"</span>,</span><br><span class="line">        <span class="string">"stdio.h"</span>: <span class="string">"c"</span>,</span><br><span class="line">        <span class="string">"ostream"</span>: <span class="string">"cpp"</span>,</span><br><span class="line">        <span class="string">"array"</span>: <span class="string">"cpp"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>配置完上面4项，你的vscode应该就可以正常调试了</li></ol><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130234319465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200130234342433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="5"><li>最后几点注意：</li></ol><p>【1】程序文件路径不要有==中文==，否则会导致==调试失败</p><p>【2】vscode设置保留在单文件夹中，你如果要更换文件夹，请把 <strong>.vscode</strong>    文件夹也复制到你要更改的文件夹中</p><p>【3】中文显示乱码问题 VS code 编码设置/文件乱码<br>     点击文件-&gt;首选项-&gt;设置，然后在右边用户设置输入：<br>    <strong>“files.autoGuessEncoding”: true,</strong><br>    插入这一行内用并保存。<br>    或者如下图打钩：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200225182246263.png" alt="在这里插入图片描述">加</p><p>入这个设置后，VSCode会在打开文件时尝试猜测字符集编码。</p><p>【4】VSCode内部终端运行代码</p><p>设置在终端运行 : 首选项 -&gt; 设置 -&gt; 扩展 -&gt; Run Code ，勾选 ”Run In Terminal“ 和 ”Save File Before Run”</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200225183007201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxMjIwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这样的话 写个demo运行一下吧(这里是右击运行的，也可以用快捷键，不过这里的快捷键已经被我修改过了)</p>]]></content>
      
      
      <categories>
          
          <category> 开发配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> VsCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
